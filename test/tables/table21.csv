CWE-ID,Name,Weakness Abstraction,Status,Description,Extended Description,Related Weaknesses,Weakness Ordinalities,Applicable Platforms,Background Details,Alternate Terms,Modes Of Introduction,Exploitation Factors,Likelihood of Exploit,Common Consequences,Detection Methods,Potential Mitigations,Observed Examples,Functional Areas,Affected Resources,Taxonomy Mappings,Related Attack Patterns,Notes
708,Incorrect Ownership Assignment,Base,Incomplete,"The product assigns an owner to a resource, but the owner is outside of the intended control sphere.",This may allow the resource to be manipulated by actors outside of the intended control sphere.,::NATURE:ChildOf:CWE ID:282:VIEW ID:1000:ORDINAL:Primary::NATURE:CanAlsoBe:CWE ID:345:VIEW ID:1000::,,::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::,,,::PHASE:Architecture and Design::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::PHASE:Operation::,,,::SCOPE:Confidentiality:SCOPE:Integrity:IMPACT:Read Application Data:IMPACT:Modify Application Data:NOTE:An attacker could read and modify data for which they do not have permissions to access directly.::,,::PHASE:Policy:DESCRIPTION:Periodically review the privileges and their owners.::PHASE:Testing:DESCRIPTION:Use automated tools to check for privilege settings.::,"::REFERENCE:CVE-2007-5101:DESCRIPTION:File system sets wrong ownership and group when creating a new file.:LINK:https://www.cve.org/CVERecord?id=CVE-2007-5101::REFERENCE:CVE-2007-4238:DESCRIPTION:OS installs program with bin owner/group, allowing modification.:LINK:https://www.cve.org/CVERecord?id=CVE-2007-4238::REFERENCE:CVE-2007-1716:DESCRIPTION:Manager does not properly restore ownership of a reusable resource when a user logs out, allowing privilege escalation.:LINK:https://www.cve.org/CVERecord?id=CVE-2007-1716::REFERENCE:CVE-2005-3148:DESCRIPTION:Backup software restores symbolic links with incorrect uid/gid.:LINK:https://www.cve.org/CVERecord?id=CVE-2005-3148::REFERENCE:CVE-2005-1064:DESCRIPTION:Product changes the ownership of files that a symlink points to, instead of the symlink itself.:LINK:https://www.cve.org/CVERecord?id=CVE-2005-1064::REFERENCE:CVE-2011-1551:DESCRIPTION:Component assigns ownership of sensitive directory tree to a user account, which can be leveraged to perform privileged operations.:LINK:https://www.cve.org/CVERecord?id=CVE-2011-1551::",,,,,"::TYPE:Maintenance:NOTE:This overlaps verification errors, permissions, and privileges. A closely related weakness is the incorrect assignment of groups to a resource. It is not clear whether it would fall under this entry or require a different entry.::"
733,Compiler Optimization Removal or Modification of Security-critical Code,Base,Incomplete,"The developer builds a security-critical protection mechanism into the software, but the compiler optimizes the program such that the mechanism is removed or modified.",,::NATURE:ChildOf:CWE ID:1038:VIEW ID:1000:ORDINAL:Primary::,,::LANGUAGE NAME:C:LANGUAGE PREVALENCE:Often::LANGUAGE NAME:C++:LANGUAGE PREVALENCE:Often::LANGUAGE CLASS:Compiled:LANGUAGE PREVALENCE:Undetermined::,,,,,,::SCOPE:Access Control:SCOPE:Other:IMPACT:Bypass Protection Mechanism:IMPACT:Other::,"::METHOD:Black Box:DESCRIPTION:This specific weakness is impossible to detect using black box methods. While an analyst could examine memory to see that it has not been scrubbed, an analysis of the executable would not be successful. This is because the compiler has already removed the relevant code. Only the source code shows whether the programmer intended to clear the memory or not, so this weakness is indistinguishable from others.::METHOD:White Box:DESCRIPTION:This weakness is only detectable using white box methods (see black box detection factor). Careful analysis is required to determine if the code is likely to be removed by the compiler.::",,"::REFERENCE:CVE-2008-1685:DESCRIPTION:C compiler optimization, as allowed by specifications, removes code that is used to perform checks to detect integer overflows.:LINK:https://www.cve.org/CVERecord?id=CVE-2008-1685::REFERENCE:CVE-2019-1010006:DESCRIPTION:Chain: compiler optimization (CWE-733) removes or modifies code used to detect integer overflow (CWE-190), allowing out-of-bounds write (CWE-787).:LINK:https://www.cve.org/CVERecord?id=CVE-2019-1010006::",,,,::10::24::46::8::9::,
749,Exposed Dangerous Method or Function,Base,Incomplete,"The product provides an Applications Programming Interface (API) or similar interface for interaction with external actors, but the interface includes a dangerous method or function that is not properly restricted.","This weakness can lead to a wide variety of resultant weaknesses, depending on the behavior of the exposed method. It can apply to any number of technologies and approaches, such as ActiveX controls, Java functions, IOCTLs, and so on. The exposure can occur in a few different ways: The function/method was never intended to be exposed to outside actors. The function/method was only intended to be accessible to a limited set of actors, such as Internet-based access from a single web site.",::NATURE:ChildOf:CWE ID:284:VIEW ID:1000:ORDINAL:Primary::,::ORDINALITY:Primary::,::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::,,,::PHASE:Architecture and Design::PHASE:Implementation::,,,::SCOPE:Integrity:SCOPE:Confidentiality:SCOPE:Availability:SCOPE:Access Control:SCOPE:Other:IMPACT:Gain Privileges or Assume Identity:IMPACT:Read Application Data:IMPACT:Modify Application Data:IMPACT:Execute Unauthorized Code or Commands:IMPACT:Other:NOTE:Exposing critical functionality essentially provides an attacker with the privilege level of the exposed functionality. This could result in the modification or exposure of sensitive data or possibly even execution of arbitrary code.::,,"::PHASE:Architecture and Design:DESCRIPTION:If you must expose a method, make sure to perform input validation on all arguments, limit access to authorized parties, and protect against all possible vulnerabilities.::PHASE:Architecture and Design Implementation:STRATEGY:Attack Surface Reduction:DESCRIPTION:Identify all exposed functionality. Explicitly list all functionality that must be exposed to some user or set of users. Identify which functionality may be: accessible to all users restricted to a small set of privileged users prevented from being directly accessible at all Ensure that the implemented code follows these expectations. This includes setting the appropriate access modifiers where applicable (public, private, protected, etc.) or not marking ActiveX controls safe-for-scripting.::",::REFERENCE:CVE-2007-6382:DESCRIPTION:arbitrary Java code execution via exposed method:LINK:https://www.cve.org/CVERecord?id=CVE-2007-6382::REFERENCE:CVE-2007-1112:DESCRIPTION:security tool ActiveX control allows download or upload of files:LINK:https://www.cve.org/CVERecord?id=CVE-2007-1112::,,,,::500::,"::TYPE:Research Gap:NOTE:Under-reported and under-studied. This weakness could appear in any technology, language, or framework that allows the programmer to provide a functional interface to external parties, but it is not heavily reported. In 2007, CVE began showing a notable increase in reports of exposed method vulnerabilities in ActiveX applications, as well as IOCTL access to OS-level resources. These weaknesses have been documented for Java applications in various secure programming sources, but there are few reports in CVE, which suggests limited awareness in most parts of the vulnerability research community.::"
756,Missing Custom Error Page,Base,Incomplete,"The product does not return custom error pages to the user, possibly exposing sensitive information.",,::NATURE:ChildOf:CWE ID:755:VIEW ID:1000:ORDINAL:Primary::NATURE:CanPrecede:CWE ID:209:VIEW ID:1000::,,,,,,,,"::SCOPE:Confidentiality:IMPACT:Read Application Data:NOTE:Attackers can leverage the additional information provided by a default error page to mount attacks targeted on the framework, database, or other resources used by the application.::",,,,,,,,
757,Selection of Less-Secure Algorithm During Negotiation ('Algorithm Downgrade'),Base,Incomplete,"A protocol or its implementation supports interaction between multiple actors and allows those actors to negotiate which algorithm should be used as a protection mechanism such as encryption or authentication, but it does not select the strongest algorithm that is available to both parties.","When a security mechanism can be forced to downgrade to use a less secure algorithm, this can make it easier for attackers to compromise the product by exploiting weaker algorithm. The victim might not be aware that the less secure algorithm is being used. For example, if an attacker can force a communications channel to use cleartext instead of strongly-encrypted data, then the attacker could read the channel by sniffing, instead of going through extra effort of trying to decrypt the data using brute force techniques.",::NATURE:ChildOf:CWE ID:693:VIEW ID:1000:ORDINAL:Primary::,,,,,::PHASE:Architecture and Design:NOTE:COMMISSION: This weakness refers to an incorrect design related to an architectural security tactic.::,,,::SCOPE:Access Control:IMPACT:Bypass Protection Mechanism::,,,::REFERENCE:CVE-2006-4302:DESCRIPTION:Attacker can select an older version of the software to exploit its vulnerabilities.:LINK:https://www.cve.org/CVERecord?id=CVE-2006-4302::REFERENCE:CVE-2006-4407:DESCRIPTION:Improper prioritization of encryption ciphers during negotiation leads to use of a weaker cipher.:LINK:https://www.cve.org/CVERecord?id=CVE-2006-4407::REFERENCE:CVE-2005-2969:DESCRIPTION:chain: SSL/TLS implementation disables a verification step (CWE-325) that enables a downgrade attack to a weaker protocol.:LINK:https://www.cve.org/CVERecord?id=CVE-2005-2969::REFERENCE:CVE-2001-1444:DESCRIPTION:Telnet protocol implementation allows downgrade to weaker authentication and encryption using an Adversary-in-the-Middle AITM attack.:LINK:https://www.cve.org/CVERecord?id=CVE-2001-1444::REFERENCE:CVE-2002-1646:DESCRIPTION:SSH server implementation allows override of configuration setting to use weaker authentication schemes. This may be a composite with CWE-642.:LINK:https://www.cve.org/CVERecord?id=CVE-2002-1646::,,,,::220::606::620::,"::TYPE:Relationship:NOTE:This is related to CWE-300, although not all downgrade attacks necessarily require an entity that redirects or interferes with the network. See examples.::"
763,Release of Invalid Pointer or Reference,Base,Incomplete,"The product attempts to return a memory resource to the system, but it calls the wrong release function or calls the appropriate release function incorrectly.","This weakness can take several forms, such as: The memory was allocated, explicitly or implicitly, via one memory management method and deallocated using a different, non-compatible function (CWE-762). The function calls or memory management routines chosen are appropriate, however they are used incorrectly, such as in CWE-761.",::NATURE:ChildOf:CWE ID:404:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:404:VIEW ID:1003:ORDINAL:Primary::NATURE:ChildOf:CWE ID:404:VIEW ID:1340:ORDINAL:Primary::,,,,,::PHASE:Implementation::,,,"::SCOPE:Integrity:SCOPE:Availability:SCOPE:Confidentiality:IMPACT:Modify Memory:IMPACT:DoS: Crash, Exit, or Restart:IMPACT:Execute Unauthorized Code or Commands:NOTE:This weakness may result in the corruption of memory, and perhaps instructions, possibly leading to a crash. If the corrupted memory can be effectively controlled, it may be possible to execute arbitrary code.::",,"::PHASE:Implementation:DESCRIPTION:Only call matching memory management functions. Do not mix and match routines. For example, when you allocate a buffer with malloc(), dispose of the original pointer with free().::PHASE:Implementation:DESCRIPTION:When programming in C++, consider using smart pointers provided by the boost library to help correctly and consistently manage memory.::PHASE:Architecture and Design:STRATEGY:Libraries or Frameworks:DESCRIPTION:Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. For example, glibc in Linux provides protection against free of invalid pointers.::PHASE:Architecture and Design:DESCRIPTION:Use a language that provides abstractions for memory allocation and deallocation.::PHASE:Testing:DESCRIPTION:Use a tool that dynamically detects memory management problems, such as valgrind.::",,,::Memory::,::TAXONOMY NAME:Software Fault Patterns:ENTRY ID:SFP12:ENTRY NAME:Faulty Memory Release::,,"::TYPE:Maintenance:NOTE:The view-1000 subtree that is associated with this weakness needs additional work. Several entries will likely be created in this branch. Currently the focus is on free() of memory, but delete and other related release routines may require the creation of intermediate entries that are not specific to a particular function. In addition, the role of other types of invalid pointers, such as an expired pointer, i.e. CWE-415 Double Free and release of uninitialized pointers, related to CWE-457.::"
764,Multiple Locks of a Critical Resource,Base,Incomplete,"The product locks a critical resource more times than intended, leading to an unexpected state in the system.","When a product is operating in a concurrent environment and repeatedly locks a critical resource, the consequences will vary based on the type of lock, the lock's implementation, and the resource being protected. In some situations such as with semaphores, the resources are pooled and extra locking calls will reduce the size of the total available pool, possibly leading to degraded performance or a denial of service. If this can be triggered by an attacker, it will be similar to an unrestricted lock (CWE-412). In the context of a binary lock, it is likely that any duplicate locking attempts will never succeed since the lock is already held and progress may not be possible.",::NATURE:ChildOf:CWE ID:667:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:675:VIEW ID:1000::NATURE:ChildOf:CWE ID:662:VIEW ID:1305:ORDINAL:Primary::NATURE:ChildOf:CWE ID:662:VIEW ID:1340:ORDINAL:Primary::,,,,,::PHASE:Architecture and Design::PHASE:Implementation::,,,"::SCOPE:Availability:SCOPE:Integrity:IMPACT:DoS: Resource Consumption (CPU):IMPACT:DoS: Crash, Exit, or Restart:IMPACT:Unexpected State::",,"::PHASE:Implementation:DESCRIPTION:When locking and unlocking a resource, try to be sure that all control paths through the code in which the resource is locked one or more times correspond to exactly as many unlocks. If the software acquires a lock and then determines it is not able to perform its intended behavior, be sure to release the lock(s) before waiting for conditions to improve. Reacquire the lock(s) before trying again.::",,,,::TAXONOMY NAME:Software Fault Patterns:ENTRY ID:SFP21:ENTRY NAME:Multiple locks/unlocks::,,"::TYPE:Maintenance:NOTE:An alternate way to think about this weakness is as an imbalance between the number of locks / unlocks in the control flow. Over the course of execution, if each lock call is not followed by a subsequent call to unlock in a reasonable amount of time, then system performance may be degraded or at least operating at less than peak levels if there is competition for the locks. This entry may need to be modified to reflect these concepts in the future.::"
765,Multiple Unlocks of a Critical Resource,Base,Incomplete,"The product unlocks a critical resource more times than intended, leading to an unexpected state in the system.","When the product is operating in a concurrent environment and repeatedly unlocks a critical resource, the consequences will vary based on the type of lock, the lock's implementation, and the resource being protected. In some situations such as with semaphores, the resources are pooled and extra calls to unlock will increase the count for the number of available resources, likely resulting in a crash or unpredictable behavior when the system nears capacity.",::NATURE:ChildOf:CWE ID:667:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:675:VIEW ID:1000::,,,,,::PHASE:Implementation::,,,"::SCOPE:Availability:SCOPE:Integrity:IMPACT:DoS: Crash, Exit, or Restart:IMPACT:Modify Memory:IMPACT:Unexpected State::",,"::PHASE:Implementation:DESCRIPTION:When locking and unlocking a resource, try to be sure that all control paths through the code in which the resource is locked one or more times correspond to exactly as many unlocks. If the product acquires a lock and then determines it is not able to perform its intended behavior, be sure to release the lock(s) before waiting for conditions to improve. Reacquire the lock(s) before trying again.::","::REFERENCE:CVE-2009-0935:DESCRIPTION:Attacker provides invalid address to a memory-reading function, causing a mutex to be unlocked twice:LINK:https://www.cve.org/CVERecord?id=CVE-2009-0935::",,,::TAXONOMY NAME:Software Fault Patterns:ENTRY ID:SFP21:ENTRY NAME:Multiple locks/unlocks::,,"::TYPE:Maintenance:NOTE:An alternate way to think about this weakness is as an imbalance between the number of locks / unlocks in the control flow. Over the course of execution, if each lock call is not followed by a subsequent call to unlock in a reasonable amount of time, then system performance may be degraded or at least operating at less than peak levels if there is competition for the locks. This entry may need to be modified to reflect these concepts in the future.::"
770,Allocation of Resources Without Limits or Throttling,Base,Incomplete,"The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.","Code frequently has to work with limited resources, so programmers must be careful to ensure that resources are not consumed too quickly, or too easily. Without use of quotas, resource limits, or other protection mechanisms, it can be easy for an attacker to consume many resources by rapidly making many requests, or causing larger resources to be used than is needed. When too many resources are allocated, or if a single resource is too large, then it can prevent the code from working correctly, possibly leading to a denial of service.",::NATURE:ChildOf:CWE ID:400:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:665:VIEW ID:1000::NATURE:ChildOf:CWE ID:400:VIEW ID:1003:ORDINAL:Primary::,,::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Often::,,,::PHASE:Architecture and Design:NOTE:OMISSION: This weakness is caused by missing a security tactic during the architecture and design phase.::PHASE:Implementation::PHASE:Operation::PHASE:System Configuration::,,,"::SCOPE:Availability:IMPACT:DoS: Resource Consumption (CPU):IMPACT:DoS: Resource Consumption (Memory):IMPACT:DoS: Resource Consumption (Other):NOTE:When allocating resources without limits, an attacker could prevent other systems, applications, or processes from accessing the same type of resource.::","::METHOD:Manual Static Analysis:DESCRIPTION:Manual static analysis can be useful for finding this weakness, but it might not achieve desired code coverage within limited time constraints. If denial-of-service is not considered a significant risk, or if there is strong emphasis on consequences such as code execution, then manual analysis may not focus on this weakness at all.::METHOD:Fuzzing:DESCRIPTION:While fuzzing is typically geared toward finding low-level implementation bugs, it can inadvertently find uncontrolled resource allocation problems. This can occur when the fuzzer generates a large number of test cases but does not restart the targeted product in between test cases. If an individual test case produces a crash, but it does not do so reliably, then an inability to limit resource allocation may be the cause. When the allocation is directly affected by numeric inputs, then fuzzing may produce indications of this weakness.:EFFECTIVENESS:Opportunistic::METHOD:Automated Dynamic Analysis:DESCRIPTION:Certain automated dynamic analysis techniques may be effective in producing side effects of uncontrolled resource allocation problems, especially with resources such as processes, memory, and connections. The technique may involve generating a large number of requests to the product within a short time frame. Manual analysis is likely required to interpret the results.::METHOD:Automated Static Analysis:DESCRIPTION:Specialized configuration or tuning may be required to train automated tools to recognize this weakness. Automated static analysis typically has limited utility in recognizing unlimited allocation problems, except for the missing release of program-independent system resources such as files, sockets, and processes, or unchecked arguments to memory. For system resources, automated static analysis may be able to detect circumstances in which resources are not released after they have expired, or if too much of a resource is requested at once, as can occur with memory. Automated analysis of configuration files may be able to detect settings that do not specify a maximum value. Automated static analysis tools will not be appropriate for detecting exhaustion of custom resources, such as an intended security policy in which a bulletin board user is only allowed to make a limited number of posts per day.::","::PHASE:Requirements:DESCRIPTION:Clearly specify the minimum and maximum expectations for capabilities, and dictate which behaviors are acceptable when resource allocation reaches limits.::PHASE:Architecture and Design:DESCRIPTION:Limit the amount of resources that are accessible to unprivileged users. Set per-user limits for resources. Allow the system administrator to define these limits. Be careful to avoid CWE-410.::PHASE:Architecture and Design:DESCRIPTION:Design throttling mechanisms into the system architecture. The best protection is to limit the amount of resources that an unauthorized user can cause to be expended. A strong authentication and access control model will help prevent such attacks from occurring in the first place, and it will help the administrator to identify who is committing the abuse. The login application should be protected against DoS attacks as much as possible. Limiting the database access, perhaps by caching result sets, can help minimize the resources expended. To further limit the potential for a DoS attack, consider tracking the rate of requests received from users and blocking requests that exceed a defined rate threshold.::PHASE:Implementation:STRATEGY:Input Validation:DESCRIPTION:Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.::PHASE:Architecture and Design:DESCRIPTION:For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.::PHASE:Architecture and Design:DESCRIPTION:Mitigation of resource exhaustion attacks requires that the target system either: recognizes the attack and denies that user further access for a given amount of time, typically by using increasing time delays uniformly throttles all requests in order to make it more difficult to consume resources more quickly than they can again be freed. The first of these solutions is an issue in itself though, since it may allow attackers to prevent the use of the system by a particular valid user. If the attacker impersonates the valid user, they may be able to prevent the user from accessing the server in question. The second solution can be difficult to effectively institute -- and even when properly done, it does not provide a full solution. It simply requires more resources on the part of the attacker.::PHASE:Architecture and Design:DESCRIPTION:Ensure that protocols have specific limits of scale placed on them.::PHASE:Architecture and Design Implementation:DESCRIPTION:If the program must fail, ensure that it fails gracefully (fails closed). There may be a temptation to simply let the program fail poorly in cases such as low memory conditions, but an attacker may be able to assert control before the software has fully exited. Alternately, an uncontrolled failure could cause cascading problems with other downstream components; for example, the program could send a signal to a downstream process so the process immediately knows that a problem has occurred and has a better chance of recovery. Ensure that all failures in resource allocation place the system into a safe posture.::PHASE:Operation Architecture and Design:STRATEGY:Resource Limitation:DESCRIPTION:Use resource-limiting settings provided by the operating system or environment. For example, when managing system resources in POSIX, setrlimit() can be used to set limits for certain types of resources, and getrlimit() can determine how many resources are available. However, these functions are not available on all operating systems. When the current levels get close to the maximum that is defined for the application (see CWE-770), then limit the allocation of further resources to privileged users; alternately, begin releasing resources for less-privileged users. While this mitigation may protect the system from attack, it will not necessarily stop attackers from adversely impacting other users. Ensure that the application performs the appropriate error checks and error handling in case resources become unavailable (CWE-703).::","::REFERENCE:CVE-2022-21668:DESCRIPTION:Chain: Python library does not limit the resources used to process images that specify a very large number of bands (CWE-1284), leading to excessive memory consumption (CWE-789) or an integer overflow (CWE-190).:LINK:https://www.cve.org/CVERecord?id=CVE-2022-21668::REFERENCE:CVE-2009-4017:DESCRIPTION:Language interpreter does not restrict the number of temporary files being created when handling a MIME request with a large number of parts..:LINK:https://www.cve.org/CVERecord?id=CVE-2009-4017::REFERENCE:CVE-2009-2726:DESCRIPTION:Driver does not use a maximum width when invoking sscanf style functions, causing stack consumption.:LINK:https://www.cve.org/CVERecord?id=CVE-2009-2726::REFERENCE:CVE-2009-2540:DESCRIPTION:Large integer value for a length property in an object causes a large amount of memory allocation.:LINK:https://www.cve.org/CVERecord?id=CVE-2009-2540::REFERENCE:CVE-2009-2054:DESCRIPTION:Product allows exhaustion of file descriptors when processing a large number of TCP packets.:LINK:https://www.cve.org/CVERecord?id=CVE-2009-2054::REFERENCE:CVE-2008-5180:DESCRIPTION:Communication product allows memory consumption with a large number of SIP requests, which cause many sessions to be created.:LINK:https://www.cve.org/CVERecord?id=CVE-2008-5180::REFERENCE:CVE-2008-1700:DESCRIPTION:Product allows attackers to cause a denial of service via a large number of directives, each of which opens a separate window.:LINK:https://www.cve.org/CVERecord?id=CVE-2008-1700::REFERENCE:CVE-2005-4650:DESCRIPTION:CMS does not restrict the number of searches that can occur simultaneously, leading to resource exhaustion.:LINK:https://www.cve.org/CVERecord?id=CVE-2005-4650::REFERENCE:CVE-2020-15100:DESCRIPTION:web application scanner attempts to read an excessively large file created by a user, causing process termination:LINK:https://www.cve.org/CVERecord?id=CVE-2020-15100::REFERENCE:CVE-2020-7218:DESCRIPTION:Go-based workload orchestrator does not limit resource usage with unauthenticated connections, allowing a DoS by flooding the service:LINK:https://www.cve.org/CVERecord?id=CVE-2020-7218::",,,::TAXONOMY NAME:The CERT Oracle Secure Coding Standard for Java (2011):ENTRY ID:FIO04-J:ENTRY NAME:Close resources when they are no longer needed::TAXONOMY NAME:The CERT Oracle Secure Coding Standard for Java (2011):ENTRY ID:SER12-J:ENTRY NAME:Avoid memory and resource leaks during serialization::TAXONOMY NAME:The CERT Oracle Secure Coding Standard for Java (2011):ENTRY ID:MSC05-J:ENTRY NAME:Do not exhaust heap space::,::125::130::147::197::229::230::231::469::482::486::487::488::489::490::491::493::494::495::496::528::,"::TYPE:Relationship:NOTE:This entry is different from uncontrolled resource consumption (CWE-400) in that there are other weaknesses that are related to inability to control resource consumption, such as holding on to a resource too long after use, or not correctly keeping track of active resources so that they can be managed and released when they are finished (CWE-771).::TYPE:Theoretical:NOTE:Vulnerability theory is largely about how behaviors and resources interact. Resource exhaustion can be regarded as either a consequence or an attack, depending on the perspective. This entry is an attempt to reflect one of the underlying weaknesses that enable these attacks (or consequences) to take place.::"
771,Missing Reference to Active Allocated Resource,Base,Incomplete,"The product does not properly maintain a reference to a resource that has been allocated, which prevents the resource from being reclaimed.","This does not necessarily apply in languages or frameworks that automatically perform garbage collection, since the removal of all references may act as a signal that the resource is ready to be reclaimed.",::NATURE:ChildOf:CWE ID:400:VIEW ID:1000:ORDINAL:Primary::,,,,,::PHASE:Architecture and Design::PHASE:Implementation::,,,::SCOPE:Availability:IMPACT:DoS: Resource Consumption (Other):NOTE:An attacker that can influence the allocation of resources that are not properly maintained could deplete the available resource pool and prevent all other processes from accessing the same type of resource.::,,"::PHASE:Operation Architecture and Design:STRATEGY:Resource Limitation:DESCRIPTION:Use resource-limiting settings provided by the operating system or environment. For example, when managing system resources in POSIX, setrlimit() can be used to set limits for certain types of resources, and getrlimit() can determine how many resources are available. However, these functions are not available on all operating systems. When the current levels get close to the maximum that is defined for the application (see CWE-770), then limit the allocation of further resources to privileged users; alternately, begin releasing resources for less-privileged users. While this mitigation may protect the system from attack, it will not necessarily stop attackers from adversely impacting other users. Ensure that the application performs the appropriate error checks and error handling in case resources become unavailable (CWE-703).::",,,,::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:FIO42-C:ENTRY NAME:Close files when they are no longer needed:MAPPING FIT:CWE More Abstract::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:MEM31-C:ENTRY NAME:Free dynamically allocated memory when no longer needed:MAPPING FIT:CWE More Abstract::TAXONOMY NAME:Software Fault Patterns:ENTRY ID:SFP14:ENTRY NAME:Failure to Release Resource::,,
772,Missing Release of Resource after Effective Lifetime,Base,Draft,"The product does not release a resource after its effective lifetime has ended, i.e., after the resource is no longer needed.","When a resource is not released after use, it can allow attackers to cause a denial of service by causing the allocation of resources without triggering their release. Frequently-affected resources include memory, CPU, disk space, power or battery, etc.",::NATURE:ChildOf:CWE ID:404:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:404:VIEW ID:1003:ORDINAL:Primary::NATURE:ChildOf:CWE ID:404:VIEW ID:1305:ORDINAL:Primary::NATURE:ChildOf:CWE ID:404:VIEW ID:1340:ORDINAL:Primary::,,::TECHNOLOGY CLASS:Mobile:TECHNOLOGY PREVALENCE:Undetermined::,,,::PHASE:Architecture and Design::PHASE:Implementation::,,,::SCOPE:Availability:IMPACT:DoS: Resource Consumption (Other):NOTE:An attacker that can influence the allocation of resources that are not properly released could deplete the available resource pool and prevent all other processes from accessing the same type of resource.::,,"::PHASE:Requirements:STRATEGY:Language Selection:DESCRIPTION:Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. For example, languages such as Java, Ruby, and Lisp perform automatic garbage collection that releases memory for objects that have been deallocated.::PHASE:Implementation:DESCRIPTION:It is good practice to be responsible for freeing all resources you allocate and to be consistent with how and where you free resources in a function. If you allocate resources that you intend to free upon completion of the function, you must be sure to free the resources at all exit points for that function including error conditions.::PHASE:Operation Architecture and Design:STRATEGY:Resource Limitation:DESCRIPTION:Use resource-limiting settings provided by the operating system or environment. For example, when managing system resources in POSIX, setrlimit() can be used to set limits for certain types of resources, and getrlimit() can determine how many resources are available. However, these functions are not available on all operating systems. When the current levels get close to the maximum that is defined for the application (see CWE-770), then limit the allocation of further resources to privileged users; alternately, begin releasing resources for less-privileged users. While this mitigation may protect the system from attack, it will not necessarily stop attackers from adversely impacting other users. Ensure that the application performs the appropriate error checks and error handling in case resources become unavailable (CWE-703).::","::REFERENCE:CVE-2007-0897:DESCRIPTION:Chain: anti-virus product encounters a malformed file but returns from a function without closing a file descriptor (CWE-775) leading to file descriptor consumption (CWE-400) and failed scans.:LINK:https://www.cve.org/CVERecord?id=CVE-2007-0897::REFERENCE:CVE-2001-0830:DESCRIPTION:Sockets not properly closed when attacker repeatedly connects and disconnects from server.:LINK:https://www.cve.org/CVERecord?id=CVE-2001-0830::REFERENCE:CVE-1999-1127:DESCRIPTION:Does not shut down named pipe connections if malformed data is sent.:LINK:https://www.cve.org/CVERecord?id=CVE-1999-1127::REFERENCE:CVE-2009-2858:DESCRIPTION:Chain: memory leak (CWE-404) leads to resource exhaustion.:LINK:https://www.cve.org/CVERecord?id=CVE-2009-2858::REFERENCE:CVE-2009-2054:DESCRIPTION:Product allows exhaustion of file descriptors when processing a large number of TCP packets.:LINK:https://www.cve.org/CVERecord?id=CVE-2009-2054::REFERENCE:CVE-2008-2122:DESCRIPTION:Port scan triggers CPU consumption with processes that attempt to read data from closed sockets.:LINK:https://www.cve.org/CVERecord?id=CVE-2008-2122::REFERENCE:CVE-2007-4103:DESCRIPTION:Product allows resource exhaustion via a large number of calls that do not complete a 3-way handshake.:LINK:https://www.cve.org/CVERecord?id=CVE-2007-4103::REFERENCE:CVE-2002-1372:DESCRIPTION:Return values of file/socket operations not checked, allowing resultant consumption of file descriptors.:LINK:https://www.cve.org/CVERecord?id=CVE-2002-1372::",,,::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:FIO42-C:ENTRY NAME:Close files when they are no longer needed:MAPPING FIT:CWE More Abstract::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:MEM31-C:ENTRY NAME:Free dynamically allocated memory when no longer needed:MAPPING FIT:CWE More Abstract::TAXONOMY NAME:OMG ASCSM:ENTRY ID:ASCSM-CWE-772::TAXONOMY NAME:OMG ASCRM:ENTRY ID:ASCRM-CWE-772::TAXONOMY NAME:Software Fault Patterns:ENTRY ID:SFP14:ENTRY NAME:Failure to Release Resource::,::469::,"::TYPE:Maintenance:NOTE:Resource exhaustion (CWE-400) is currently treated as a weakness, although it is more like a category of weaknesses that all have the same type of consequence. While this entry treats CWE-400 as a parent in view 1000, the relationship is probably more appropriately described as a chain.::TYPE:Theoretical:NOTE:Vulnerability theory is largely about how behaviors and resources interact. Resource exhaustion can be regarded as either a consequence or an attack, depending on the perspective. This entry is an attempt to reflect one of the underlying weaknesses that enable these attacks (or consequences) to take place.::"
776,Improper Restriction of Recursive Entity References in DTDs ('XML Entity Expansion'),Base,Draft,"The product uses XML documents and allows their structure to be defined with a Document Type Definition (DTD), but it does not properly control the number of recursive definitions of entities.","If the DTD contains a large number of nested or recursive entities, this can lead to explosive growth of data when parsed, causing a denial of service.",::NATURE:ChildOf:CWE ID:674:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:674:VIEW ID:1003:ORDINAL:Primary::NATURE:ChildOf:CWE ID:409:VIEW ID:1000::,,::LANGUAGE NAME:XML:LANGUAGE PREVALENCE:Undetermined::,,"::TERM:XEE:DESCRIPTION:XEE is the acronym commonly used for XML Entity Expansion.::TERM:Billion Laughs Attack::TERM:XML Bomb:DESCRIPTION:While the XML Bomb term was used in the early years of knowledge of this issue, the XEE term seems to be more commonly used.::",::PHASE:Implementation::PHASE:Operation::,,,"::SCOPE:Availability:IMPACT:DoS: Resource Consumption (Other):NOTE:If parsed, recursive entity references allow the attacker to expand data exponentially, quickly consuming all system resources.::",,"::PHASE:Operation:DESCRIPTION:If possible, prohibit the use of DTDs or use an XML parser that limits the expansion of recursive DTD entities.::PHASE:Implementation:DESCRIPTION:Before parsing XML files with associated DTDs, scan for recursive entity declarations and do not continue parsing potentially explosive content.::",::REFERENCE:CVE-2008-3281:DESCRIPTION:XEE in XML-parsing library.:LINK:https://www.cve.org/CVERecord?id=CVE-2008-3281::REFERENCE:CVE-2011-3288:DESCRIPTION:XML bomb / XEE in enterprise communication product.:LINK:https://www.cve.org/CVERecord?id=CVE-2011-3288::REFERENCE:CVE-2011-1755:DESCRIPTION:Billion laughs attack in XMPP server daemon.:LINK:https://www.cve.org/CVERecord?id=CVE-2011-1755::REFERENCE:CVE-2009-1955:DESCRIPTION:XML bomb in web server module:LINK:https://www.cve.org/CVERecord?id=CVE-2009-1955::REFERENCE:CVE-2003-1564:DESCRIPTION:Parsing library allows XML bomb:LINK:https://www.cve.org/CVERecord?id=CVE-2003-1564::,,,::TAXONOMY NAME:WASC:ENTRY ID:44:ENTRY NAME:XML Entity Expansion::,::197::,
778,Insufficient Logging,Base,Draft,"When a security-critical event occurs, the product either does not record the event or omits important details about the event when logging it.","When security-critical events are not logged properly, such as a failed login attempt, this can make malicious behavior more difficult to detect and may hinder forensic analysis after an attack succeeds. As organizations adopt cloud storage resources, these technologies often require configuration changes to enable detailed logging information, since detailed logging can incur additional costs. This could lead to telemetry gaps in critical audit logs. For example, in Azure, the default value for logging is disabled.",::NATURE:ChildOf:CWE ID:223:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:693:VIEW ID:1000::,,::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::TECHNOLOGY CLASS:Cloud Computing:TECHNOLOGY PREVALENCE:Undetermined::,,,::PHASE:Operation:NOTE:COMMISSION: This weakness refers to an incorrect design related to an architectural security tactic.::,,,"::SCOPE:Non-Repudiation:IMPACT:Hide Activities:NOTE:If security critical information is not recorded, there will be no trail for forensic analysis and discovering the cause of problems or the source of attacks may become more difficult or impossible.::",,"::PHASE:Architecture and Design:DESCRIPTION:Use a centralized logging mechanism that supports multiple levels of detail.::PHASE:Implementation:DESCRIPTION:Ensure that all security-related successes and failures can be logged. When storing data in the cloud (e.g., AWS S3 buckets, Azure blobs, Google Cloud Storage, etc.), use the provider's controls to enable and capture detailed logging information.::PHASE:Operation:DESCRIPTION:Be sure to set the level of logging appropriately in a production environment. Sufficient data should be logged to enable system administrators to detect attacks, diagnose errors, and recover from attacks. At the same time, logging too much data (CWE-779) can cause the same problems, including unexpected costs when using a cloud environment.::PHASE:Operation:DESCRIPTION:To enable storage logging using Azure's Portal, navigate to the name of the Storage Account, locate Monitoring (CLASSIC) section, and select Diagnostic settings (classic). For each of the various properties (blob, file, table, queue), ensure the status is properly set for the desired logging data. If using PowerShell, the Set-AzStorageServiceLoggingProperty command could be called using appropriate -ServiceType, -LoggingOperations, and -RetentionDays arguments.::","::REFERENCE:CVE-2008-4315:DESCRIPTION:server does not log failed authentication attempts, making it easier for attackers to perform brute force password guessing without being detected:LINK:https://www.cve.org/CVERecord?id=CVE-2008-4315::REFERENCE:CVE-2008-1203:DESCRIPTION:admin interface does not log failed authentication attempts, making it easier for attackers to perform brute force password guessing without being detected:LINK:https://www.cve.org/CVERecord?id=CVE-2008-1203::REFERENCE:CVE-2007-3730:DESCRIPTION:default configuration for POP server does not log source IP or username for login attempts:LINK:https://www.cve.org/CVERecord?id=CVE-2007-3730::REFERENCE:CVE-2007-1225:DESCRIPTION:proxy does not log requests without http:// in the URL, allowing web surfers to access restricted web content without detection:LINK:https://www.cve.org/CVERecord?id=CVE-2007-1225::REFERENCE:CVE-2003-1566:DESCRIPTION:web server does not log requests for a non-standard request type:LINK:https://www.cve.org/CVERecord?id=CVE-2003-1566::",,,,,
779,Logging of Excessive Data,Base,Draft,"The product logs too much information, making log files hard to process and possibly hindering recovery efforts or forensic analysis after an attack.","While logging is a good practice in general, and very high levels of logging are appropriate for debugging stages of development, too much logging in a production environment might hinder a system administrator's ability to detect anomalous conditions. This can provide cover for an attacker while attempting to penetrate a system, clutter the audit trail for forensic analysis, or make it more difficult to debug problems in a production environment.",::NATURE:ChildOf:CWE ID:400:VIEW ID:1000:ORDINAL:Primary::,,::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::,,,::PHASE:Operation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::,,,"::SCOPE:Availability:IMPACT:DoS: Resource Consumption (CPU):IMPACT:DoS: Resource Consumption (Other):NOTE:Log files can become so large that they consume excessive resources, such as disk and CPU, which can hinder the performance of the system.::SCOPE:Non-Repudiation:IMPACT:Hide Activities:NOTE:Logging too much information can make the log files of less use to forensics analysts and developers when trying to diagnose a problem or recover from an attack.::SCOPE:Non-Repudiation:IMPACT:Hide Activities:NOTE:If system administrators are unable to effectively process log files, attempted attacks may go undetected, possibly leading to eventual system compromise.::",,"::PHASE:Architecture and Design:DESCRIPTION:Suppress large numbers of duplicate log messages and replace them with periodic summaries. For example, syslog may include an entry that states last message repeated X times when recording repeated events.::PHASE:Architecture and Design:DESCRIPTION:Support a maximum size for the log file that can be controlled by the administrator. If the maximum size is reached, the admin should be notified. Also, consider reducing functionality of the product. This may result in a denial-of-service to legitimate product users, but it will prevent the product from adversely impacting the entire system.::PHASE:Implementation:DESCRIPTION:Adjust configurations appropriately when the product is transitioned from a debug state to production.::","::REFERENCE:CVE-2007-0421:DESCRIPTION:server records a large amount of data to the server log when it receives malformed headers:LINK:https://www.cve.org/CVERecord?id=CVE-2007-0421::REFERENCE:CVE-2002-1154:DESCRIPTION:chain: application does not restrict access to front-end for updates, which allows attacker to fill the error log:LINK:https://www.cve.org/CVERecord?id=CVE-2002-1154::",,,,,
783,Operator Precedence Logic Error,Base,Draft,The product uses an expression in which operator precedence causes incorrect logic to be used.,"While often just a bug, operator precedence logic errors can have serious consequences if they are used in security-critical code, such as making an authentication decision.",::NATURE:ChildOf:CWE ID:670:VIEW ID:1000:ORDINAL:Primary::,,::LANGUAGE NAME:C:LANGUAGE PREVALENCE:Rarely::LANGUAGE NAME:C++:LANGUAGE PREVALENCE:Rarely::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Rarely::,,,"::PHASE:Implementation:NOTE:Logic errors related to operator precedence may cause problems even during normal operation, so they are probably discovered quickly during the testing phase. If testing is incomplete or there is a strong reliance on manual review of the code, then these errors may not be discovered before the software is deployed.::",,,"::SCOPE:Confidentiality:SCOPE:Integrity:SCOPE:Availability:IMPACT:Varies by Context:IMPACT:Unexpected State:NOTE:The consequences will vary based on the context surrounding the incorrect precedence. In a security decision, integrity or confidentiality are the most likely results. Otherwise, a crash may occur due to the software reaching an unexpected state.::",,"::PHASE:Implementation:DESCRIPTION:Regularly wrap sub-expressions in parentheses, especially in security-critical code.::","::REFERENCE:CVE-2008-2516:DESCRIPTION:Authentication module allows authentication bypass because it uses (x = call(args) == SUCCESS) instead of ((x = call(args)) == SUCCESS).:LINK:https://www.cve.org/CVERecord?id=CVE-2008-2516::REFERENCE:CVE-2008-0599:DESCRIPTION:Chain: Language interpreter calculates wrong buffer size (CWE-131) by using size = ptr ? X : Y instead of size = (ptr ? X : Y) expression.:LINK:https://www.cve.org/CVERecord?id=CVE-2008-0599::REFERENCE:CVE-2001-1155:DESCRIPTION:Chain: product does not properly check the result of a reverse DNS lookup because of operator precedence (CWE-783), allowing bypass of DNS-based access restrictions.:LINK:https://www.cve.org/CVERecord?id=CVE-2001-1155::",,,::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:EXP00-C:ENTRY NAME:Use parentheses for precedence of operation:MAPPING FIT:Exact::TAXONOMY NAME:SEI CERT Perl Coding Standard:ENTRY ID:EXP04-PL:ENTRY NAME:Do not mix the early-precedence logical operators with late-precedence logical operators:MAPPING FIT:CWE More Abstract::,,
786,Access of Memory Location Before Start of Buffer,Base,Incomplete,The product reads or writes to a buffer using an index or pointer that references a memory location prior to the beginning of the buffer.,"This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",::NATURE:ChildOf:CWE ID:119:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:119:VIEW ID:1305:ORDINAL:Primary::NATURE:ChildOf:CWE ID:119:VIEW ID:1340:ORDINAL:Primary::,,,,,,,,"::SCOPE:Confidentiality:IMPACT:Read Memory:NOTE:For an out-of-bounds read, the attacker may have access to sensitive information. If the sensitive information contains system details, such as the current buffers position in memory, this knowledge can be used to craft further attacks, possibly with more severe consequences.::SCOPE:Integrity:SCOPE:Availability:IMPACT:Modify Memory:IMPACT:DoS: Crash, Exit, or Restart:NOTE:Out of bounds memory access will very likely result in the corruption of relevant memory, and perhaps instructions, possibly leading to a crash.::SCOPE:Integrity:IMPACT:Modify Memory:IMPACT:Execute Unauthorized Code or Commands:NOTE:If the corrupted memory can be effectively controlled, it may be possible to execute arbitrary code. If the corrupted memory is data rather than instructions, the system will continue to function with improper changes, possibly in violation of an implicit or explicit policy.::",,,"::REFERENCE:CVE-2002-2227:DESCRIPTION:Unchecked length of SSLv2 challenge value leads to buffer underflow.:LINK:https://www.cve.org/CVERecord?id=CVE-2002-2227::REFERENCE:CVE-2007-4580:DESCRIPTION:Buffer underflow from a small size value with a large buffer (length parameter inconsistency, CWE-130):LINK:https://www.cve.org/CVERecord?id=CVE-2007-4580::REFERENCE:CVE-2007-1584:DESCRIPTION:Buffer underflow from an all-whitespace string, which causes a counter to be decremented before the buffer while looking for a non-whitespace character.:LINK:https://www.cve.org/CVERecord?id=CVE-2007-1584::REFERENCE:CVE-2007-0886:DESCRIPTION:Buffer underflow resultant from encoded data that triggers an integer overflow.:LINK:https://www.cve.org/CVERecord?id=CVE-2007-0886::REFERENCE:CVE-2006-6171:DESCRIPTION:Product sets an incorrect buffer size limit, leading to off-by-two buffer underflow.:LINK:https://www.cve.org/CVERecord?id=CVE-2006-6171::REFERENCE:CVE-2006-4024:DESCRIPTION:Negative value is used in a memcpy() operation, leading to buffer underflow.:LINK:https://www.cve.org/CVERecord?id=CVE-2006-4024::REFERENCE:CVE-2004-2620:DESCRIPTION:Buffer underflow due to mishandled special characters:LINK:https://www.cve.org/CVERecord?id=CVE-2004-2620::",,,::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:ARR30-C:ENTRY NAME:Do not form or use out-of-bounds pointers or array subscripts:MAPPING FIT:CWE More Specific::,,
787,Out-of-bounds Write,Base,Draft,"The product writes data past the end, or before the beginning, of the intended buffer.","Typically, this can result in corruption of data, a crash, or code execution. The product may modify an index or perform pointer arithmetic that references a memory location that is outside of the boundaries of the buffer. A subsequent write operation then produces undefined or unexpected results.",::NATURE:ChildOf:CWE ID:119:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:119:VIEW ID:1003:ORDINAL:Primary::NATURE:ChildOf:CWE ID:119:VIEW ID:1305:ORDINAL:Primary::NATURE:ChildOf:CWE ID:119:VIEW ID:1340:ORDINAL:Primary::,,::LANGUAGE NAME:C:LANGUAGE PREVALENCE:Often::LANGUAGE NAME:C++:LANGUAGE PREVALENCE:Often::LANGUAGE CLASS:Assembly:LANGUAGE PREVALENCE:Undetermined::TECHNOLOGY CLASS:ICS/OT:TECHNOLOGY PREVALENCE:Often::,,"::TERM:Memory Corruption:DESCRIPTION:Often used to describe the consequences of writing to memory outside the bounds of a buffer, or to memory that is invalid, when the root cause is something other than a sequential copy of excessive data from a fixed starting location. This may include issues such as incorrect pointer arithmetic, accessing invalid pointers due to incomplete initialization or memory release, etc.::",::PHASE:Implementation::,,,"::SCOPE:Integrity:SCOPE:Availability:IMPACT:Modify Memory:IMPACT:DoS: Crash, Exit, or Restart:IMPACT:Execute Unauthorized Code or Commands::","::METHOD:Automated Static Analysis:DESCRIPTION:This weakness can often be detected using automated static analysis tools. Many modern tools use data flow analysis or constraint-based techniques to minimize the number of false positives. Automated static analysis generally does not account for environmental considerations when reporting out-of-bounds memory operations. This can make it difficult for users to determine which warnings should be investigated first. For example, an analysis tool might report buffer overflows that originate from command line arguments in a program that is not expected to run with setuid or other special privileges.:EFFECTIVENESS:High::METHOD:Automated Dynamic Analysis:DESCRIPTION:This weakness can be detected using dynamic tools and techniques that interact with the software using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The software's operation may slow down, but it should not become unstable, crash, or generate incorrect results.::","::PHASE:Requirements:STRATEGY:Language Selection:DESCRIPTION:Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. For example, many languages that perform their own memory management, such as Java and Perl, are not subject to buffer overflows. Other languages, such as Ada and C#, typically provide overflow protection, but the protection can be disabled by the programmer. Be wary that a language's interface to native code may still be subject to overflows, even if the language itself is theoretically safe.::PHASE:Architecture and Design:STRATEGY:Libraries or Frameworks:DESCRIPTION:Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. Examples include the Safe C String Library (SafeStr) by Messier and Viega [REF-57], and the Strsafe.h library from Microsoft [REF-56]. These libraries provide safer versions of overflow-prone string-handling functions.::PHASE:Build and Compilation:STRATEGY:Compilation or Build Hardening:DESCRIPTION:Run or compile the software using features or extensions that automatically provide a protection mechanism that mitigates or eliminates buffer overflows. For example, certain compilers and extensions provide automatic buffer overflow detection mechanisms that are built into the compiled code. Examples include the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice.:EFFECTIVENESS:Defense in Depth::PHASE:Implementation:DESCRIPTION:Consider adhering to the following rules when allocating and managing an application's memory: Double check that the buffer is as large as specified. When using functions that accept a number of bytes to copy, such as strncpy(), be aware that if the destination buffer size is equal to the source buffer size, it may not NULL-terminate the string. Check buffer boundaries if accessing the buffer in a loop and make sure there is no danger of writing past the allocated space. If necessary, truncate all input strings to a reasonable length before passing them to the copy and concatenation functions.::PHASE:Operation:STRATEGY:Environment Hardening:DESCRIPTION:Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code. Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64].:EFFECTIVENESS:Defense in Depth::PHASE:Operation:STRATEGY:Environment Hardening:DESCRIPTION:Use a CPU and operating system that offers Data Execution Protection (NX) or its equivalent [REF-60] [REF-61].:EFFECTIVENESS:Defense in Depth::PHASE:Implementation:DESCRIPTION:Replace unbounded copy functions with analogous functions that support length arguments, such as strcpy with strncpy. Create these if they are not available.:EFFECTIVENESS:Moderate::","::REFERENCE:CVE-2021-21220:DESCRIPTION:Chain: insufficient input validation (CWE-20) in browser allows heap corruption (CWE-787), as exploited in the wild per CISA KEV.:LINK:https://www.cve.org/CVERecord?id=CVE-2021-21220::REFERENCE:CVE-2021-28664:DESCRIPTION:GPU kernel driver allows memory corruption because a user can obtain read/write access to read-only pages, as exploited in the wild per CISA KEV.:LINK:https://www.cve.org/CVERecord?id=CVE-2021-28664::REFERENCE:CVE-2020-17087:DESCRIPTION:Chain: integer truncation (CWE-197) causes small buffer allocation (CWE-131) leading to out-of-bounds write (CWE-787) in kernel pool, as exploited in the wild per CISA KEV.:LINK:https://www.cve.org/CVERecord?id=CVE-2020-17087::REFERENCE:CVE-2020-1054:DESCRIPTION:Out-of-bounds write in kernel-mode driver, as exploited in the wild per CISA KEV.:LINK:https://www.cve.org/CVERecord?id=CVE-2020-1054::REFERENCE:CVE-2020-0041:DESCRIPTION:Escape from browser sandbox using out-of-bounds write due to incorrect bounds check, as exploited in the wild per CISA KEV.:LINK:https://www.cve.org/CVERecord?id=CVE-2020-0041::REFERENCE:CVE-2020-0968:DESCRIPTION:Memory corruption in web browser scripting engine, as exploited in the wild per CISA KEV.:LINK:https://www.cve.org/CVERecord?id=CVE-2020-0968::REFERENCE:CVE-2020-0022:DESCRIPTION:chain: mobile phone Bluetooth implementation does not include offset when calculating packet length (CWE-682), leading to out-of-bounds write (CWE-787):LINK:https://www.cve.org/CVERecord?id=CVE-2020-0022::REFERENCE:CVE-2019-1010006:DESCRIPTION:Chain: compiler optimization (CWE-733) removes or modifies code used to detect integer overflow (CWE-190), allowing out-of-bounds write (CWE-787).:LINK:https://www.cve.org/CVERecord?id=CVE-2019-1010006::REFERENCE:CVE-2009-1532:DESCRIPTION:malformed inputs cause accesses of uninitialized or previously-deleted objects, leading to memory corruption:LINK:https://www.cve.org/CVERecord?id=CVE-2009-1532::REFERENCE:CVE-2009-0269:DESCRIPTION:chain: -1 value from a function call was intended to indicate an error, but is used as an array index instead.:LINK:https://www.cve.org/CVERecord?id=CVE-2009-0269::REFERENCE:CVE-2002-2227:DESCRIPTION:Unchecked length of SSLv2 challenge value leads to buffer underflow.:LINK:https://www.cve.org/CVERecord?id=CVE-2002-2227::REFERENCE:CVE-2007-4580:DESCRIPTION:Buffer underflow from a small size value with a large buffer (length parameter inconsistency, CWE-130):LINK:https://www.cve.org/CVERecord?id=CVE-2007-4580::REFERENCE:CVE-2007-4268:DESCRIPTION:Chain: integer signedness error (CWE-195) passes signed comparison, leading to heap overflow (CWE-122):LINK:https://www.cve.org/CVERecord?id=CVE-2007-4268::REFERENCE:CVE-2009-2550:DESCRIPTION:Classic stack-based buffer overflow in media player using a long entry in a playlist:LINK:https://www.cve.org/CVERecord?id=CVE-2009-2550::REFERENCE:CVE-2009-2403:DESCRIPTION:Heap-based buffer overflow in media player using a long entry in a playlist:LINK:https://www.cve.org/CVERecord?id=CVE-2009-2403::",,,,,
788,Access of Memory Location After End of Buffer,Base,Incomplete,The product reads or writes to a buffer using an index or pointer that references a memory location after the end of the buffer.,This typically occurs when a pointer or its index is incremented to a position after the buffer; or when pointer arithmetic results in a position after the buffer.,::NATURE:ChildOf:CWE ID:119:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:119:VIEW ID:1305:ORDINAL:Primary::NATURE:ChildOf:CWE ID:119:VIEW ID:1340:ORDINAL:Primary::,,,,,,,,"::SCOPE:Confidentiality:IMPACT:Read Memory:NOTE:For an out-of-bounds read, the attacker may have access to sensitive information. If the sensitive information contains system details, such as the current buffers position in memory, this knowledge can be used to craft further attacks, possibly with more severe consequences.::SCOPE:Integrity:SCOPE:Availability:IMPACT:Modify Memory:IMPACT:DoS: Crash, Exit, or Restart:NOTE:Out of bounds memory access will very likely result in the corruption of relevant memory, and perhaps instructions, possibly leading to a crash. Other attacks leading to lack of availability are possible, including putting the program into an infinite loop.::SCOPE:Integrity:IMPACT:Modify Memory:IMPACT:Execute Unauthorized Code or Commands:NOTE:If the memory accessible by the attacker can be effectively controlled, it may be possible to execute arbitrary code, as with a standard buffer overflow. If the attacker can overwrite a pointer's worth of memory (usually 32 or 64 bits), they can redirect a function pointer to their own malicious code. Even when the attacker can only modify a single byte arbitrary code execution can be possible. Sometimes this is because the same problem can be exploited repeatedly to the same effect. Other times it is because the attacker can overwrite security-critical application-specific data -- such as a flag indicating whether the user is an administrator.::",,,"::REFERENCE:CVE-2009-2550:DESCRIPTION:Classic stack-based buffer overflow in media player using a long entry in a playlist:LINK:https://www.cve.org/CVERecord?id=CVE-2009-2550::REFERENCE:CVE-2009-2403:DESCRIPTION:Heap-based buffer overflow in media player using a long entry in a playlist:LINK:https://www.cve.org/CVERecord?id=CVE-2009-2403::REFERENCE:CVE-2009-0689:DESCRIPTION:large precision value in a format string triggers overflow:LINK:https://www.cve.org/CVERecord?id=CVE-2009-0689::REFERENCE:CVE-2009-0558:DESCRIPTION:attacker-controlled array index leads to code execution:LINK:https://www.cve.org/CVERecord?id=CVE-2009-0558::REFERENCE:CVE-2008-4113:DESCRIPTION:OS kernel trusts userland-supplied length value, allowing reading of sensitive information:LINK:https://www.cve.org/CVERecord?id=CVE-2008-4113::REFERENCE:CVE-2007-4268:DESCRIPTION:Chain: integer signedness error (CWE-195) passes signed comparison, leading to heap overflow (CWE-122):LINK:https://www.cve.org/CVERecord?id=CVE-2007-4268::",,,::TAXONOMY NAME:OMG ASCRM:ENTRY ID:ASCRM-CWE-788::,,
791,Incomplete Filtering of Special Elements,Base,Incomplete,"The product receives data from an upstream component, but does not completely filter special elements before sending it to a downstream component.",,::NATURE:ChildOf:CWE ID:790:VIEW ID:1000:ORDINAL:Primary::,,,,,::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::,,,::SCOPE:Integrity:IMPACT:Unexpected State::,,,,,,,,
795,Only Filtering Special Elements at a Specified Location,Base,Incomplete,"The product receives data from an upstream component, but only accounts for special elements at a specified location, thereby missing remaining special elements that may exist before sending it to a downstream component.","A filter might only account for instances of special elements when they occur: relative to a marker (e.g. at the beginning/end of string; the second argument), or at an absolute position (e.g. byte number 10). This may leave special elements in the data that did not match the filter position, but still may be dangerous.",::NATURE:ChildOf:CWE ID:791:VIEW ID:1000:ORDINAL:Primary::,,,,,::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::,,,::SCOPE:Integrity:IMPACT:Unexpected State::,,,,,,,,
798,Use of Hard-coded Credentials,Base,Draft,"The product contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data.","Hard-coded credentials typically create a significant hole that allows an attacker to bypass the authentication that has been configured by the product administrator. This hole might be difficult for the system administrator to detect. Even if detected, it can be difficult to fix, so the administrator may be forced into disabling the product entirely. There are two main variations: Inbound: the product contains an authentication mechanism that checks the input credentials against a hard-coded set of credentials. Outbound: the product connects to another system or component, and it contains hard-coded credentials for connecting to that component. In the Inbound variant, a default administration account is created, and a simple password is hard-coded into the product and associated with that account. This hard-coded password is the same for each installation of the product, and it usually cannot be changed or disabled by system administrators without manually modifying the program, or otherwise patching the product. If the password is ever discovered or published (a common occurrence on the Internet), then anybody with knowledge of this password can access the product. Finally, since all installations of the product will have the same password, even across different organizations, this enables massive attacks such as worms to take place. The Outbound variant applies to front-end systems that authenticate with a back-end service. The back-end service may require a fixed password which can be easily discovered. The programmer may simply hard-code those back-end credentials into the front-end product. Any user of that program may be able to extract the password. Client-side systems with hard-coded passwords pose even more of a threat, since the extraction of a password from a binary is usually very simple.",::NATURE:ChildOf:CWE ID:1391:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:287:VIEW ID:1003:ORDINAL:Primary::NATURE:ChildOf:CWE ID:344:VIEW ID:1000::NATURE:ChildOf:CWE ID:671:VIEW ID:1000::NATURE:PeerOf:CWE ID:257:VIEW ID:1000::,::ORDINALITY:Primary::,::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::TECHNOLOGY CLASS:Mobile:TECHNOLOGY PREVALENCE:Undetermined::TECHNOLOGY CLASS:ICS/OT:TECHNOLOGY PREVALENCE:Often::,,,::PHASE:Architecture and Design:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::,,,"::SCOPE:Access Control:IMPACT:Bypass Protection Mechanism:NOTE:If hard-coded passwords are used, it is almost certain that malicious users will gain access to the account in question.::SCOPE:Integrity:SCOPE:Confidentiality:SCOPE:Availability:SCOPE:Access Control:SCOPE:Other:IMPACT:Read Application Data:IMPACT:Gain Privileges or Assume Identity:IMPACT:Execute Unauthorized Code or Commands:IMPACT:Other:NOTE:This weakness can lead to the exposure of resources or functionality to unintended actors, possibly providing attackers with sensitive information or even execute arbitrary code.::","::METHOD:Black Box:DESCRIPTION:Credential storage in configuration files is findable using black box methods, but the use of hard-coded credentials for an incoming authentication routine typically involves an account that is not visible outside of the code.:EFFECTIVENESS:Moderate::METHOD:Automated Static Analysis:DESCRIPTION:Automated white box techniques have been published for detecting hard-coded credentials for incoming authentication, but there is some expert disagreement regarding their effectiveness and applicability to a broad range of methods.::METHOD:Manual Static Analysis:DESCRIPTION:This weakness may be detectable using manual code analysis. Unless authentication is decentralized and applied throughout the product, there can be sufficient time for the analyst to find incoming authentication routines and examine the program logic looking for usage of hard-coded credentials. Configuration files could also be analyzed.::METHOD:Manual Dynamic Analysis:DESCRIPTION:For hard-coded credentials in incoming authentication: use monitoring tools that examine the product's process as it interacts with the operating system and the network. This technique is useful in cases when source code is unavailable, if the product was not developed by you, or if you want to verify that the build phase did not introduce any new weaknesses. Examples include debuggers that directly attach to the running process; system-call tracing utilities such as truss (Solaris) and strace (Linux); system activity monitors such as FileMon, RegMon, Process Monitor, and other Sysinternals utilities (Windows); and sniffers and protocol analyzers that monitor network traffic. Attach the monitor to the process and perform a login. Using call trees or similar artifacts from the output, examine the associated behaviors and see if any of them appear to be comparing the input to a fixed string or value.::METHOD:Automated Static Analysis - Binary or Bytecode:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Bytecode Weakness Analysis - including disassembler + source code weakness analysis Binary Weakness Analysis - including disassembler + source code weakness analysis:EFFECTIVENESS:SOAR Partial::METHOD:Manual Static Analysis - Binary or Bytecode:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Binary / Bytecode disassembler - then use manual analysis for vulnerabilities & anomalies:EFFECTIVENESS:High::METHOD:Dynamic Analysis with Manual Results Interpretation:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Network Sniffer Forced Path Execution:EFFECTIVENESS:SOAR Partial::METHOD:Manual Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Focused Manual Spotcheck - Focused manual analysis of source Manual Source Code Review (not inspections):EFFECTIVENESS:High::METHOD:Automated Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Source code Weakness Analyzer Context-configured Source Code Weakness Analyzer:EFFECTIVENESS:High::METHOD:Automated Static Analysis:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Configuration Checker:EFFECTIVENESS:SOAR Partial::METHOD:Architecture or Design Review:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.) Formal Methods / Correct-By-Construction:EFFECTIVENESS:High::","::PHASE:Architecture and Design:DESCRIPTION:For outbound authentication: store passwords, keys, and other credentials outside of the code in a strongly-protected, encrypted configuration file or database that is protected from access by all outsiders, including other local users on the same system. Properly protect the key (CWE-320). If you cannot use encryption to protect the file, then make sure that the permissions are as restrictive as possible [REF-7]. In Windows environments, the Encrypted File System (EFS) may provide some protection.::PHASE:Architecture and Design:DESCRIPTION:For inbound authentication: Rather than hard-code a default username and password, key, or other authentication credentials for first time logins, utilize a first login mode that requires the user to enter a unique strong password or key.::PHASE:Architecture and Design:DESCRIPTION:If the product must contain hard-coded credentials or they cannot be removed, perform access control checks and limit which entities can access the feature that requires the hard-coded credentials. For example, a feature might only be enabled through the system console instead of through a network connection.::PHASE:Architecture and Design:DESCRIPTION:For inbound authentication using passwords: apply strong one-way hashes to passwords and store those hashes in a configuration file or database with appropriate access control. That way, theft of the file/database still requires the attacker to try to crack the password. When handling an incoming password during authentication, take the hash of the password and compare it to the saved hash. Use randomly assigned salts for each separate hash that is generated. This increases the amount of computation that an attacker needs to conduct a brute-force attack, possibly limiting the effectiveness of the rainbow table method.::PHASE:Architecture and Design:DESCRIPTION:For front-end to back-end connections: Three solutions are possible, although none are complete. The first suggestion involves the use of generated passwords or keys that are changed automatically and must be entered at given time intervals by a system administrator. These passwords will be held in memory and only be valid for the time intervals. Next, the passwords or keys should be limited at the back end to only performing actions valid for the front end, as opposed to having full access. Finally, the messages sent should be tagged and checksummed with time sensitive values so as to prevent replay-style attacks.::","::REFERENCE:CVE-2022-29953:DESCRIPTION:Condition Monitor firmware has a maintenance interface with hard-coded credentials:LINK:https://www.cve.org/CVERecord?id=CVE-2022-29953::REFERENCE:CVE-2022-29960:DESCRIPTION:Engineering Workstation uses hard-coded cryptographic keys that could allow for unathorized filesystem access and privilege escalation:LINK:https://www.cve.org/CVERecord?id=CVE-2022-29960::REFERENCE:CVE-2022-29964:DESCRIPTION:Distributed Control System (DCS) has hard-coded passwords for local shell access:LINK:https://www.cve.org/CVERecord?id=CVE-2022-29964::REFERENCE:CVE-2022-30997:DESCRIPTION:Programmable Logic Controller (PLC) has a maintenance service that uses undocumented, hard-coded credentials:LINK:https://www.cve.org/CVERecord?id=CVE-2022-30997::REFERENCE:CVE-2022-30314:DESCRIPTION:Firmware for a Safety Instrumented System (SIS) has hard-coded credentials for access to boot configuration:LINK:https://www.cve.org/CVERecord?id=CVE-2022-30314::REFERENCE:CVE-2022-30271:DESCRIPTION:Remote Terminal Unit (RTU) uses a hard-coded SSH private key that is likely to be used in typical deployments:LINK:https://www.cve.org/CVERecord?id=CVE-2022-30271::REFERENCE:CVE-2021-37555:DESCRIPTION:Telnet service for IoT feeder for dogs and cats has hard-coded password [REF-1288]:LINK:https://www.cve.org/CVERecord?id=CVE-2021-37555::REFERENCE:CVE-2012-3503:DESCRIPTION:Installation script has a hard-coded secret token value, allowing attackers to bypass authentication:LINK:https://www.cve.org/CVERecord?id=CVE-2012-3503::REFERENCE:CVE-2010-2772:DESCRIPTION:SCADA system uses a hard-coded password to protect back-end database containing authorization information, exploited by Stuxnet worm:LINK:https://www.cve.org/CVERecord?id=CVE-2010-2772::REFERENCE:CVE-2010-2073:DESCRIPTION:FTP server library uses hard-coded usernames and passwords for three default accounts:LINK:https://www.cve.org/CVERecord?id=CVE-2010-2073::REFERENCE:CVE-2010-1573:DESCRIPTION:Chain: Router firmware uses hard-coded username and password for access to debug functionality, which can be used to execute arbitrary code:LINK:https://www.cve.org/CVERecord?id=CVE-2010-1573::REFERENCE:CVE-2008-2369:DESCRIPTION:Server uses hard-coded authentication key:LINK:https://www.cve.org/CVERecord?id=CVE-2008-2369::REFERENCE:CVE-2008-0961:DESCRIPTION:Backup product uses hard-coded username and password, allowing attackers to bypass authentication via the RPC interface:LINK:https://www.cve.org/CVERecord?id=CVE-2008-0961::REFERENCE:CVE-2008-1160:DESCRIPTION:Security appliance uses hard-coded password allowing attackers to gain root access:LINK:https://www.cve.org/CVERecord?id=CVE-2008-1160::REFERENCE:CVE-2006-7142:DESCRIPTION:Drive encryption product stores hard-coded cryptographic keys for encrypted configuration files in executable programs:LINK:https://www.cve.org/CVERecord?id=CVE-2006-7142::REFERENCE:CVE-2005-3716:DESCRIPTION:VoIP product uses hard-coded public credentials that cannot be changed, which allows attackers to obtain sensitive information:LINK:https://www.cve.org/CVERecord?id=CVE-2005-3716::REFERENCE:CVE-2005-3803:DESCRIPTION:VoIP product uses hard coded public and private SNMP community strings that cannot be changed, which allows remote attackers to obtain sensitive information:LINK:https://www.cve.org/CVERecord?id=CVE-2005-3803::REFERENCE:CVE-2005-0496:DESCRIPTION:Backup product contains hard-coded credentials that effectively serve as a back door, which allows remote attackers to access the file system:LINK:https://www.cve.org/CVERecord?id=CVE-2005-0496::",,,::TAXONOMY NAME:The CERT Oracle Secure Coding Standard for Java (2011):ENTRY ID:MSC03-J:ENTRY NAME:Never hard code sensitive information::TAXONOMY NAME:OMG ASCSM:ENTRY ID:ASCSM-CWE-798::TAXONOMY NAME:ISA/IEC 62443:ENTRY ID:Part 3-3:ENTRY NAME:Req SR 1.5::TAXONOMY NAME:ISA/IEC 62443:ENTRY ID:Part 4-2:ENTRY NAME:Req CR 1.5::,::191::70::,"::TYPE:Maintenance:NOTE:The Taxonomy_Mappings to ISA/IEC 62443 were added in CWE 4.10, but they are still under review and might change in future CWE versions. These draft mappings were performed by members of the Mapping CWE to 62443 subgroup of the CWE-CAPEC ICS/OT Special Interest Group (SIG), and their work is incomplete as of CWE 4.10. The mappings are included to facilitate discussion and review by the broader ICS/OT community, and they are likely to change in future CWE versions.::"
804,Guessable CAPTCHA,Base,Incomplete,"The product uses a CAPTCHA challenge, but the challenge can be guessed or automatically recognized by a non-human actor.","An automated attacker could bypass the intended protection of the CAPTCHA challenge and perform actions at a higher frequency than humanly possible, such as launching spam attacks. There can be several different causes of a guessable CAPTCHA: An audio or visual image that does not have sufficient distortion from the unobfuscated source image. A question is generated with a format that can be automatically recognized, such as a math question. A question for which the number of possible answers is limited, such as birth years or favorite sports teams. A general-knowledge or trivia question for which the answer can be accessed using a data base, such as country capitals or popular entertainers. Other data associated with the CAPTCHA may provide hints about its contents, such as an image whose filename contains the word that is used in the CAPTCHA.",::NATURE:ChildOf:CWE ID:863:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:1390:VIEW ID:1000::,::ORDINALITY:Primary::,::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::TECHNOLOGY NAME:Web Server:TECHNOLOGY PREVALENCE:Sometimes::,,,::PHASE:Architecture and Design::PHASE:Implementation::,,,"::SCOPE:Access Control:SCOPE:Other:IMPACT:Bypass Protection Mechanism:IMPACT:Other:NOTE:When authorization, authentication, or another protection mechanism relies on CAPTCHA entities to ensure that only human actors can access certain functionality, then an automated attacker such as a bot may access the restricted functionality by guessing the CAPTCHA.::",,,,,,::TAXONOMY NAME:WASC:ENTRY ID:21:ENTRY NAME:Insufficient Anti-Automation::,,
805,Buffer Access with Incorrect Length Value,Base,Incomplete,"The product uses a sequential operation to read or write a buffer, but it uses an incorrect length value that causes it to access memory that is outside of the bounds of the buffer.","When the length value exceeds the size of the destination, a buffer overflow could occur.",::NATURE:ChildOf:CWE ID:119:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:119:VIEW ID:1305:ORDINAL:Primary::NATURE:ChildOf:CWE ID:119:VIEW ID:1340:ORDINAL:Primary::,::ORDINALITY:Resultant::ORDINALITY:Primary::,::LANGUAGE NAME:C:LANGUAGE PREVALENCE:Often::LANGUAGE NAME:C++:LANGUAGE PREVALENCE:Often::LANGUAGE CLASS:Assembly:LANGUAGE PREVALENCE:Undetermined::,,,::PHASE:Implementation::,,,"::SCOPE:Integrity:SCOPE:Confidentiality:SCOPE:Availability:IMPACT:Read Memory:IMPACT:Modify Memory:IMPACT:Execute Unauthorized Code or Commands:NOTE:Buffer overflows often can be used to execute arbitrary code, which is usually outside the scope of a program's implicit security policy. This can often be used to subvert any other security service.::SCOPE:Availability:IMPACT:Modify Memory:IMPACT:DoS: Crash, Exit, or Restart:IMPACT:DoS: Resource Consumption (CPU):NOTE:Buffer overflows generally lead to crashes. Other attacks leading to lack of availability are possible, including putting the program into an infinite loop.::","::METHOD:Automated Static Analysis:DESCRIPTION:This weakness can often be detected using automated static analysis tools. Many modern tools use data flow analysis or constraint-based techniques to minimize the number of false positives. Automated static analysis generally does not account for environmental considerations when reporting out-of-bounds memory operations. This can make it difficult for users to determine which warnings should be investigated first. For example, an analysis tool might report buffer overflows that originate from command line arguments in a program that is not expected to run with setuid or other special privileges.:EFFECTIVENESS:High::METHOD:Automated Dynamic Analysis:DESCRIPTION:This weakness can be detected using dynamic tools and techniques that interact with the product using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The product's operation may slow down, but it should not become unstable, crash, or generate incorrect results.:EFFECTIVENESS:Moderate::METHOD:Manual Analysis:DESCRIPTION:Manual analysis can be useful for finding this weakness, but it might not achieve desired code coverage within limited time constraints. This becomes difficult for weaknesses that must be considered for all inputs, since the attack surface can be too large.::","::PHASE:Requirements:STRATEGY:Language Selection:DESCRIPTION:Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. For example, many languages that perform their own memory management, such as Java and Perl, are not subject to buffer overflows. Other languages, such as Ada and C#, typically provide overflow protection, but the protection can be disabled by the programmer. Be wary that a language's interface to native code may still be subject to overflows, even if the language itself is theoretically safe.::PHASE:Architecture and Design:STRATEGY:Libraries or Frameworks:DESCRIPTION:Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. Examples include the Safe C String Library (SafeStr) by Messier and Viega [REF-57], and the Strsafe.h library from Microsoft [REF-56]. These libraries provide safer versions of overflow-prone string-handling functions.::PHASE:Build and Compilation:STRATEGY:Compilation or Build Hardening:DESCRIPTION:Run or compile the product using features or extensions that automatically provide a protection mechanism that mitigates or eliminates buffer overflows. For example, certain compilers and extensions provide automatic buffer overflow detection mechanisms that are built into the compiled code. Examples include the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice.:EFFECTIVENESS:Defense in Depth::PHASE:Implementation:DESCRIPTION:Consider adhering to the following rules when allocating and managing an application's memory: Double check that the buffer is as large as specified. When using functions that accept a number of bytes to copy, such as strncpy(), be aware that if the destination buffer size is equal to the source buffer size, it may not NULL-terminate the string. Check buffer boundaries if accessing the buffer in a loop and make sure there is no danger of writing past the allocated space. If necessary, truncate all input strings to a reasonable length before passing them to the copy and concatenation functions.::PHASE:Architecture and Design:DESCRIPTION:For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.::PHASE:Operation:STRATEGY:Environment Hardening:DESCRIPTION:Run or compile the product using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code. Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64].:EFFECTIVENESS:Defense in Depth::PHASE:Operation:STRATEGY:Environment Hardening:DESCRIPTION:Use a CPU and operating system that offers Data Execution Protection (NX) or its equivalent [REF-60] [REF-61].:EFFECTIVENESS:Defense in Depth::PHASE:Architecture and Design Operation:STRATEGY:Environment Hardening:DESCRIPTION:Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the product or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.::PHASE:Architecture and Design Operation:STRATEGY:Sandbox or Jail:DESCRIPTION:Run the code in a jail or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software. OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations. This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise. Be careful to avoid CWE-243 and other weaknesses related to jails.:EFFECTIVENESS:Limited::","::REFERENCE:CVE-2011-1959:DESCRIPTION:Chain: large length value causes buffer over-read (CWE-126):LINK:https://www.cve.org/CVERecord?id=CVE-2011-1959::REFERENCE:CVE-2011-1848:DESCRIPTION:Use of packet length field to make a calculation, then copy into a fixed-size buffer:LINK:https://www.cve.org/CVERecord?id=CVE-2011-1848::REFERENCE:CVE-2011-0105:DESCRIPTION:Chain: retrieval of length value from an uninitialized memory location:LINK:https://www.cve.org/CVERecord?id=CVE-2011-0105::REFERENCE:CVE-2011-0606:DESCRIPTION:Crafted length value in document reader leads to buffer overflow:LINK:https://www.cve.org/CVERecord?id=CVE-2011-0606::REFERENCE:CVE-2011-0651:DESCRIPTION:SSL server overflow when the sum of multiple length fields exceeds a given value:LINK:https://www.cve.org/CVERecord?id=CVE-2011-0651::REFERENCE:CVE-2010-4156:DESCRIPTION:Language interpreter API function doesn't validate length argument, leading to information exposure:LINK:https://www.cve.org/CVERecord?id=CVE-2010-4156::",,::Memory::,::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:ARR38-C:ENTRY NAME:Guarantee that library functions do not form invalid pointers:MAPPING FIT:Imprecise::,::100::256::,
807,Reliance on Untrusted Inputs in a Security Decision,Base,Incomplete,"The product uses a protection mechanism that relies on the existence or values of an input, but the input can be modified by an untrusted actor in a way that bypasses the protection mechanism.","Developers may assume that inputs such as cookies, environment variables, and hidden form fields cannot be modified. However, an attacker could change these inputs using customized clients or other attacks. This change might not be detected. When security decisions such as authentication and authorization are made based on the values of these inputs, attackers can bypass the security of the software. Without sufficient encryption, integrity checking, or other mechanism, any input that originates from an outsider cannot be trusted.",::NATURE:ChildOf:CWE ID:693:VIEW ID:1000:ORDINAL:Primary::,,::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::,,,::PHASE:Architecture and Design:NOTE:COMMISSION: This weakness refers to an incorrect design related to an architectural security tactic.::PHASE:Implementation::,,,"::SCOPE:Confidentiality:SCOPE:Access Control:SCOPE:Availability:SCOPE:Other:IMPACT:Bypass Protection Mechanism:IMPACT:Gain Privileges or Assume Identity:IMPACT:Varies by Context:NOTE:Attackers can bypass the security decision to access whatever is being protected. The consequences will depend on the associated functionality, but they can range from granting additional privileges to untrusted users to bypassing important security checks. Ultimately, this weakness may lead to exposure or modification of sensitive data, system crash, or execution of arbitrary code.::","::METHOD:Manual Static Analysis:DESCRIPTION:Since this weakness does not typically appear frequently within a single software package, manual white box techniques may be able to provide sufficient code coverage and reduction of false positives if all potentially-vulnerable operations can be assessed within limited time constraints.:EFFECTIVENESS:High::METHOD:Automated Static Analysis - Binary or Bytecode:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Bytecode Weakness Analysis - including disassembler + source code weakness analysis Binary Weakness Analysis - including disassembler + source code weakness analysis:EFFECTIVENESS:SOAR Partial::METHOD:Manual Static Analysis - Binary or Bytecode:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Binary / Bytecode disassembler - then use manual analysis for vulnerabilities & anomalies:EFFECTIVENESS:SOAR Partial::METHOD:Dynamic Analysis with Automated Results Interpretation:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Web Application Scanner Web Services Scanner Database Scanners:EFFECTIVENESS:SOAR Partial::METHOD:Dynamic Analysis with Manual Results Interpretation:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Fuzz Tester Framework-based Fuzzer Monitored Virtual Environment - run potentially malicious code in sandbox / wrapper / virtual machine, see if it does anything suspicious:EFFECTIVENESS:SOAR Partial::METHOD:Manual Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Manual Source Code Review (not inspections):EFFECTIVENESS:High::METHOD:Automated Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Source code Weakness Analyzer Context-configured Source Code Weakness Analyzer:EFFECTIVENESS:SOAR Partial::METHOD:Architecture or Design Review:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.) Formal Methods / Correct-By-Construction Cost effective for partial coverage: Attack Modeling:EFFECTIVENESS:High::","::PHASE:Architecture and Design:STRATEGY:Attack Surface Reduction:DESCRIPTION:Store state information and sensitive data on the server side only. Ensure that the system definitively and unambiguously keeps track of its own state and user state and has rules defined for legitimate state transitions. Do not allow any application user to affect state directly in any way other than through legitimate actions leading to state transitions. If information must be stored on the client, do not do so without encryption and integrity checking, or otherwise having a mechanism on the server side to catch tampering. Use a message authentication code (MAC) algorithm, such as Hash Message Authentication Code (HMAC) [REF-529]. Apply this against the state or sensitive data that you has to be exposed, which can guarantee the integrity of the data - i.e., that the data has not been modified. Ensure that a strong hash function is used (CWE-328).::PHASE:Architecture and Design:STRATEGY:Libraries or Frameworks:DESCRIPTION:Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. With a stateless protocol such as HTTP, use a framework that maintains the state for you. Examples include ASP.NET View State [REF-756] and the OWASP ESAPI Session Management feature [REF-45]. Be careful of language features that provide state support, since these might be provided as a convenience to the programmer and may not be considering security.::PHASE:Architecture and Design:DESCRIPTION:For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.::PHASE:Operation Implementation:STRATEGY:Environment Hardening:DESCRIPTION:When using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE-95, CWE-621, and similar issues.::PHASE:Architecture and Design Implementation:STRATEGY:Attack Surface Reduction:DESCRIPTION:Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, filenames, databases, and any external systems that provide data to the application. Remember that such inputs may be obtained indirectly through API calls. Identify all inputs that are used for security decisions and determine if you can modify the design so that you do not have to rely on submitted inputs at all. For example, you may be able to keep critical information about the user's session on the server side instead of recording it within external data.::",::REFERENCE:CVE-2009-1549:DESCRIPTION:Attacker can bypass authentication by setting a cookie to a specific value.:LINK:https://www.cve.org/CVERecord?id=CVE-2009-1549::REFERENCE:CVE-2009-1619:DESCRIPTION:Attacker can bypass authentication and gain admin privileges by setting an admin cookie to 1.:LINK:https://www.cve.org/CVERecord?id=CVE-2009-1619::REFERENCE:CVE-2009-0864:DESCRIPTION:Content management system allows admin privileges by setting a login cookie to OK.:LINK:https://www.cve.org/CVERecord?id=CVE-2009-0864::REFERENCE:CVE-2008-5784:DESCRIPTION:e-dating application allows admin privileges by setting the admin cookie to 1.:LINK:https://www.cve.org/CVERecord?id=CVE-2008-5784::REFERENCE:CVE-2008-6291:DESCRIPTION:Web-based email list manager allows attackers to gain admin privileges by setting a login cookie to admin.:LINK:https://www.cve.org/CVERecord?id=CVE-2008-6291::,,,::TAXONOMY NAME:The CERT Oracle Secure Coding Standard for Java (2011):ENTRY ID:SEC09-J:ENTRY NAME:Do not base security checks on untrusted sources::,,
820,Missing Synchronization,Base,Incomplete,The product utilizes a shared resource in a concurrent manner but does not attempt to synchronize access to the resource.,"If access to a shared resource is not synchronized, then the resource may not be in a state that is expected by the product. This might lead to unexpected or insecure behaviors, especially if an attacker can influence the shared resource.",::NATURE:ChildOf:CWE ID:662:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:662:VIEW ID:1305:ORDINAL:Primary::NATURE:ChildOf:CWE ID:662:VIEW ID:1340:ORDINAL:Primary::,,,,,,,,::SCOPE:Integrity:SCOPE:Confidentiality:SCOPE:Other:IMPACT:Modify Application Data:IMPACT:Read Application Data:IMPACT:Alter Execution Logic::,,,,,,::TAXONOMY NAME:The CERT Oracle Secure Coding Standard for Java (2011):ENTRY ID:LCK05-J:ENTRY NAME:Synchronize access to static fields that can be modified by untrusted code::,,"::TYPE:Maintenance:NOTE:Deeper research is necessary for synchronization and related mechanisms, including locks, mutexes, semaphores, and other mechanisms. Multiple entries are dependent on this research, which includes relationships to concurrency, race conditions, reentrant functions, etc. CWE-662 and its children - including CWE-667, CWE-820, CWE-821, and others - may need to be modified significantly, along with their relationships.::"
821,Incorrect Synchronization,Base,Incomplete,"The product utilizes a shared resource in a concurrent manner, but it does not correctly synchronize access to the resource.","If access to a shared resource is not correctly synchronized, then the resource may not be in a state that is expected by the product. This might lead to unexpected or insecure behaviors, especially if an attacker can influence the shared resource.",::NATURE:ChildOf:CWE ID:662:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:662:VIEW ID:1305:ORDINAL:Primary::NATURE:ChildOf:CWE ID:662:VIEW ID:1340:ORDINAL:Primary::,,,,,,,,::SCOPE:Integrity:SCOPE:Confidentiality:SCOPE:Other:IMPACT:Modify Application Data:IMPACT:Read Application Data:IMPACT:Alter Execution Logic::,,,,,,,,"::TYPE:Maintenance:NOTE:Deeper research is necessary for synchronization and related mechanisms, including locks, mutexes, semaphores, and other mechanisms. Multiple entries are dependent on this research, which includes relationships to concurrency, race conditions, reentrant functions, etc. CWE-662 and its children - including CWE-667, CWE-820, CWE-821, and others - may need to be modified significantly, along with their relationships.::"
822,Untrusted Pointer Dereference,Base,Incomplete,"The product obtains a value from an untrusted source, converts this value to a pointer, and dereferences the resulting pointer.","An attacker can supply a pointer for memory locations that the product is not expecting. If the pointer is dereferenced for a write operation, the attack might allow modification of critical state variables, cause a crash, or execute code. If the dereferencing operation is for a read, then the attack might allow reading of sensitive data, cause a crash, or set a variable to an unexpected value (since the value will be read from an unexpected memory location). There are several variants of this weakness, including but not necessarily limited to: The untrusted value is directly invoked as a function call. In OS kernels or drivers where there is a boundary between userland and privileged memory spaces, an untrusted pointer might enter through an API or system call (see CWE-781 for one such example). Inadvertently accepting the value from an untrusted control sphere when it did not have to be accepted as input at all. This might occur when the code was originally developed to be run by a single user in a non-networked environment, and the code is then ported to or otherwise exposed to a networked environment.",::NATURE:ChildOf:CWE ID:119:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:119:VIEW ID:1305:ORDINAL:Primary::NATURE:ChildOf:CWE ID:119:VIEW ID:1340:ORDINAL:Primary::NATURE:CanPrecede:CWE ID:125:VIEW ID:1000::NATURE:CanPrecede:CWE ID:787:VIEW ID:1000::,,,,,,,,"::SCOPE:Confidentiality:IMPACT:Read Memory:NOTE:If the untrusted pointer is used in a read operation, an attacker might be able to read sensitive portions of memory.::SCOPE:Availability:IMPACT:DoS: Crash, Exit, or Restart:NOTE:If the untrusted pointer references a memory location that is not accessible to the product, or points to a location that is malformed or larger than expected by a read or write operation, the application may terminate unexpectedly.::SCOPE:Integrity:SCOPE:Confidentiality:SCOPE:Availability:IMPACT:Execute Unauthorized Code or Commands:IMPACT:Modify Memory:NOTE:If the untrusted pointer is used in a function call, or points to unexpected data in a write operation, then code execution may be possible.::",,,"::REFERENCE:CVE-2007-5655:DESCRIPTION:message-passing framework interprets values in packets as pointers, causing a crash.:LINK:https://www.cve.org/CVERecord?id=CVE-2007-5655::REFERENCE:CVE-2010-2299:DESCRIPTION:labeled as a type confusion issue, also referred to as a stale pointer. However, the bug ID says contents are simply interpreted as a pointer... renderer ordinarily doesn't supply this pointer directly. The handle in the untrusted area is replaced in one function, but not another - thus also, effectively, exposure to wrong sphere (CWE-668).:LINK:https://www.cve.org/CVERecord?id=CVE-2010-2299::REFERENCE:CVE-2009-1719:DESCRIPTION:Untrusted dereference using undocumented constructor.:LINK:https://www.cve.org/CVERecord?id=CVE-2009-1719::REFERENCE:CVE-2009-1250:DESCRIPTION:An error code is incorrectly checked and interpreted as a pointer, leading to a crash.:LINK:https://www.cve.org/CVERecord?id=CVE-2009-1250::REFERENCE:CVE-2009-0311:DESCRIPTION:An untrusted value is obtained from a packet and directly called as a function pointer, leading to code execution.:LINK:https://www.cve.org/CVERecord?id=CVE-2009-0311::REFERENCE:CVE-2010-1818:DESCRIPTION:Undocumented attribute in multimedia software allows unmarshaling of an untrusted pointer.:LINK:https://www.cve.org/CVERecord?id=CVE-2010-1818::REFERENCE:CVE-2010-3189:DESCRIPTION:ActiveX control for security software accepts a parameter that is assumed to be an initialized pointer.:LINK:https://www.cve.org/CVERecord?id=CVE-2010-3189::REFERENCE:CVE-2010-1253:DESCRIPTION:Spreadsheet software treats certain record values that lead to user-controlled pointer (might be untrusted offset, not untrusted pointer).:LINK:https://www.cve.org/CVERecord?id=CVE-2010-1253::",,,,::129::,"::TYPE:Maintenance:NOTE:There are close relationships between incorrect pointer dereferences and other weaknesses related to buffer operations. There may not be sufficient community agreement regarding these relationships. Further study is needed to determine when these relationships are chains, composites, perspective/layering, or other types of relationships. As of September 2010, most of the relationships are being captured as chains.::TYPE:Terminology:NOTE:Many weaknesses related to pointer dereferences fall under the general term of memory corruption or memory safety. As of September 2010, there is no commonly-used terminology that covers the lower-level variants.::"
823,Use of Out-of-range Pointer Offset,Base,Incomplete,"The product performs pointer arithmetic on a valid pointer, but it uses an offset that can point outside of the intended range of valid memory locations for the resulting pointer.","While a pointer can contain a reference to any arbitrary memory location, a program typically only intends to use the pointer to access limited portions of memory, such as contiguous memory used to access an individual array. Programs may use offsets in order to access fields or sub-elements stored within structured data. The offset might be out-of-range if it comes from an untrusted source, is the result of an incorrect calculation, or occurs because of another error. If an attacker can control or influence the offset so that it points outside of the intended boundaries of the structure, then the attacker may be able to read or write to memory locations that are used elsewhere in the product. As a result, the attack might change the state of the product as accessed through program variables, cause a crash or instable behavior, and possibly lead to code execution.",::NATURE:ChildOf:CWE ID:119:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:119:VIEW ID:1305:ORDINAL:Primary::NATURE:ChildOf:CWE ID:119:VIEW ID:1340:ORDINAL:Primary::NATURE:CanPrecede:CWE ID:125:VIEW ID:1000::NATURE:CanPrecede:CWE ID:787:VIEW ID:1000::,,,,"::TERM:Untrusted pointer offset:DESCRIPTION:This term is narrower than the concept of out-of-range offset, since the offset might be the result of a calculation or other error that does not depend on any externally-supplied values.::",,,,"::SCOPE:Confidentiality:IMPACT:Read Memory:NOTE:If the untrusted pointer is used in a read operation, an attacker might be able to read sensitive portions of memory.::SCOPE:Availability:IMPACT:DoS: Crash, Exit, or Restart:NOTE:If the untrusted pointer references a memory location that is not accessible to the program, or points to a location that is malformed or larger than expected by a read or write operation, the application may terminate unexpectedly.::SCOPE:Integrity:SCOPE:Confidentiality:SCOPE:Availability:IMPACT:Execute Unauthorized Code or Commands:IMPACT:Modify Memory:NOTE:If the untrusted pointer is used in a function call, or points to unexpected data in a write operation, then code execution may be possible.::",,,"::REFERENCE:CVE-2010-2160:DESCRIPTION:Invalid offset in undocumented opcode leads to memory corruption.:LINK:https://www.cve.org/CVERecord?id=CVE-2010-2160::REFERENCE:CVE-2010-1281:DESCRIPTION:Multimedia player uses untrusted value from a file when using file-pointer calculations.:LINK:https://www.cve.org/CVERecord?id=CVE-2010-1281::REFERENCE:CVE-2009-3129:DESCRIPTION:Spreadsheet program processes a record with an invalid size field, which is later used as an offset.:LINK:https://www.cve.org/CVERecord?id=CVE-2009-3129::REFERENCE:CVE-2009-2694:DESCRIPTION:Instant messaging library does not validate an offset value specified in a packet.:LINK:https://www.cve.org/CVERecord?id=CVE-2009-2694::REFERENCE:CVE-2009-2687:DESCRIPTION:Language interpreter does not properly handle invalid offsets in JPEG image, leading to out-of-bounds memory access and crash.:LINK:https://www.cve.org/CVERecord?id=CVE-2009-2687::REFERENCE:CVE-2009-0690:DESCRIPTION:negative offset leads to out-of-bounds read:LINK:https://www.cve.org/CVERecord?id=CVE-2009-0690::REFERENCE:CVE-2008-4114:DESCRIPTION:untrusted offset in kernel:LINK:https://www.cve.org/CVERecord?id=CVE-2008-4114::REFERENCE:CVE-2010-2873:DESCRIPTION:blind trust of an offset value while writing heap memory allows corruption of function pointer,leading to code execution:LINK:https://www.cve.org/CVERecord?id=CVE-2010-2873::REFERENCE:CVE-2010-2866:DESCRIPTION:negative value (signed) causes pointer miscalculation:LINK:https://www.cve.org/CVERecord?id=CVE-2010-2866::REFERENCE:CVE-2010-2872:DESCRIPTION:signed values cause incorrect pointer calculation:LINK:https://www.cve.org/CVERecord?id=CVE-2010-2872::REFERENCE:CVE-2007-5657:DESCRIPTION:values used as pointer offsets:LINK:https://www.cve.org/CVERecord?id=CVE-2007-5657::REFERENCE:CVE-2010-2867:DESCRIPTION:a return value from a function is sign-extended if the value is signed, then used as an offset for pointer arithmetic:LINK:https://www.cve.org/CVERecord?id=CVE-2010-2867::REFERENCE:CVE-2009-1097:DESCRIPTION:portions of a GIF image used as offsets, causing corruption of an object pointer.:LINK:https://www.cve.org/CVERecord?id=CVE-2009-1097::REFERENCE:CVE-2008-1807:DESCRIPTION:invalid numeric field leads to a free of arbitrary memory locations, then code execution.:LINK:https://www.cve.org/CVERecord?id=CVE-2008-1807::REFERENCE:CVE-2007-2500:DESCRIPTION:large number of elements leads to a free of an arbitrary address:LINK:https://www.cve.org/CVERecord?id=CVE-2007-2500::REFERENCE:CVE-2008-1686:DESCRIPTION:array index issue (CWE-129) with negative offset, used to dereference a function pointer:LINK:https://www.cve.org/CVERecord?id=CVE-2008-1686::REFERENCE:CVE-2010-2878:DESCRIPTION:buffer seek value - basically an offset?:LINK:https://www.cve.org/CVERecord?id=CVE-2010-2878::",,,,::129::,"::TYPE:Maintenance:NOTE:There are close relationships between incorrect pointer dereferences and other weaknesses related to buffer operations. There may not be sufficient community agreement regarding these relationships. Further study is needed to determine when these relationships are chains, composites, perspective/layering, or other types of relationships. As of September 2010, most of the relationships are being captured as chains.::TYPE:Terminology:NOTE:Many weaknesses related to pointer dereferences fall under the general term of memory corruption or memory safety. As of September 2010, there is no commonly-used terminology that covers the lower-level variants.::"
824,Access of Uninitialized Pointer,Base,Incomplete,The product accesses or uses a pointer that has not been initialized.,"If the pointer contains an uninitialized value, then the value might not point to a valid memory location. This could cause the product to read from or write to unexpected memory locations, leading to a denial of service. If the uninitialized pointer is used as a function call, then arbitrary functions could be invoked. If an attacker can influence the portion of uninitialized memory that is contained in the pointer, this weakness could be leveraged to execute code or perform other attacks. Depending on memory layout, associated memory management behaviors, and product operation, the attacker might be able to influence the contents of the uninitialized pointer, thus gaining more fine-grained control of the memory location to be accessed.",::NATURE:ChildOf:CWE ID:119:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:119:VIEW ID:1003:ORDINAL:Primary::NATURE:ChildOf:CWE ID:119:VIEW ID:1305:ORDINAL:Primary::NATURE:ChildOf:CWE ID:119:VIEW ID:1340:ORDINAL:Primary::NATURE:CanPrecede:CWE ID:125:VIEW ID:1000::NATURE:CanPrecede:CWE ID:787:VIEW ID:1000::,,,,,,,,"::SCOPE:Confidentiality:IMPACT:Read Memory:NOTE:If the uninitialized pointer is used in a read operation, an attacker might be able to read sensitive portions of memory.::SCOPE:Availability:IMPACT:DoS: Crash, Exit, or Restart:NOTE:If the uninitialized pointer references a memory location that is not accessible to the product, or points to a location that is malformed (such as NULL) or larger than expected by a read or write operation, then a crash may occur.::SCOPE:Integrity:SCOPE:Confidentiality:SCOPE:Availability:IMPACT:Execute Unauthorized Code or Commands:NOTE:If the uninitialized pointer is used in a function call, or points to unexpected data in a write operation, then code execution may be possible.::",,,"::REFERENCE:CVE-2010-0211:DESCRIPTION:chain: unchecked return value (CWE-252) leads to free of invalid, uninitialized pointer (CWE-824).:LINK:https://www.cve.org/CVERecord?id=CVE-2010-0211::REFERENCE:CVE-2009-2768:DESCRIPTION:Pointer in structure is not initialized, leading to NULL pointer dereference (CWE-476) and system crash.:LINK:https://www.cve.org/CVERecord?id=CVE-2009-2768::REFERENCE:CVE-2009-1721:DESCRIPTION:Free of an uninitialized pointer.:LINK:https://www.cve.org/CVERecord?id=CVE-2009-1721::REFERENCE:CVE-2009-1415:DESCRIPTION:Improper handling of invalid signatures leads to free of invalid pointer.:LINK:https://www.cve.org/CVERecord?id=CVE-2009-1415::REFERENCE:CVE-2009-0846:DESCRIPTION:Invalid encoding triggers free of uninitialized pointer.:LINK:https://www.cve.org/CVERecord?id=CVE-2009-0846::REFERENCE:CVE-2009-0040:DESCRIPTION:Crafted PNG image leads to free of uninitialized pointer.:LINK:https://www.cve.org/CVERecord?id=CVE-2009-0040::REFERENCE:CVE-2008-2934:DESCRIPTION:Crafted GIF image leads to free of uninitialized pointer.:LINK:https://www.cve.org/CVERecord?id=CVE-2008-2934::REFERENCE:CVE-2007-4682:DESCRIPTION:Access of uninitialized pointer might lead to code execution.:LINK:https://www.cve.org/CVERecord?id=CVE-2007-4682::REFERENCE:CVE-2007-4639:DESCRIPTION:Step-based manipulation: invocation of debugging function before the primary initialization function leads to access of an uninitialized pointer and code execution.:LINK:https://www.cve.org/CVERecord?id=CVE-2007-4639::REFERENCE:CVE-2007-4000:DESCRIPTION:Unchecked return values can lead to a write to an uninitialized pointer.:LINK:https://www.cve.org/CVERecord?id=CVE-2007-4000::REFERENCE:CVE-2007-2442:DESCRIPTION:zero-length input leads to free of uninitialized pointer.:LINK:https://www.cve.org/CVERecord?id=CVE-2007-2442::REFERENCE:CVE-2007-1213:DESCRIPTION:Crafted font leads to uninitialized function pointer.:LINK:https://www.cve.org/CVERecord?id=CVE-2007-1213::REFERENCE:CVE-2006-6143:DESCRIPTION:Uninitialized function pointer in freed memory is invoked:LINK:https://www.cve.org/CVERecord?id=CVE-2006-6143::REFERENCE:CVE-2006-4175:DESCRIPTION:LDAP server mishandles malformed BER queries, leading to free of uninitialized memory:LINK:https://www.cve.org/CVERecord?id=CVE-2006-4175::REFERENCE:CVE-2006-0054:DESCRIPTION:Firewall can crash with certain ICMP packets that trigger access of an uninitialized pointer.:LINK:https://www.cve.org/CVERecord?id=CVE-2006-0054::REFERENCE:CVE-2003-1201:DESCRIPTION:LDAP server does not initialize members of structs, which leads to free of uninitialized pointer if an LDAP request fails.:LINK:https://www.cve.org/CVERecord?id=CVE-2003-1201::",,,,,"::TYPE:Maintenance:NOTE:There are close relationships between incorrect pointer dereferences and other weaknesses related to buffer operations. There may not be sufficient community agreement regarding these relationships. Further study is needed to determine when these relationships are chains, composites, perspective/layering, or other types of relationships. As of September 2010, most of the relationships are being captured as chains.::TYPE:Terminology:NOTE:Many weaknesses related to pointer dereferences fall under the general term of memory corruption or memory safety. As of September 2010, there is no commonly-used terminology that covers the lower-level variants.::"
825,Expired Pointer Dereference,Base,Incomplete,"The product dereferences a pointer that contains a location for memory that was previously valid, but is no longer valid.","When a product releases memory, but it maintains a pointer to that memory, then the memory might be re-allocated at a later time. If the original pointer is accessed to read or write data, then this could cause the product to read or modify data that is in use by a different function or process. Depending on how the newly-allocated memory is used, this could lead to a denial of service, information exposure, or code execution.",::NATURE:ChildOf:CWE ID:119:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:119:VIEW ID:1305:ORDINAL:Primary::NATURE:ChildOf:CWE ID:119:VIEW ID:1340:ORDINAL:Primary::NATURE:ChildOf:CWE ID:672:VIEW ID:1000::NATURE:CanPrecede:CWE ID:125:VIEW ID:1000::NATURE:CanPrecede:CWE ID:787:VIEW ID:1000::,,,,::TERM:Dangling pointer::,,,,"::SCOPE:Confidentiality:IMPACT:Read Memory:NOTE:If the expired pointer is used in a read operation, an attacker might be able to control data read in by the application.::SCOPE:Availability:IMPACT:DoS: Crash, Exit, or Restart:NOTE:If the expired pointer references a memory location that is not accessible to the product, or points to a location that is malformed (such as NULL) or larger than expected by a read or write operation, then a crash may occur.::SCOPE:Integrity:SCOPE:Confidentiality:SCOPE:Availability:IMPACT:Execute Unauthorized Code or Commands:NOTE:If the expired pointer is used in a function call, or points to unexpected data in a write operation, then code execution may be possible.::",,"::PHASE:Architecture and Design:DESCRIPTION:Choose a language that provides automatic memory management.::PHASE:Implementation:DESCRIPTION:When freeing pointers, be sure to set them to NULL once they are freed. However, the utilization of multiple or complex data structures may lower the usefulness of this strategy.::","::REFERENCE:CVE-2008-5013:DESCRIPTION:access of expired memory address leads to arbitrary code execution:LINK:https://www.cve.org/CVERecord?id=CVE-2008-5013::REFERENCE:CVE-2010-3257:DESCRIPTION:stale pointer issue leads to denial of service and possibly other consequences:LINK:https://www.cve.org/CVERecord?id=CVE-2010-3257::REFERENCE:CVE-2008-0062:DESCRIPTION:Chain: a message having an unknown message type may cause a reference to uninitialized memory resulting in a null pointer dereference (CWE-476) or dangling pointer (CWE-825), possibly crashing the system or causing heap corruption.:LINK:https://www.cve.org/CVERecord?id=CVE-2008-0062::REFERENCE:CVE-2007-1211:DESCRIPTION:read of value at an offset into a structure after the offset is no longer valid:LINK:https://www.cve.org/CVERecord?id=CVE-2007-1211::",,,,,"::TYPE:Maintenance:NOTE:There are close relationships between incorrect pointer dereferences and other weaknesses related to buffer operations. There may not be sufficient community agreement regarding these relationships. Further study is needed to determine when these relationships are chains, composites, perspective/layering, or other types of relationships. As of September 2010, most of the relationships are being captured as chains.::TYPE:Terminology:NOTE:Many weaknesses related to pointer dereferences fall under the general term of memory corruption or memory safety. As of September 2010, there is no commonly-used terminology that covers the lower-level variants.::"
826,Premature Release of Resource During Expected Lifetime,Base,Incomplete,The product releases a resource that is still intended to be used by itself or another actor.,"This weakness focuses on errors in which the product should not release a resource, but performs the release anyway. This is different than a weakness in which the product releases a resource at the appropriate time, but it maintains a reference to the resource, which it later accesses. For this weakness, the resource should still be valid upon the subsequent access. When a product releases a resource that is still being used, it is possible that operations will still be taken on this resource, which may have been repurposed in the meantime, leading to issues similar to CWE-825. Consequences may include denial of service, information exposure, or code execution.",::NATURE:ChildOf:CWE ID:666:VIEW ID:1000:ORDINAL:Primary::NATURE:CanPrecede:CWE ID:672:VIEW ID:1000::,,,,,,,,"::SCOPE:Confidentiality:IMPACT:Read Application Data:IMPACT:Read Memory:NOTE:If the released resource is subsequently reused or reallocated, then a read operation on the original resource might access sensitive data that is associated with a different user or entity.::SCOPE:Availability:IMPACT:DoS: Crash, Exit, or Restart:NOTE:When the resource is released, the software might modify some of its structure, or close associated channels (such as a file descriptor). When the software later accesses the resource as if it is valid, the resource might not be in an expected state, leading to resultant errors that may lead to a crash.::SCOPE:Integrity:SCOPE:Confidentiality:SCOPE:Availability:IMPACT:Execute Unauthorized Code or Commands:IMPACT:Modify Application Data:IMPACT:Modify Memory:NOTE:When the resource is released, the software might modify some of its structure. This might affect logic in the sections of code that still assume the resource is active. If the released resource is related to memory and is used in a function call, or points to unexpected data in a write operation, then code execution may be possible upon subsequent accesses.::",,,"::REFERENCE:CVE-2009-3547:DESCRIPTION:chain: race condition might allow resource to be released before operating on it, leading to NULL dereference:LINK:https://www.cve.org/CVERecord?id=CVE-2009-3547::",,,,,"::TYPE:Research Gap:NOTE:Under-studied and under-reported as of September 2010. This weakness has been reported in high-visibility software, although the focus has been primarily on memory allocation and de-allocation. There are very few examples of this weakness that are not directly related to memory management, although such weaknesses are likely to occur in real-world software for other types of resources.::"
828,Signal Handler with Functionality that is not Asynchronous-Safe,Base,Incomplete,"The product defines a signal handler that contains code sequences that are not asynchronous-safe, i.e., the functionality is not reentrant, or it can be interrupted.","This can lead to an unexpected system state with a variety of potential consequences depending on context, including denial of service and code execution. Signal handlers are typically intended to interrupt normal functionality of a program, or even other signals, in order to notify the process of an event. When a signal handler uses global or static variables, or invokes functions that ultimately depend on such state or its associated metadata, then it could corrupt system state that is being used by normal functionality. This could subject the program to race conditions or other weaknesses that allow an attacker to cause the program state to be corrupted. While denial of service is frequently the consequence, in some cases this weakness could be leveraged for code execution. There are several different scenarios that introduce this issue: Invocation of non-reentrant functions from within the handler. One example is malloc(), which modifies internal global variables as it manages memory. Very few functions are actually reentrant. Code sequences (not necessarily function calls) contain non-atomic use of global variables, or associated metadata or structures, that can be accessed by other functionality of the program, including other signal handlers. Frequently, the same function is registered to handle multiple signals. The signal handler function is intended to run at most one time, but instead it can be invoked multiple times. This could happen by repeated delivery of the same signal, or by delivery of different signals that have the same handler function (CWE-831). Note that in some environments or contexts, it might be possible for the signal handler to be interrupted itself. If both a signal handler and the normal behavior of the product have to operate on the same set of state variables, and a signal is received in the middle of the normal execution's modifications of those variables, the variables may be in an incorrect or corrupt state during signal handler execution, and possibly still incorrect or corrupt upon return.",::NATURE:ChildOf:CWE ID:364:VIEW ID:1000:ORDINAL:Primary::,,,,,,,,"::SCOPE:Integrity:SCOPE:Confidentiality:SCOPE:Availability:IMPACT:DoS: Crash, Exit, or Restart:IMPACT:Execute Unauthorized Code or Commands:NOTE:The most common consequence will be a corruption of the state of the product, possibly leading to a crash or exit. However, if the signal handler is operating on state variables for security relevant libraries or protection mechanisms, the consequences can be far more severe, including protection mechanism bypass, privilege escalation, or information exposure.::",,"::PHASE:Implementation Architecture and Design:DESCRIPTION:Eliminate the usage of non-reentrant functionality inside of signal handlers. This includes replacing all non-reentrant library calls with reentrant calls. Note: This will not always be possible and may require large portions of the product to be rewritten or even redesigned. Sometimes reentrant-safe library alternatives will not be available. Sometimes non-reentrant interaction between the state of the system and the signal handler will be required by design.:EFFECTIVENESS:High::PHASE:Implementation:DESCRIPTION:Where non-reentrant functionality must be leveraged within a signal handler, be sure to block or mask signals appropriately. This includes blocking other signals within the signal handler itself that may also leverage the functionality. It also includes blocking all signals reliant upon the functionality when it is being accessed or modified by the normal behaviors of the product.::","::REFERENCE:CVE-2008-4109:DESCRIPTION:Signal handler uses functions that ultimately call the unsafe syslog/malloc/s*printf, leading to denial of service via multiple login attempts:LINK:https://www.cve.org/CVERecord?id=CVE-2008-4109::REFERENCE:CVE-2006-5051:DESCRIPTION:Chain: Signal handler contains too much functionality (CWE-828), introducing a race condition (CWE-362) that leads to a double free (CWE-415).:LINK:https://www.cve.org/CVERecord?id=CVE-2006-5051::REFERENCE:CVE-2001-1349:DESCRIPTION:unsafe calls to library functions from signal handler:LINK:https://www.cve.org/CVERecord?id=CVE-2001-1349::REFERENCE:CVE-2004-0794:DESCRIPTION:SIGURG can be used to remotely interrupt signal handler; other variants exist.:LINK:https://www.cve.org/CVERecord?id=CVE-2004-0794::REFERENCE:CVE-2004-2259:DESCRIPTION:SIGCHLD signal to FTP server can cause crash under heavy load while executing non-reentrant functions like malloc/free.:LINK:https://www.cve.org/CVERecord?id=CVE-2004-2259::REFERENCE:CVE-2002-1563:DESCRIPTION:SIGCHLD not blocked in a daemon loop while counter is modified, causing counter to get out of sync.:LINK:https://www.cve.org/CVERecord?id=CVE-2002-1563::",,,::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:SIG31-C:ENTRY NAME:Do not access or modify shared objects in signal handlers::,,
829,Inclusion of Functionality from Untrusted Control Sphere,Base,Incomplete,"The product imports, requires, or includes executable functionality (such as a library) from a source that is outside of the intended control sphere.","When including third-party functionality, such as a web widget, library, or other source of functionality, the product must effectively trust that functionality. Without sufficient protection mechanisms, the functionality could be malicious in nature (either by coming from an untrusted source, being spoofed, or being modified in transit from a trusted source). The functionality might also contain its own weaknesses, or grant access to additional functionality and state information that should be kept private to the base system, such as system state information, sensitive application data, or the DOM of a web application. This might lead to many different consequences depending on the included functionality, but some examples include injection of malware, information exposure by granting excessive privileges or permissions to the untrusted functionality, DOM-based XSS vulnerabilities, stealing user's cookies, or open redirect to malware (CWE-601).",::NATURE:ChildOf:CWE ID:669:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:669:VIEW ID:1003:ORDINAL:Primary::,,,,,::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::,,,"::SCOPE:Confidentiality:SCOPE:Integrity:SCOPE:Availability:IMPACT:Execute Unauthorized Code or Commands:NOTE:An attacker could insert malicious functionality into the program by causing the program to download code that the attacker has placed into the untrusted control sphere, such as a malicious web site.::","::METHOD:Automated Static Analysis - Binary or Bytecode:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Bytecode Weakness Analysis - including disassembler + source code weakness analysis:EFFECTIVENESS:SOAR Partial::METHOD:Manual Static Analysis - Binary or Bytecode:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Binary / Bytecode disassembler - then use manual analysis for vulnerabilities & anomalies:EFFECTIVENESS:SOAR Partial::METHOD:Dynamic Analysis with Manual Results Interpretation:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Forced Path Execution Monitored Virtual Environment - run potentially malicious code in sandbox / wrapper / virtual machine, see if it does anything suspicious:EFFECTIVENESS:SOAR Partial::METHOD:Manual Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Manual Source Code Review (not inspections) Cost effective for partial coverage: Focused Manual Spotcheck - Focused manual analysis of source:EFFECTIVENESS:High::METHOD:Automated Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Source code Weakness Analyzer Context-configured Source Code Weakness Analyzer:EFFECTIVENESS:SOAR Partial::METHOD:Architecture or Design Review:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.) Formal Methods / Correct-By-Construction Cost effective for partial coverage: Attack Modeling:EFFECTIVENESS:High::","::PHASE:Architecture and Design:STRATEGY:Libraries or Frameworks:DESCRIPTION:Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.::PHASE:Architecture and Design:STRATEGY:Enforcement by Conversion:DESCRIPTION:When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs. For example, ID 1 could map to inbox.txt and ID 2 could map to profile.txt. Features such as the ESAPI AccessReferenceMap [REF-45] provide this capability.::PHASE:Architecture and Design:DESCRIPTION:For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.::PHASE:Architecture and Design Operation:STRATEGY:Sandbox or Jail:DESCRIPTION:Run the code in a jail or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software. OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations. This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise. Be careful to avoid CWE-243 and other weaknesses related to jails.:EFFECTIVENESS:Limited::PHASE:Architecture and Design Operation:STRATEGY:Environment Hardening:DESCRIPTION:Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.::PHASE:Implementation:STRATEGY:Input Validation:DESCRIPTION:Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright. When validating filenames, use stringent allowlists that limit the character set to be used. If feasible, only allow a single . character in the filename to avoid weaknesses such as CWE-23, and exclude directory separators such as / to avoid CWE-36. Use a list of allowable file extensions, which will help to avoid CWE-434. Do not rely exclusively on a filtering mechanism that removes potentially dangerous characters. This is equivalent to a denylist, which may be incomplete (CWE-184). For example, filtering / is insufficient protection if the filesystem also supports the use of as a directory separator. Another possible error could occur when the filtering is applied in a way that still produces dangerous data (CWE-182). For example, if ../ sequences are removed from the .../...// string in a sequential fashion, two instances of ../ would be removed from the original string, but the remaining characters would still form the ../ string.:EFFECTIVENESS:High::PHASE:Architecture and Design Operation:STRATEGY:Attack Surface Reduction:DESCRIPTION:Store library, include, and utility files outside of the web document root, if possible. Otherwise, store them in a separate directory and use the web server's access control capabilities to prevent attackers from directly requesting them. One common practice is to define a fixed constant in each calling program, then check for the existence of the constant in the library/include file; if the constant does not exist, then the file was directly requested, and it can exit immediately. This significantly reduces the chance of an attacker being able to bypass any protection mechanisms that are in the base program but not in the include files. It will also reduce the attack surface.::PHASE:Architecture and Design Implementation:STRATEGY:Attack Surface Reduction:DESCRIPTION:Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, filenames, databases, and any external systems that provide data to the application. Remember that such inputs may be obtained indirectly through API calls. Many file inclusion problems occur because the programmer assumed that certain inputs could not be modified, especially for cookies and URL components.::PHASE:Operation:STRATEGY:Firewall:DESCRIPTION:Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.:EFFECTIVENESS:Moderate::","::REFERENCE:CVE-2010-2076:DESCRIPTION:Product does not properly reject DTDs in SOAP messages, which allows remote attackers to read arbitrary files, send HTTP requests to intranet servers, or cause a denial of service.:LINK:https://www.cve.org/CVERecord?id=CVE-2010-2076::REFERENCE:CVE-2004-0285:DESCRIPTION:Modification of assumed-immutable configuration variable in include file allows file inclusion via direct request.:LINK:https://www.cve.org/CVERecord?id=CVE-2004-0285::REFERENCE:CVE-2004-0030:DESCRIPTION:Modification of assumed-immutable configuration variable in include file allows file inclusion via direct request.:LINK:https://www.cve.org/CVERecord?id=CVE-2004-0030::REFERENCE:CVE-2004-0068:DESCRIPTION:Modification of assumed-immutable configuration variable in include file allows file inclusion via direct request.:LINK:https://www.cve.org/CVERecord?id=CVE-2004-0068::REFERENCE:CVE-2005-2157:DESCRIPTION:Modification of assumed-immutable configuration variable in include file allows file inclusion via direct request.:LINK:https://www.cve.org/CVERecord?id=CVE-2005-2157::REFERENCE:CVE-2005-2162:DESCRIPTION:Modification of assumed-immutable configuration variable in include file allows file inclusion via direct request.:LINK:https://www.cve.org/CVERecord?id=CVE-2005-2162::REFERENCE:CVE-2005-2198:DESCRIPTION:Modification of assumed-immutable configuration variable in include file allows file inclusion via direct request.:LINK:https://www.cve.org/CVERecord?id=CVE-2005-2198::REFERENCE:CVE-2004-0128:DESCRIPTION:Modification of assumed-immutable variable in configuration script leads to file inclusion.:LINK:https://www.cve.org/CVERecord?id=CVE-2004-0128::REFERENCE:CVE-2005-1864:DESCRIPTION:PHP file inclusion.:LINK:https://www.cve.org/CVERecord?id=CVE-2005-1864::REFERENCE:CVE-2005-1869:DESCRIPTION:PHP file inclusion.:LINK:https://www.cve.org/CVERecord?id=CVE-2005-1869::REFERENCE:CVE-2005-1870:DESCRIPTION:PHP file inclusion.:LINK:https://www.cve.org/CVERecord?id=CVE-2005-1870::REFERENCE:CVE-2005-2154:DESCRIPTION:PHP local file inclusion.:LINK:https://www.cve.org/CVERecord?id=CVE-2005-2154::REFERENCE:CVE-2002-1704:DESCRIPTION:PHP remote file include.:LINK:https://www.cve.org/CVERecord?id=CVE-2002-1704::REFERENCE:CVE-2002-1707:DESCRIPTION:PHP remote file include.:LINK:https://www.cve.org/CVERecord?id=CVE-2002-1707::REFERENCE:CVE-2005-1964:DESCRIPTION:PHP remote file include.:LINK:https://www.cve.org/CVERecord?id=CVE-2005-1964::REFERENCE:CVE-2005-1681:DESCRIPTION:PHP remote file include.:LINK:https://www.cve.org/CVERecord?id=CVE-2005-1681::REFERENCE:CVE-2005-2086:DESCRIPTION:PHP remote file include.:LINK:https://www.cve.org/CVERecord?id=CVE-2005-2086::REFERENCE:CVE-2004-0127:DESCRIPTION:Directory traversal vulnerability in PHP include statement.:LINK:https://www.cve.org/CVERecord?id=CVE-2004-0127::REFERENCE:CVE-2005-1971:DESCRIPTION:Directory traversal vulnerability in PHP include statement.:LINK:https://www.cve.org/CVERecord?id=CVE-2005-1971::REFERENCE:CVE-2005-3335:DESCRIPTION:PHP file inclusion issue, both remote and local; local include uses .. and %00 characters as a manipulation, but many remote file inclusion issues probably have this vector.:LINK:https://www.cve.org/CVERecord?id=CVE-2005-3335::",,,,::175::201::228::251::252::253::263::538::549::640::660::695::698::,
831,Signal Handler Function Associated with Multiple Signals,Base,Incomplete,The product defines a function that is used as a handler for more than one signal.,"While sometimes intentional and safe, when the same function is used to handle multiple signals, a race condition could occur if the function uses any state outside of its local declaration, such as global variables or non-reentrant functions, or has any side effects. An attacker could send one signal that invokes the handler function; in many OSes, this will typically prevent the same signal from invoking the handler again, at least until the handler function has completed execution. However, the attacker could then send a different signal that is associated with the same handler function. This could interrupt the original handler function while it is still executing. If there is shared state, then the state could be corrupted. This can lead to a variety of potential consequences depending on context, including denial of service and code execution. Another rarely-explored possibility arises when the signal handler is only designed to be executed once (if at all). By sending multiple signals, an attacker could invoke the function more than once. This may generate extra, unintended side effects. A race condition might not even be necessary; the attacker could send one signal, wait until it is handled, then send the other signal.",::NATURE:ChildOf:CWE ID:364:VIEW ID:1000:ORDINAL:Primary::,,,,,,,,"::SCOPE:Availability:SCOPE:Integrity:SCOPE:Confidentiality:SCOPE:Access Control:SCOPE:Other:IMPACT:DoS: Crash, Exit, or Restart:IMPACT:Execute Unauthorized Code or Commands:IMPACT:Read Application Data:IMPACT:Gain Privileges or Assume Identity:IMPACT:Bypass Protection Mechanism:IMPACT:Varies by Context:NOTE:The most common consequence will be a corruption of the state of the product, possibly leading to a crash or exit. However, if the signal handler is operating on state variables for security relevant libraries or protection mechanisms, the consequences can be far more severe, including protection mechanism bypass, privilege escalation, or information exposure.::",,,,,,,,
832,Unlock of a Resource that is not Locked,Base,Incomplete,The product attempts to unlock a resource that is not locked.,"Depending on the locking functionality, an unlock of a non-locked resource might cause memory corruption or other modification to the resource (or its associated metadata that is used for tracking locks).",::NATURE:ChildOf:CWE ID:667:VIEW ID:1000:ORDINAL:Primary::,,,,,,,,"::SCOPE:Integrity:SCOPE:Confidentiality:SCOPE:Availability:SCOPE:Other:IMPACT:DoS: Crash, Exit, or Restart:IMPACT:Execute Unauthorized Code or Commands:IMPACT:Modify Memory:IMPACT:Other:NOTE:Depending on the locking being used, an unlock operation might not have any adverse effects. When effects exist, the most common consequence will be a corruption of the state of the product, possibly leading to a crash or exit; depending on the implementation of the unlocking, memory corruption or code execution could occur.::",,,"::REFERENCE:CVE-2010-4210:DESCRIPTION:function in OS kernel unlocks a mutex that was not previously locked, causing a panic or overwrite of arbitrary memory.:LINK:https://www.cve.org/CVERecord?id=CVE-2010-4210::REFERENCE:CVE-2008-4302:DESCRIPTION:Chain: OS kernel does not properly handle a failure of a function call (CWE-755), leading to an unlock of a resource that was not locked (CWE-832), with resultant crash.:LINK:https://www.cve.org/CVERecord?id=CVE-2008-4302::REFERENCE:CVE-2009-1243:DESCRIPTION:OS kernel performs an unlock in some incorrect circumstances, leading to panic.:LINK:https://www.cve.org/CVERecord?id=CVE-2009-1243::",,,,,
833,Deadlock,Base,Incomplete,"The product contains multiple threads or executable segments that are waiting for each other to release a necessary lock, resulting in deadlock.",,::NATURE:ChildOf:CWE ID:667:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:662:VIEW ID:1305:ORDINAL:Primary::,,,,,,,,"::SCOPE:Availability:IMPACT:DoS: Resource Consumption (CPU):IMPACT:DoS: Resource Consumption (Other):IMPACT:DoS: Crash, Exit, or Restart:NOTE:Each thread of execution will hang and prevent tasks from completing. In some cases, CPU consumption may occur if a lock check occurs in a tight loop.::",,,"::REFERENCE:CVE-1999-1476:DESCRIPTION:A bug in some Intel Pentium processors allow DoS (hang) via an invalid CMPXCHG8B instruction, causing a deadlock:LINK:https://www.cve.org/CVERecord?id=CVE-1999-1476::REFERENCE:CVE-2009-2857:DESCRIPTION:OS deadlock:LINK:https://www.cve.org/CVERecord?id=CVE-2009-2857::REFERENCE:CVE-2009-1961:DESCRIPTION:OS deadlock involving 3 separate functions:LINK:https://www.cve.org/CVERecord?id=CVE-2009-1961::REFERENCE:CVE-2009-2699:DESCRIPTION:deadlock in library:LINK:https://www.cve.org/CVERecord?id=CVE-2009-2699::REFERENCE:CVE-2009-4272:DESCRIPTION:deadlock triggered by packets that force collisions in a routing table:LINK:https://www.cve.org/CVERecord?id=CVE-2009-4272::REFERENCE:CVE-2002-1850:DESCRIPTION:read/write deadlock between web server and script:LINK:https://www.cve.org/CVERecord?id=CVE-2002-1850::REFERENCE:CVE-2004-0174:DESCRIPTION:web server deadlock involving multiple listening connections:LINK:https://www.cve.org/CVERecord?id=CVE-2004-0174::REFERENCE:CVE-2009-1388:DESCRIPTION:multiple simultaneous calls to the same function trigger deadlock.:LINK:https://www.cve.org/CVERecord?id=CVE-2009-1388::REFERENCE:CVE-2006-5158:DESCRIPTION:chain: other weakness leads to NULL pointer dereference (CWE-476) or deadlock (CWE-833).:LINK:https://www.cve.org/CVERecord?id=CVE-2006-5158::REFERENCE:CVE-2006-4342:DESCRIPTION:deadlock when an operation is performed on a resource while it is being removed.:LINK:https://www.cve.org/CVERecord?id=CVE-2006-4342::REFERENCE:CVE-2006-2374:DESCRIPTION:Deadlock in device driver triggered by using file handle of a related device.:LINK:https://www.cve.org/CVERecord?id=CVE-2006-2374::REFERENCE:CVE-2006-2275:DESCRIPTION:Deadlock when large number of small messages cannot be processed quickly enough.:LINK:https://www.cve.org/CVERecord?id=CVE-2006-2275::REFERENCE:CVE-2005-3847:DESCRIPTION:OS kernel has deadlock triggered by a signal during a core dump.:LINK:https://www.cve.org/CVERecord?id=CVE-2005-3847::REFERENCE:CVE-2005-3106:DESCRIPTION:Race condition leads to deadlock.:LINK:https://www.cve.org/CVERecord?id=CVE-2005-3106::REFERENCE:CVE-2005-2456:DESCRIPTION:Chain: array index error (CWE-129) leads to deadlock (CWE-833):LINK:https://www.cve.org/CVERecord?id=CVE-2005-2456::",,,::TAXONOMY NAME:The CERT Oracle Secure Coding Standard for Java (2011):ENTRY ID:LCK08-J:ENTRY NAME:Ensure actively held locks are released on exceptional conditions::,::25::,
835,Loop with Unreachable Exit Condition ('Infinite Loop'),Base,Incomplete,"The product contains an iteration or loop with an exit condition that cannot be reached, i.e., an infinite loop.","If the loop can be influenced by an attacker, this weakness could allow attackers to consume excessive resources such as CPU or memory.",::NATURE:ChildOf:CWE ID:834:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:834:VIEW ID:1003:ORDINAL:Primary::,,::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::,,,,,,"::SCOPE:Availability:IMPACT:DoS: Resource Consumption (CPU):IMPACT:DoS: Resource Consumption (Memory):IMPACT:DoS: Amplification:NOTE:An infinite loop will cause unexpected consumption of resources, such as CPU cycles or memory. The software's operation may slow down, or cause a long time to respond.::",,,"::REFERENCE:CVE-2022-25304:DESCRIPTION:A Python machine communication platform did not account for receiving a malformed packet with a null size, causing the receiving function to never update the message buffer and be caught in an infinite loop.:LINK:https://www.cve.org/CVERecord?id=CVE-2022-25304::REFERENCE:CVE-2011-1027:DESCRIPTION:Chain: off-by-one error leads to infinite loop using invalid hex-encoded characters.:LINK:https://www.cve.org/CVERecord?id=CVE-2011-1027::REFERENCE:CVE-2011-1142:DESCRIPTION:Chain: self-referential values in recursive definitions lead to infinite loop.:LINK:https://www.cve.org/CVERecord?id=CVE-2011-1142::REFERENCE:CVE-2011-1002:DESCRIPTION:NULL UDP packet is never cleared from a queue, leading to infinite loop.:LINK:https://www.cve.org/CVERecord?id=CVE-2011-1002::REFERENCE:CVE-2006-6499:DESCRIPTION:Chain: web browser crashes due to infinite loop - bad looping logic [that relies on] floating point math [CWE-1339] to exit the loop [CWE-835]:LINK:https://www.cve.org/CVERecord?id=CVE-2006-6499::REFERENCE:CVE-2010-4476:DESCRIPTION:Floating point conversion routine cycles back and forth between two different values.:LINK:https://www.cve.org/CVERecord?id=CVE-2010-4476::REFERENCE:CVE-2010-4645:DESCRIPTION:Floating point conversion routine cycles back and forth between two different values.:LINK:https://www.cve.org/CVERecord?id=CVE-2010-4645::REFERENCE:CVE-2010-2534:DESCRIPTION:Chain: improperly clearing a pointer in a linked list leads to infinite loop.:LINK:https://www.cve.org/CVERecord?id=CVE-2010-2534::REFERENCE:CVE-2013-1591:DESCRIPTION:Chain: an integer overflow (CWE-190) in the image size calculation causes an infinite loop (CWE-835) which sequentially allocates buffers without limits (CWE-1325) until the stack is full.:LINK:https://www.cve.org/CVERecord?id=CVE-2013-1591::REFERENCE:CVE-2008-3688:DESCRIPTION:Chain: A denial of service may be caused by an uninitialized variable (CWE-457) allowing an infinite loop (CWE-835) resulting from a connection to an unresponsive server.:LINK:https://www.cve.org/CVERecord?id=CVE-2008-3688::",,,::TAXONOMY NAME:OMG ASCSM:ENTRY ID:ASCSM-CWE-835::,,
836,Use of Password Hash Instead of Password for Authentication,Base,Incomplete,"The product records password hashes in a data store, receives a hash of a password from a client, and compares the supplied hash to the hash obtained from the data store.","Some authentication mechanisms rely on the client to generate the hash for a password, possibly to reduce load on the server or avoid sending the password across the network. However, when the client is used to generate the hash, an attacker can bypass the authentication by obtaining a copy of the hash, e.g. by using SQL injection to compromise a database of authentication credentials, or by exploiting an information exposure. The attacker could then use a modified client to replay the stolen hash without having knowledge of the original password. As a result, the server-side comparison against a client-side hash does not provide any more security than the use of passwords without hashing.",::NATURE:ChildOf:CWE ID:1390:VIEW ID:1000:ORDINAL:Primary::NATURE:PeerOf:CWE ID:602:VIEW ID:1000::,,::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::,,,::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::,,,::SCOPE:Access Control:IMPACT:Bypass Protection Mechanism:IMPACT:Gain Privileges or Assume Identity:NOTE:An attacker could bypass the authentication routine without knowing the original password.::,,,::REFERENCE:CVE-2009-1283:DESCRIPTION:Product performs authentication with user-supplied password hashes that can be obtained from a separate SQL injection vulnerability (CVE-2009-1282).:LINK:https://www.cve.org/CVERecord?id=CVE-2009-1283::REFERENCE:CVE-2005-3435:DESCRIPTION:Product allows attackers to bypass authentication by obtaining the password hash for another user and specifying the hash in the pwd argument.:LINK:https://www.cve.org/CVERecord?id=CVE-2005-3435::,,,,::644::652::,
837,"Improper Enforcement of a Single, Unique Action",Base,Incomplete,"The product requires that an actor should only be able to perform an action once, or to have only one unique action, but the product does not enforce or improperly enforces this restriction.","In various applications, a user is only expected to perform a certain action once, such as voting, requesting a refund, or making a purchase. When this restriction is not enforced, sometimes this can have security implications. For example, in a voting application, an attacker could attempt to stuff the ballot box by voting multiple times. If these votes are counted separately, then the attacker could directly affect who wins the vote. This could have significant business impact depending on the purpose of the product.",::NATURE:ChildOf:CWE ID:799:VIEW ID:1000:ORDINAL:Primary::,,::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::,,,,,,"::SCOPE:Other:NOTE:An attacker might be able to gain advantage over other users by performing the action multiple times, or affect the correctness of the product.::",,,"::REFERENCE:CVE-2008-0294:DESCRIPTION:Ticket-booking web application allows a user to lock a seat more than once.:LINK:https://www.cve.org/CVERecord?id=CVE-2008-0294::REFERENCE:CVE-2005-4051:DESCRIPTION:CMS allows people to rate downloads by voting more than once.:LINK:https://www.cve.org/CVERecord?id=CVE-2005-4051::REFERENCE:CVE-2002-216:DESCRIPTION:Polling software allows people to vote more than once by setting a cookie.:LINK:https://www.cve.org/CVERecord?id=CVE-2002-216::REFERENCE:CVE-2003-1433:DESCRIPTION:Chain: lack of validation of a challenge key in a game allows a player to register multiple times and lock other players out of the game.:LINK:https://www.cve.org/CVERecord?id=CVE-2003-1433::REFERENCE:CVE-2002-1018:DESCRIPTION:Library feature allows attackers to check out the same e-book multiple times, preventing other users from accessing copies of the e-book.:LINK:https://www.cve.org/CVERecord?id=CVE-2002-1018::REFERENCE:CVE-2009-2346:DESCRIPTION:Protocol implementation allows remote attackers to cause a denial of service (call-number exhaustion) by initiating many message exchanges.:LINK:https://www.cve.org/CVERecord?id=CVE-2009-2346::",,,,,
838,Inappropriate Encoding for Output Context,Base,Incomplete,"The product uses or specifies an encoding when generating output to a downstream component, but the specified encoding is not the same as the encoding that is expected by the downstream component.","This weakness can cause the downstream component to use a decoding method that produces different data than what the product intended to send. When the wrong encoding is used - even if closely related - the downstream component could decode the data incorrectly. This can have security consequences when the provided boundaries between control and data are inadvertently broken, because the resulting data could introduce control characters or special elements that were not sent by the product. The resulting data could then be used to bypass protection mechanisms such as input validation, and enable injection attacks. While using output encoding is essential for ensuring that communications between components are accurate, the use of the wrong encoding - even if closely related - could cause the downstream component to misinterpret the output. For example, HTML entity encoding is used for elements in the HTML body of a web page. However, a programmer might use entity encoding when generating output for that is used within an attribute of an HTML tag, which could contain functional Javascript that is not affected by the HTML encoding. While web applications have received the most attention for this problem, this weakness could potentially apply to any type of product that uses a communications stream that could support multiple encodings.",::NATURE:ChildOf:CWE ID:116:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:116:VIEW ID:1003:ORDINAL:Primary::,,::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::,,,,,,"::SCOPE:Integrity:SCOPE:Confidentiality:SCOPE:Availability:IMPACT:Modify Application Data:IMPACT:Execute Unauthorized Code or Commands:NOTE:An attacker could modify the structure of the message or data being sent to the downstream component, possibly injecting commands.::",,"::PHASE:Implementation:STRATEGY:Output Encoding:DESCRIPTION:Use context-aware encoding. That is, understand which encoding is being used by the downstream component, and ensure that this encoding is used. If an encoding can be specified, do so, instead of assuming that the default encoding is the same as the default being assumed by the downstream component.::PHASE:Architecture and Design:STRATEGY:Output Encoding:DESCRIPTION:Where possible, use communications protocols or data formats that provide strict boundaries between control and data. If this is not feasible, ensure that the protocols or formats allow the communicating components to explicitly state which encoding/decoding method is being used. Some template frameworks provide built-in support.::PHASE:Architecture and Design:STRATEGY:Libraries or Frameworks:DESCRIPTION:Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. For example, consider using the ESAPI Encoding control [REF-45] or a similar tool, library, or framework. These will help the programmer encode outputs in a manner less prone to error. Note that some template mechanisms provide built-in support for the appropriate encoding.::","::REFERENCE:CVE-2009-2814:DESCRIPTION:Server does not properly handle requests that do not contain UTF-8 data; browser assumes UTF-8, allowing XSS.:LINK:https://www.cve.org/CVERecord?id=CVE-2009-2814::",,,::TAXONOMY NAME:The CERT Oracle Secure Coding Standard for Java (2011):ENTRY ID:IDS13-J:ENTRY NAME:Use compatible encodings on both sides of file or network IO::,::468::,
839,Numeric Range Comparison Without Minimum Check,Base,Incomplete,"The product checks a value to ensure that it is less than or equal to a maximum, but it does not also verify that the value is greater than or equal to the minimum.","Some products use signed integers or floats even when their values are only expected to be positive or 0. An input validation check might assume that the value is positive, and only check for the maximum value. If the value is negative, but the code assumes that the value is positive, this can produce an error. The error may have security consequences if the negative value is used for memory allocation, array access, buffer access, etc. Ultimately, the error could lead to a buffer overflow or other type of memory corruption. The use of a negative number in a positive-only context could have security implications for other types of resources. For example, a shopping cart might check that the user is not requesting more than 10 items, but a request for -3 items could cause the application to calculate a negative price and credit the attacker's account.",::NATURE:ChildOf:CWE ID:1023:VIEW ID:1000:ORDINAL:Primary::NATURE:CanPrecede:CWE ID:195:VIEW ID:1000::NATURE:CanPrecede:CWE ID:682:VIEW ID:1000::NATURE:CanPrecede:CWE ID:119:VIEW ID:1000::NATURE:CanPrecede:CWE ID:124:VIEW ID:1000::,,::LANGUAGE NAME:C:LANGUAGE PREVALENCE:Often::LANGUAGE NAME:C++:LANGUAGE PREVALENCE:Often::,,"::TERM:Signed comparison:DESCRIPTION:The signed comparison term is often used to describe when the product uses a signed variable and checks it to ensure that it is less than a maximum value (typically a maximum buffer size), but does not verify that it is greater than 0.::",,,,"::SCOPE:Integrity:SCOPE:Confidentiality:SCOPE:Availability:IMPACT:Modify Application Data:IMPACT:Execute Unauthorized Code or Commands:NOTE:An attacker could modify the structure of the message or data being sent to the downstream component, possibly injecting commands.::SCOPE:Availability:IMPACT:DoS: Resource Consumption (Other):NOTE:in some contexts, a negative value could lead to resource consumption.::SCOPE:Confidentiality:SCOPE:Integrity:IMPACT:Modify Memory:IMPACT:Read Memory:NOTE:If a negative value is used to access memory, buffers, or other indexable structures, it could access memory outside the bounds of the buffer.::",,"::PHASE:Implementation:STRATEGY:Enforcement by Conversion:DESCRIPTION:If the number to be used is always expected to be positive, change the variable type from signed to unsigned or size_t.::PHASE:Implementation:STRATEGY:Input Validation:DESCRIPTION:If the number to be used could have a negative value based on the specification (thus requiring a signed value), but the number should only be positive to preserve code correctness, then include a check to ensure that the value is positive.::","::REFERENCE:CVE-2010-1866:DESCRIPTION:Chain: integer overflow causes a negative signed value, which later bypasses a maximum-only check, leading to heap-based buffer overflow.:LINK:https://www.cve.org/CVERecord?id=CVE-2010-1866::REFERENCE:CVE-2009-1099:DESCRIPTION:Chain: 16-bit counter can be interpreted as a negative value, compared to a 32-bit maximum value, leading to buffer under-write.:LINK:https://www.cve.org/CVERecord?id=CVE-2009-1099::REFERENCE:CVE-2011-0521:DESCRIPTION:Chain: kernel's lack of a check for a negative value leads to memory corruption.:LINK:https://www.cve.org/CVERecord?id=CVE-2011-0521::REFERENCE:CVE-2010-3704:DESCRIPTION:Chain: parser uses atoi() but does not check for a negative value, which can happen on some platforms, leading to buffer under-write.:LINK:https://www.cve.org/CVERecord?id=CVE-2010-3704::REFERENCE:CVE-2010-2530:DESCRIPTION:Chain: Negative value stored in an int bypasses a size check and causes allocation of large amounts of memory.:LINK:https://www.cve.org/CVERecord?id=CVE-2010-2530::REFERENCE:CVE-2009-3080:DESCRIPTION:Chain: negative offset value to IOCTL bypasses check for maximum index, then used as an array index for buffer under-read.:LINK:https://www.cve.org/CVERecord?id=CVE-2009-3080::REFERENCE:CVE-2008-6393:DESCRIPTION:chain: file transfer client performs signed comparison, leading to integer overflow and heap-based buffer overflow.:LINK:https://www.cve.org/CVERecord?id=CVE-2008-6393::REFERENCE:CVE-2008-4558:DESCRIPTION:chain: negative ID in media player bypasses check for maximum index, then used as an array index for buffer under-read.:LINK:https://www.cve.org/CVERecord?id=CVE-2008-4558::",,,,,
841,Improper Enforcement of Behavioral Workflow,Base,Incomplete,"The product supports a session in which more than one behavior must be performed by an actor, but it does not properly ensure that the actor performs the behaviors in the required sequence.","By performing actions in an unexpected order, or by omitting steps, an attacker could manipulate the business logic of the product or cause it to enter an invalid state. In some cases, this can also expose resultant weaknesses. For example, a file-sharing protocol might require that an actor perform separate steps to provide a username, then a password, before being able to transfer files. If the file-sharing server accepts a password command followed by a transfer command, without any username being provided, the product might still perform the transfer. Note that this is different than CWE-696, which focuses on when the product performs actions in the wrong sequence; this entry is closely related, but it is focused on ensuring that the actor performs actions in the correct sequence. Workflow-related behaviors include: Steps are performed in the expected order. Required steps are not omitted. Steps are not interrupted. Steps are performed in a timely fashion.",::NATURE:ChildOf:CWE ID:691:VIEW ID:1000:ORDINAL:Primary::,,,,,::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::,,,"::SCOPE:Other:IMPACT:Alter Execution Logic:NOTE:An attacker could cause the product to skip critical steps or perform them in the wrong order, bypassing its intended business logic. This can sometimes have security implications.::",,,"::REFERENCE:CVE-2011-0348:DESCRIPTION:Bypass of access/billing restrictions by sending traffic to an unrestricted destination before sending to a restricted destination.:LINK:https://www.cve.org/CVERecord?id=CVE-2011-0348::REFERENCE:CVE-2007-3012:DESCRIPTION:Attacker can access portions of a restricted page by canceling out of a dialog.:LINK:https://www.cve.org/CVERecord?id=CVE-2007-3012::REFERENCE:CVE-2009-5056:DESCRIPTION:Ticket-tracking system does not enforce a permission setting.:LINK:https://www.cve.org/CVERecord?id=CVE-2009-5056::REFERENCE:CVE-2004-2164:DESCRIPTION:Shopping cart does not close a database connection when user restores a previous order, leading to connection exhaustion.:LINK:https://www.cve.org/CVERecord?id=CVE-2004-2164::REFERENCE:CVE-2003-0777:DESCRIPTION:Chain: product does not properly handle dropped connections, leading to missing NULL terminator (CWE-170) and segmentation fault.:LINK:https://www.cve.org/CVERecord?id=CVE-2003-0777::REFERENCE:CVE-2005-3327:DESCRIPTION:Chain: Authentication bypass by skipping the first startup step as required by the protocol.:LINK:https://www.cve.org/CVERecord?id=CVE-2005-3327::REFERENCE:CVE-2004-0829:DESCRIPTION:Chain: File server crashes when sent a find next request without an initial find first.:LINK:https://www.cve.org/CVERecord?id=CVE-2004-0829::REFERENCE:CVE-2010-2620:DESCRIPTION:FTP server allows remote attackers to bypass authentication by sending (1) LIST, (2) RETR, (3) STOR, or other commands without performing the required login steps first.:LINK:https://www.cve.org/CVERecord?id=CVE-2010-2620::REFERENCE:CVE-2005-3296:DESCRIPTION:FTP server allows remote attackers to list arbitrary directories as root by running the LIST command before logging in.:LINK:https://www.cve.org/CVERecord?id=CVE-2005-3296::",,,::TAXONOMY NAME:WASC:ENTRY ID:40:ENTRY NAME:Insufficient Process Validation::,,"::TYPE:Research Gap:NOTE:This weakness is typically associated with business logic flaws, except when it produces resultant weaknesses. The classification of business logic flaws has been under-studied, although exploitation of business flaws frequently happens in real-world systems, and many applied vulnerability researchers investigate them. The greatest focus is in web applications. There is debate within the community about whether these problems represent particularly new concepts, or if they are variations of well-known principles. Many business logic flaws appear to be oriented toward business processes, application flows, and sequences of behaviors, which are not as well-represented in CWE as weaknesses related to input validation, memory management, etc.::"
842,Placement of User into Incorrect Group,Base,Incomplete,The product or the administrator places a user into an incorrect group.,"If the incorrect group has more access or privileges than the intended group, the user might be able to bypass intended security policy to access unexpected resources or perform unexpected actions. The access-control system might not be able to detect malicious usage of this group membership.",::NATURE:ChildOf:CWE ID:286:VIEW ID:1000:ORDINAL:Primary::,,::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::,,,::PHASE:Implementation::PHASE:Operation::,,,::SCOPE:Access Control:IMPACT:Gain Privileges or Assume Identity::,,,"::REFERENCE:CVE-1999-1193:DESCRIPTION:Operating system assigns user to privileged wheel group, allowing the user to gain root privileges.:LINK:https://www.cve.org/CVERecord?id=CVE-1999-1193::REFERENCE:CVE-2010-3716:DESCRIPTION:Chain: drafted web request allows the creation of users with arbitrary group membership.:LINK:https://www.cve.org/CVERecord?id=CVE-2010-3716::REFERENCE:CVE-2008-5397:DESCRIPTION:Chain: improper processing of configuration options causes users to contain unintended group memberships.:LINK:https://www.cve.org/CVERecord?id=CVE-2008-5397::REFERENCE:CVE-2007-6644:DESCRIPTION:CMS does not prevent remote administrators from promoting other users to the administrator group, in violation of the intended security model.:LINK:https://www.cve.org/CVERecord?id=CVE-2007-6644::REFERENCE:CVE-2007-3260:DESCRIPTION:Product assigns members to the root group, allowing escalation of privileges.:LINK:https://www.cve.org/CVERecord?id=CVE-2007-3260::REFERENCE:CVE-2002-0080:DESCRIPTION:Chain: daemon does not properly clear groups before dropping privileges.:LINK:https://www.cve.org/CVERecord?id=CVE-2002-0080::",,,,,
843,Access of Resource Using Incompatible Type ('Type Confusion'),Base,Incomplete,"The product allocates or initializes a resource such as a pointer, object, or variable using one type, but it later accesses that resource using a type that is incompatible with the original type.","When the product accesses the resource using an incompatible type, this could trigger logical errors because the resource does not have expected properties. In languages without memory safety, such as C and C++, type confusion can lead to out-of-bounds memory access. While this weakness is frequently associated with unions when parsing data with many different embedded object types in C, it can be present in any application that can interpret the same variable or memory location in multiple ways. This weakness is not unique to C and C++. For example, errors in PHP applications can be triggered by providing array parameters when scalars are expected, or vice versa. Languages such as Perl, which perform automatic conversion of a variable of one type when it is accessed as if it were another type, can also contain these issues.",::NATURE:ChildOf:CWE ID:704:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:704:VIEW ID:1003:ORDINAL:Primary::NATURE:CanPrecede:CWE ID:119:VIEW ID:1000::,,::LANGUAGE NAME:C:LANGUAGE PREVALENCE:Undetermined::LANGUAGE NAME:C++:LANGUAGE PREVALENCE:Undetermined::,,::TERM:Object Type Confusion::,::PHASE:Implementation::,,,"::SCOPE:Availability:SCOPE:Integrity:SCOPE:Confidentiality:IMPACT:Read Memory:IMPACT:Modify Memory:IMPACT:Execute Unauthorized Code or Commands:IMPACT:DoS: Crash, Exit, or Restart:NOTE:When a memory buffer is accessed using the wrong type, it could read or write memory out of the bounds of the buffer, if the allocated buffer is smaller than the type that the code is attempting to access, leading to a crash and possibly code execution.::",,,"::REFERENCE:CVE-2010-4577:DESCRIPTION:Type confusion in CSS sequence leads to out-of-bounds read.:LINK:https://www.cve.org/CVERecord?id=CVE-2010-4577::REFERENCE:CVE-2011-0611:DESCRIPTION:Size inconsistency allows code execution, first discovered when it was actively exploited in-the-wild.:LINK:https://www.cve.org/CVERecord?id=CVE-2011-0611::REFERENCE:CVE-2010-0258:DESCRIPTION:Improperly-parsed file containing records of different types leads to code execution when a memory location is interpreted as a different object than intended.:LINK:https://www.cve.org/CVERecord?id=CVE-2010-0258::",,,::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:EXP39-C:ENTRY NAME:Do not access a variable through a pointer of an incompatible type:MAPPING FIT:Exact::,,"::TYPE:Applicable Platform:NOTE:This weakness is possible in any type-unsafe programming language.::TYPE:Research Gap:NOTE:Type confusion weaknesses have received some attention by applied researchers and major software vendors for C and C++ code. Some publicly-reported vulnerabilities probably have type confusion as a root-cause weakness, but these may be described as memory corruption instead. For other languages, there are very few public reports of type confusion weaknesses. These are probably under-studied. Since many programs rely directly or indirectly on loose typing, a potential type confusion behavior might be intentional, possibly requiring more manual analysis.::"
908,Use of Uninitialized Resource,Base,Incomplete,The product uses or accesses a resource that has not been initialized.,"When a resource has not been properly initialized, the product may behave unexpectedly. This may lead to a crash or invalid memory access, but the consequences vary depending on the type of resource and how it is used within the product.",::NATURE:ChildOf:CWE ID:665:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:665:VIEW ID:1003:ORDINAL:Primary::,::ORDINALITY:Primary::ORDINALITY:Resultant::,::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::,,,::PHASE:Implementation::,,,"::SCOPE:Confidentiality:IMPACT:Read Memory:IMPACT:Read Application Data:NOTE:When reusing a resource such as memory or a program variable, the original contents of that resource may not be cleared before it is sent to an untrusted party.::SCOPE:Availability:IMPACT:DoS: Crash, Exit, or Restart:NOTE:The uninitialized resource may contain values that cause program flow to change in ways that the programmer did not intend.::",,"::PHASE:Implementation:DESCRIPTION:Explicitly initialize the resource before use. If this is performed through an API function or standard procedure, follow all required steps.::PHASE:Implementation:DESCRIPTION:Pay close attention to complex conditionals that affect initialization, since some branches might not perform the initialization.::PHASE:Implementation:DESCRIPTION:Avoid race conditions (CWE-362) during initialization routines.::PHASE:Build and Compilation:DESCRIPTION:Run or compile the product with settings that generate warnings about uninitialized variables or data.::","::REFERENCE:CVE-2019-9805:DESCRIPTION:Chain: Creation of the packet client occurs before initialization is complete (CWE-696) resulting in a read from uninitialized memory (CWE-908), causing memory corruption.:LINK:https://www.cve.org/CVERecord?id=CVE-2019-9805::REFERENCE:CVE-2008-4197:DESCRIPTION:Use of uninitialized memory may allow code execution.:LINK:https://www.cve.org/CVERecord?id=CVE-2008-4197::REFERENCE:CVE-2008-2934:DESCRIPTION:Free of an uninitialized pointer leads to crash and possible code execution.:LINK:https://www.cve.org/CVERecord?id=CVE-2008-2934::REFERENCE:CVE-2008-0063:DESCRIPTION:Product does not clear memory contents when generating an error message, leading to information leak.:LINK:https://www.cve.org/CVERecord?id=CVE-2008-0063::REFERENCE:CVE-2008-0062:DESCRIPTION:Lack of initialization triggers NULL pointer dereference or double-free.:LINK:https://www.cve.org/CVERecord?id=CVE-2008-0062::REFERENCE:CVE-2008-0081:DESCRIPTION:Uninitialized variable leads to code execution in popular desktop application.:LINK:https://www.cve.org/CVERecord?id=CVE-2008-0081::REFERENCE:CVE-2008-3688:DESCRIPTION:Chain: Uninitialized variable leads to infinite loop.:LINK:https://www.cve.org/CVERecord?id=CVE-2008-3688::REFERENCE:CVE-2008-3475:DESCRIPTION:Chain: Improper initialization leads to memory corruption.:LINK:https://www.cve.org/CVERecord?id=CVE-2008-3475::REFERENCE:CVE-2005-1036:DESCRIPTION:Chain: Bypass of access restrictions due to improper authorization (CWE-862) of a user results from an improperly initialized (CWE-909) I/O permission bitmap:LINK:https://www.cve.org/CVERecord?id=CVE-2005-1036::REFERENCE:CVE-2008-3597:DESCRIPTION:Chain: game server can access player data structures before initialization has happened leading to NULL dereference:LINK:https://www.cve.org/CVERecord?id=CVE-2008-3597::REFERENCE:CVE-2009-2692:DESCRIPTION:Chain: uninitialized function pointers can be dereferenced allowing code execution:LINK:https://www.cve.org/CVERecord?id=CVE-2009-2692::REFERENCE:CVE-2009-0949:DESCRIPTION:Chain: improper initialization of memory can lead to NULL dereference:LINK:https://www.cve.org/CVERecord?id=CVE-2009-0949::REFERENCE:CVE-2009-3620:DESCRIPTION:Chain: some unprivileged ioctls do not verify that a structure has been initialized before invocation, leading to NULL dereference:LINK:https://www.cve.org/CVERecord?id=CVE-2009-3620::",,,::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:EXP33-C:ENTRY NAME:Do not read uninitialized memory:MAPPING FIT:CWE More Abstract::,,
909,Missing Initialization of Resource,Base,Incomplete,The product does not initialize a critical resource.,"Many resources require initialization before they can be properly used. If a resource is not initialized, it could contain unpredictable or expired data, or it could be initialized to defaults that are invalid. This can have security implications when the resource is expected to have certain properties or values.",::NATURE:ChildOf:CWE ID:665:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:665:VIEW ID:1003:ORDINAL:Primary::NATURE:CanPrecede:CWE ID:908:VIEW ID:1000::,::ORDINALITY:Primary::ORDINALITY:Resultant::,::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::,,,::PHASE:Implementation::,,,"::SCOPE:Confidentiality:IMPACT:Read Memory:IMPACT:Read Application Data:NOTE:When reusing a resource such as memory or a program variable, the original contents of that resource may not be cleared before it is sent to an untrusted party.::SCOPE:Availability:IMPACT:DoS: Crash, Exit, or Restart:NOTE:The uninitialized resource may contain values that cause program flow to change in ways that the programmer did not intend.::",,"::PHASE:Implementation:DESCRIPTION:Explicitly initialize the resource before use. If this is performed through an API function or standard procedure, follow all specified steps.::PHASE:Implementation:DESCRIPTION:Pay close attention to complex conditionals that affect initialization, since some branches might not perform the initialization.::PHASE:Implementation:DESCRIPTION:Avoid race conditions (CWE-362) during initialization routines.::PHASE:Build and Compilation:DESCRIPTION:Run or compile your product with settings that generate warnings about uninitialized variables or data.::","::REFERENCE:CVE-2020-20739:DESCRIPTION:A variable that has its value set in a conditional statement is sometimes used when the conditional fails, sometimes causing data leakage:LINK:https://www.cve.org/CVERecord?id=CVE-2020-20739::REFERENCE:CVE-2005-1036:DESCRIPTION:Chain: Bypass of access restrictions due to improper authorization (CWE-862) of a user results from an improperly initialized (CWE-909) I/O permission bitmap:LINK:https://www.cve.org/CVERecord?id=CVE-2005-1036::",,,,,
910,Use of Expired File Descriptor,Base,Incomplete,The product uses or accesses a file descriptor after it has been closed.,"After a file descriptor for a particular file or device has been released, it can be reused. The code might not write to the original file, since the reused file descriptor might reference a different file or device.",::NATURE:ChildOf:CWE ID:672:VIEW ID:1000:ORDINAL:Primary::,::ORDINALITY:Primary::ORDINALITY:Resultant::,::LANGUAGE NAME:C:LANGUAGE PREVALENCE:Sometimes::LANGUAGE NAME:C++:LANGUAGE PREVALENCE:Sometimes::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::,,::TERM:Stale file descriptor::,::PHASE:Implementation::,,,"::SCOPE:Confidentiality:IMPACT:Read Files or Directories:NOTE:The program could read data from the wrong file.::SCOPE:Availability:IMPACT:DoS: Crash, Exit, or Restart:NOTE:Accessing a file descriptor that has been closed can cause a crash.::",,,,,,::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:FIO46-C:ENTRY NAME:Do not access a closed file:MAPPING FIT:Exact::,,
911,Improper Update of Reference Count,Base,Incomplete,"The product uses a reference count to manage a resource, but it does not update or incorrectly updates the reference count.","Reference counts can be used when tracking how many objects contain a reference to a particular resource, such as in memory management or garbage collection. When the reference count reaches zero, the resource can be de-allocated or reused because there are no more objects that use it. If the reference count accidentally reaches zero, then the resource might be released too soon, even though it is still in use. If all objects no longer use the resource, but the reference count is not zero, then the resource might not ever be released.",::NATURE:ChildOf:CWE ID:664:VIEW ID:1000:ORDINAL:Primary::NATURE:CanPrecede:CWE ID:672:VIEW ID:1000::NATURE:CanPrecede:CWE ID:772:VIEW ID:1000::,::ORDINALITY:Primary::,::LANGUAGE NAME:C:LANGUAGE PREVALENCE:Sometimes::LANGUAGE NAME:C++:LANGUAGE PREVALENCE:Sometimes::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::,,,::PHASE:Implementation::,,,,,,"::REFERENCE:CVE-2002-0574:DESCRIPTION:chain: reference count is not decremented, leading to memory leak in OS by sending ICMP packets.:LINK:https://www.cve.org/CVERecord?id=CVE-2002-0574::REFERENCE:CVE-2004-0114:DESCRIPTION:Reference count for shared memory not decremented when a function fails, potentially allowing unprivileged users to read kernel memory.:LINK:https://www.cve.org/CVERecord?id=CVE-2004-0114::REFERENCE:CVE-2006-3741:DESCRIPTION:chain: improper reference count tracking leads to file descriptor consumption:LINK:https://www.cve.org/CVERecord?id=CVE-2006-3741::REFERENCE:CVE-2007-1383:DESCRIPTION:chain: integer overflow in reference counter causes the same variable to be destroyed twice.:LINK:https://www.cve.org/CVERecord?id=CVE-2007-1383::REFERENCE:CVE-2007-1700:DESCRIPTION:Incorrect reference count calculation leads to improper object destruction and code execution.:LINK:https://www.cve.org/CVERecord?id=CVE-2007-1700::REFERENCE:CVE-2008-2136:DESCRIPTION:chain: incorrect update of reference count leads to memory leak.:LINK:https://www.cve.org/CVERecord?id=CVE-2008-2136::REFERENCE:CVE-2008-2785:DESCRIPTION:chain/composite: use of incorrect data type for a reference counter allows an overflow of the counter, leading to a free of memory that is still in use.:LINK:https://www.cve.org/CVERecord?id=CVE-2008-2785::REFERENCE:CVE-2008-5410:DESCRIPTION:Improper reference counting leads to failure of cryptographic operations.:LINK:https://www.cve.org/CVERecord?id=CVE-2008-5410::REFERENCE:CVE-2009-1709:DESCRIPTION:chain: improper reference counting in a garbage collection routine leads to use-after-free:LINK:https://www.cve.org/CVERecord?id=CVE-2009-1709::REFERENCE:CVE-2009-3553:DESCRIPTION:chain: reference count not correctly maintained when client disconnects during a large operation, leading to a use-after-free.:LINK:https://www.cve.org/CVERecord?id=CVE-2009-3553::REFERENCE:CVE-2009-3624:DESCRIPTION:Reference count not always incremented, leading to crash or code execution.:LINK:https://www.cve.org/CVERecord?id=CVE-2009-3624::REFERENCE:CVE-2010-0176:DESCRIPTION:improper reference counting leads to expired pointer dereference.:LINK:https://www.cve.org/CVERecord?id=CVE-2010-0176::REFERENCE:CVE-2010-0623:DESCRIPTION:OS kernel increments reference count twice but only decrements once, leading to resource consumption and crash.:LINK:https://www.cve.org/CVERecord?id=CVE-2010-0623::REFERENCE:CVE-2010-2549:DESCRIPTION:OS kernel driver allows code execution:LINK:https://www.cve.org/CVERecord?id=CVE-2010-2549::REFERENCE:CVE-2010-4593:DESCRIPTION:improper reference counting leads to exhaustion of IP addresses:LINK:https://www.cve.org/CVERecord?id=CVE-2010-4593::REFERENCE:CVE-2011-0695:DESCRIPTION:Race condition causes reference counter to be decremented prematurely, leading to the destruction of still-active object and an invalid pointer dereference.:LINK:https://www.cve.org/CVERecord?id=CVE-2011-0695::REFERENCE:CVE-2012-4787:DESCRIPTION:improper reference counting leads to use-after-free:LINK:https://www.cve.org/CVERecord?id=CVE-2012-4787::",,,,,
914,Improper Control of Dynamically-Identified Variables,Base,Incomplete,The product does not properly restrict reading from or writing to dynamically-identified variables.,"Many languages offer powerful features that allow the programmer to access arbitrary variables that are specified by an input string. While these features can offer significant flexibility and reduce development time, they can be extremely dangerous if attackers can modify unintended variables that have security implications.",::NATURE:ChildOf:CWE ID:99:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:913:VIEW ID:1000::,::ORDINALITY:Primary::,,,,::PHASE:Architecture and Design::PHASE:Implementation::,,,::SCOPE:Integrity:IMPACT:Modify Application Data:NOTE:An attacker could modify sensitive data or program variables.::SCOPE:Integrity:IMPACT:Execute Unauthorized Code or Commands::SCOPE:Other:SCOPE:Integrity:IMPACT:Varies by Context:IMPACT:Alter Execution Logic::,,"::PHASE:Implementation:STRATEGY:Input Validation:DESCRIPTION:For any externally-influenced input, check the input against an allowlist of internal program variables that are allowed to be modified.::PHASE:Implementation Architecture and Design:STRATEGY:Refactoring:DESCRIPTION:Refactor the code so that internal program variables do not need to be dynamically identified.::","::REFERENCE:CVE-2006-7135:DESCRIPTION:extract issue enables file inclusion:LINK:https://www.cve.org/CVERecord?id=CVE-2006-7135::REFERENCE:CVE-2006-7079:DESCRIPTION:extract used for register_globals compatibility layer, enables path traversal:LINK:https://www.cve.org/CVERecord?id=CVE-2006-7079::REFERENCE:CVE-2007-0649:DESCRIPTION:extract() buried in include files makes post-disclosure analysis confusing; original report had seemed incorrect.:LINK:https://www.cve.org/CVERecord?id=CVE-2007-0649::REFERENCE:CVE-2006-6661:DESCRIPTION:extract() enables static code injection:LINK:https://www.cve.org/CVERecord?id=CVE-2006-6661::REFERENCE:CVE-2006-2828:DESCRIPTION:import_request_variables() buried in include files makes post-disclosure analysis confusing:LINK:https://www.cve.org/CVERecord?id=CVE-2006-2828::REFERENCE:CVE-2009-0422:DESCRIPTION:Chain: Dynamic variable evaluation allows resultant remote file inclusion and path traversal.:LINK:https://www.cve.org/CVERecord?id=CVE-2009-0422::REFERENCE:CVE-2007-2431:DESCRIPTION:Chain: dynamic variable evaluation in PHP program used to modify critical, unexpected $_SERVER variable for resultant XSS.:LINK:https://www.cve.org/CVERecord?id=CVE-2007-2431::REFERENCE:CVE-2006-4904:DESCRIPTION:Chain: dynamic variable evaluation in PHP program used to conduct remote file inclusion.:LINK:https://www.cve.org/CVERecord?id=CVE-2006-4904::REFERENCE:CVE-2006-4019:DESCRIPTION:Dynamic variable evaluation in mail program allows reading and modifying attachments and preferences of other users.:LINK:https://www.cve.org/CVERecord?id=CVE-2006-4019::",,,,,
915,Improperly Controlled Modification of Dynamically-Determined Object Attributes,Base,Incomplete,"The product receives input from an upstream component that specifies multiple attributes, properties, or fields that are to be initialized or updated in an object, but it does not properly control which attributes can be modified.","If the object contains attributes that were only intended for internal use, then their unexpected modification could lead to a vulnerability. This weakness is sometimes known by the language-specific mechanisms that make it possible, such as mass assignment, autobinding, or object injection.",::NATURE:ChildOf:CWE ID:913:VIEW ID:1000:ORDINAL:Primary::NATURE:PeerOf:CWE ID:502:VIEW ID:1000::,::ORDINALITY:Primary::,::LANGUAGE NAME:Ruby:LANGUAGE PREVALENCE:Undetermined::LANGUAGE NAME:ASP.NET:LANGUAGE PREVALENCE:Undetermined::LANGUAGE NAME:PHP:LANGUAGE PREVALENCE:Undetermined::LANGUAGE NAME:Python:LANGUAGE PREVALENCE:Undetermined::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::,,"::TERM:Mass Assignment:DESCRIPTION:Mass assignment is the name of a feature in Ruby on Rails that allows simultaneous modification of multiple object attributes.::TERM:AutoBinding:DESCRIPTION:The Autobinding term is used in frameworks such as Spring MVC and ASP.NET MVC.::TERM:PHP Object Injection:DESCRIPTION:Some PHP application researchers use this term for attacking unsafe use of the unserialize() function, but it is also used for CWE-502.::",::PHASE:Architecture and Design::PHASE:Implementation::,,,::SCOPE:Integrity:IMPACT:Modify Application Data:NOTE:An attacker could modify sensitive data or program variables.::SCOPE:Integrity:IMPACT:Execute Unauthorized Code or Commands::SCOPE:Other:SCOPE:Integrity:IMPACT:Varies by Context:IMPACT:Alter Execution Logic::,,"::PHASE:Implementation:DESCRIPTION:If available, use features of the language or framework that allow specification of allowlists of attributes or fields that are allowed to be modified. If possible, prefer allowlists over denylists. For applications written with Ruby on Rails, use the attr_accessible (allowlist) or attr_protected (denylist) macros in each class that may be used in mass assignment.::PHASE:Architecture and Design Implementation:DESCRIPTION:If available, use the signing/sealing features of the programming language to assure that deserialized data has not been tainted. For example, a hash-based message authentication code (HMAC) could be used to ensure that data has not been modified.::PHASE:Implementation:STRATEGY:Input Validation:DESCRIPTION:For any externally-influenced input, check the input against an allowlist of internal object attributes or fields that are allowed to be modified.::PHASE:Implementation Architecture and Design:STRATEGY:Refactoring:DESCRIPTION:Refactor the code so that object attributes or fields do not need to be dynamically identified, and only expose getter/setter functionality for the intended attributes.::","::REFERENCE:CVE-2012-2054:DESCRIPTION:Mass assignment allows modification of arbitrary attributes using modified URL.:LINK:https://www.cve.org/CVERecord?id=CVE-2012-2054::REFERENCE:CVE-2012-2055:DESCRIPTION:Source version control product allows modification of trusted key using mass assignment.:LINK:https://www.cve.org/CVERecord?id=CVE-2012-2055::REFERENCE:CVE-2008-7310:DESCRIPTION:Attackers can bypass payment step in e-commerce product.:LINK:https://www.cve.org/CVERecord?id=CVE-2008-7310::REFERENCE:CVE-2013-1465:DESCRIPTION:Use of PHP unserialize function on untrusted input allows attacker to modify application configuration.:LINK:https://www.cve.org/CVERecord?id=CVE-2013-1465::REFERENCE:CVE-2012-3527:DESCRIPTION:Use of PHP unserialize function on untrusted input in content management system might allow code execution.:LINK:https://www.cve.org/CVERecord?id=CVE-2012-3527::REFERENCE:CVE-2012-0911:DESCRIPTION:Use of PHP unserialize function on untrusted input in content management system allows code execution using a crafted cookie value.:LINK:https://www.cve.org/CVERecord?id=CVE-2012-0911::REFERENCE:CVE-2012-0911:DESCRIPTION:Content management system written in PHP allows unserialize of arbitrary objects, possibly allowing code execution.:LINK:https://www.cve.org/CVERecord?id=CVE-2012-0911::REFERENCE:CVE-2011-4962:DESCRIPTION:Content management system written in PHP allows code execution through page comments.:LINK:https://www.cve.org/CVERecord?id=CVE-2011-4962::REFERENCE:CVE-2009-4137:DESCRIPTION:Use of PHP unserialize function on cookie value allows remote code execution or upload of arbitrary files.:LINK:https://www.cve.org/CVERecord?id=CVE-2009-4137::REFERENCE:CVE-2007-5741:DESCRIPTION:Content management system written in Python interprets untrusted data as pickles, allowing code execution.:LINK:https://www.cve.org/CVERecord?id=CVE-2007-5741::REFERENCE:CVE-2011-2520:DESCRIPTION:Python script allows local users to execute code via pickled data.:LINK:https://www.cve.org/CVERecord?id=CVE-2011-2520::REFERENCE:CVE-2005-2875:DESCRIPTION:Python script allows remote attackers to execute arbitrary code using pickled objects.:LINK:https://www.cve.org/CVERecord?id=CVE-2005-2875::REFERENCE:CVE-2013-0277:DESCRIPTION:Ruby on Rails allows deserialization of untrusted YAML to execute arbitrary code.:LINK:https://www.cve.org/CVERecord?id=CVE-2013-0277::REFERENCE:CVE-2011-2894:DESCRIPTION:Spring framework allows deserialization of objects from untrusted sources to execute arbitrary code.:LINK:https://www.cve.org/CVERecord?id=CVE-2011-2894::REFERENCE:CVE-2012-1833:DESCRIPTION:Grails allows binding of arbitrary parameters to modify arbitrary object properties.:LINK:https://www.cve.org/CVERecord?id=CVE-2012-1833::REFERENCE:CVE-2010-3258:DESCRIPTION:Incorrect deserialization in web browser allows escaping the sandbox.:LINK:https://www.cve.org/CVERecord?id=CVE-2010-3258::REFERENCE:CVE-2008-1013:DESCRIPTION:Media library allows deserialization of objects by untrusted Java applets, leading to arbitrary code execution.:LINK:https://www.cve.org/CVERecord?id=CVE-2008-1013::",,,,,"::TYPE:Maintenance:NOTE:The relationships between CWE-502 and CWE-915 need further exploration. CWE-915 is more narrowly scoped to object modification, and is not necessarily used for deserialization.::"
