CWE-ID,Name,Weakness Abstraction,Status,Description,Extended Description,Related Weaknesses,Weakness Ordinalities,Applicable Platforms,Background Details,Alternate Terms,Modes Of Introduction,Exploitation Factors,Likelihood of Exploit,Common Consequences,Detection Methods,Potential Mitigations,Observed Examples,Functional Areas,Affected Resources,Taxonomy Mappings,Related Attack Patterns,Notes
203,"Observable Discrepancy",Base,Incomplete,"The product behaves differently or sends different responses under different circumstances in a way that is observable to an unauthorized actor, which exposes security-relevant information about the state of the product, such as whether a particular operation was successful or not.","Discrepancies can take many forms, and variations may be detectable in timing, control flow, communications such as replies or requests, or general behavior. These discrepancies can reveal information about the product's operation or internal state to an unauthorized actor. In some cases, discrepancies can be used by attackers to form a side channel.",::NATURE:ChildOf:CWE ID:200:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:200:VIEW ID:1003:ORDINAL:Primary::,"",::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::TECHNOLOGY CLASS:Not Technology-Specific:TECHNOLOGY PREVALENCE:Undetermined::,"","::TERM:Side Channel Attack:DESCRIPTION:Observable Discrepancies are at the root of side channel attacks.::","::PHASE:Architecture and Design::PHASE:Implementation::","",,"::SCOPE:Confidentiality:SCOPE:Access Control:IMPACT:Read Application Data:IMPACT:Bypass Protection Mechanism:NOTE:An attacker can gain access to sensitive information about the system, including authentication information that may allow an attacker to gain access to the system.::SCOPE:Confidentiality:IMPACT:Read Application Data:NOTE:When cryptographic primitives are vulnerable to side-channel-attacks, this could be used to reveal unencrypted plaintext in the worst case.::","","::PHASE:Architecture and Design:STRATEGY:Separation of Privilege:DESCRIPTION:Compartmentalize the system to have safe areas where trust boundaries can be unambiguously drawn. Do not allow sensitive data to go outside of the trust boundary and always be careful when interfacing with a compartment outside of the safe area. Ensure that appropriate compartmentalization is built into the system design, and the compartmentalization allows for and reinforces privilege separation functionality. Architects and designers should rely on the principle of least privilege to decide the appropriate time to use privileges and the time to drop privileges.::PHASE:Implementation:DESCRIPTION:Ensure that error messages only contain minimal details that are useful to the intended audience and no one else. The messages need to strike the balance between being too cryptic (which can confuse users) or being too detailed (which may reveal more than intended). The messages should not reveal the methods that were used to determine the error. Attackers can use detailed information to refine or optimize their original attack, thereby increasing their chances of success. If errors must be captured in some detail, record them in log messages, but consider what could occur if the log messages can be viewed by attackers. Highly sensitive information such as passwords should never be saved to log files. Avoid inconsistent messaging that might accidentally tip off an attacker about internal state, such as whether a user account exists or not.::","::REFERENCE:CVE-2020-8695:DESCRIPTION:Observable discrepancy in the RAPL interface for some Intel processors allows information disclosure.:LINK:https://www.cve.org/CVERecord?id=CVE-2020-8695::REFERENCE:CVE-2002-2094:DESCRIPTION:This, and others, use .. attacks and monitor error responses, so there is overlap with directory traversal.:LINK:https://www.cve.org/CVERecord?id=CVE-2002-2094::REFERENCE:CVE-2001-1483:DESCRIPTION:Enumeration of valid usernames based on inconsistent responses:LINK:https://www.cve.org/CVERecord?id=CVE-2001-1483::REFERENCE:CVE-2001-1528:DESCRIPTION:Account number enumeration via inconsistent responses.:LINK:https://www.cve.org/CVERecord?id=CVE-2001-1528::REFERENCE:CVE-2004-2150:DESCRIPTION:User enumeration via discrepancies in error messages.:LINK:https://www.cve.org/CVERecord?id=CVE-2004-2150::REFERENCE:CVE-2005-1650:DESCRIPTION:User enumeration via discrepancies in error messages.:LINK:https://www.cve.org/CVERecord?id=CVE-2005-1650::REFERENCE:CVE-2004-0294:DESCRIPTION:Bulletin Board displays different error messages when a user exists or not, which makes it easier for remote attackers to identify valid users and conduct a brute force password guessing attack.:LINK:https://www.cve.org/CVERecord?id=CVE-2004-0294::REFERENCE:CVE-2004-0243:DESCRIPTION:Operating System, when direct remote login is disabled, displays a different message if the password is correct, which allows remote attackers to guess the password via brute force methods.:LINK:https://www.cve.org/CVERecord?id=CVE-2004-0243::REFERENCE:CVE-2002-0514:DESCRIPTION:Product allows remote attackers to determine if a port is being filtered because the response packet TTL is different than the default TTL.:LINK:https://www.cve.org/CVERecord?id=CVE-2002-0514::REFERENCE:CVE-2002-0515:DESCRIPTION:Product sets a different TTL when a port is being filtered than when it is not being filtered, which allows remote attackers to identify filtered ports by comparing TTLs.:LINK:https://www.cve.org/CVERecord?id=CVE-2002-0515::REFERENCE:CVE-2002-0208:DESCRIPTION:Product modifies TCP/IP stack and ICMP error messages in unusual ways that show the product is in use.:LINK:https://www.cve.org/CVERecord?id=CVE-2002-0208::REFERENCE:CVE-2004-2252:DESCRIPTION:Behavioral infoleak by responding to SYN-FIN packets.:LINK:https://www.cve.org/CVERecord?id=CVE-2004-2252::REFERENCE:CVE-2001-1387:DESCRIPTION:Product may generate different responses than specified by the administrator, possibly leading to an information leak.:LINK:https://www.cve.org/CVERecord?id=CVE-2001-1387::REFERENCE:CVE-2004-0778:DESCRIPTION:Version control system allows remote attackers to determine the existence of arbitrary files and directories via the -X command for an alternate history file, which causes different error messages to be returned.:LINK:https://www.cve.org/CVERecord?id=CVE-2004-0778::REFERENCE:CVE-2004-1428:DESCRIPTION:FTP server generates an error message if the user name does not exist instead of prompting for a password, which allows remote attackers to determine valid usernames.:LINK:https://www.cve.org/CVERecord?id=CVE-2004-1428::REFERENCE:CVE-2003-0078:DESCRIPTION:SSL implementation does not perform a MAC computation if an incorrect block cipher padding is used, which causes an information leak (timing discrepancy) that may make it easier to launch cryptographic attacks that rely on distinguishing between padding and MAC verification errors, possibly leading to extraction of the original plaintext, aka the Vaudenay timing attack.:LINK:https://www.cve.org/CVERecord?id=CVE-2003-0078::REFERENCE:CVE-2000-1117:DESCRIPTION:Virtual machine allows malicious web site operators to determine the existence of files on the client by measuring delays in the execution of the getSystemResource method.:LINK:https://www.cve.org/CVERecord?id=CVE-2000-1117::REFERENCE:CVE-2003-0637:DESCRIPTION:Product uses a shorter timeout for a non-existent user than a valid user, which makes it easier for remote attackers to guess usernames and conduct brute force password guessing.:LINK:https://www.cve.org/CVERecord?id=CVE-2003-0637::REFERENCE:CVE-2003-0190:DESCRIPTION:Product immediately sends an error message when a user does not exist, which allows remote attackers to determine valid usernames via a timing attack.:LINK:https://www.cve.org/CVERecord?id=CVE-2003-0190::REFERENCE:CVE-2004-1602:DESCRIPTION:FTP server responds in a different amount of time when a given username exists, which allows remote attackers to identify valid usernames by timing the server response.:LINK:https://www.cve.org/CVERecord?id=CVE-2004-1602::REFERENCE:CVE-2005-0918:DESCRIPTION:Browser allows remote attackers to determine the existence of arbitrary files by setting the src property to the target filename and using Javascript to determine if the web page immediately stops loading, which indicates whether the file exists or not.:LINK:https://www.cve.org/CVERecord?id=CVE-2005-0918::",,,"::TAXONOMY NAME:PLOVER:ENTRY NAME:Discrepancy Information Leaks::TAXONOMY NAME:OWASP Top Ten 2007:ENTRY ID:A6:ENTRY NAME:Information Leakage and Improper Error Handling:MAPPING FIT:CWE More Specific::TAXONOMY NAME:OWASP Top Ten 2004:ENTRY ID:A7:ENTRY NAME:Improper Error Handling:MAPPING FIT:CWE More Specific::",::189::,"",
226,"Sensitive Information in Resource Not Removed Before Reuse",Base,Draft,"The product releases a resource such as memory or a file so that it can be made available for reuse, but it does not clear or zeroize the information contained in the resource before the product performs a critical state transition or makes the resource available for reuse by other entities.","When resources are released, they can be made available for reuse. For example, after memory is de-allocated, an operating system may make the memory available to another process, or disk space may be reallocated when a file is deleted. As removing information requires time and additional resources, operating systems do not usually clear the previously written information. Even when the resource is reused by the same process, this weakness can arise when new data is not as large as the old data, which leaves portions of the old data still available. Equivalent errors can occur in other situations where the length of data is variable but the associated data structure is not. If memory is not cleared after use, the information may be read by less trustworthy parties when the memory is reallocated. This weakness can apply in hardware, such as when a device or system switches between power, sleep, or debug states during normal operation, or when execution changes to different users or privilege levels.",::NATURE:ChildOf:CWE ID:459:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:212:VIEW ID:1000::NATURE:CanPrecede:CWE ID:201:VIEW ID:1000::,"::ORDINALITY:Primary::",::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::TECHNOLOGY CLASS:Not Technology-Specific:TECHNOLOGY PREVALENCE:Undetermined::,"","","::PHASE:Architecture and Design::PHASE:Implementation::","",,"::SCOPE:Confidentiality:IMPACT:Read Application Data::","::METHOD:Manual Analysis:DESCRIPTION:Write a known pattern into each sensitive location. Trigger the release of the resource or cause the desired state transition to occur. Read data back from the sensitive locations. If the reads are successful, and the data is the same as the pattern that was originally written, the test fails and the product needs to be fixed. Note that this test can likely be automated.:EFFECTIVENESS:High::","::PHASE:Architecture and Design Implementation:DESCRIPTION:During critical state transitions, information not needed in the next state should be removed or overwritten with fixed patterns (such as all 0's) or random data, before the transition to the next state.:EFFECTIVENESS:High::PHASE:Architecture and Design Implementation:DESCRIPTION:When releasing, de-allocating, or deleting a resource, overwrite its data and relevant metadata with fixed patterns or random data. Be cautious about complex resource types whose underlying representation might be non-contiguous or change at a low level, such as how a file might be split into different chunks on a file system, even though logical file positions are contiguous at the application layer. Such resource types might require invocation of special modes or APIs to tell the underlying operating system to perform the necessary clearing, such as SDelete (Secure Delete) on Windows, although the appropriate functionality might not be available at the application layer.:EFFECTIVENESS:High::","::REFERENCE:CVE-2003-0001:DESCRIPTION:Ethernet NIC drivers do not pad frames with null bytes, leading to infoleak from malformed packets.:LINK:https://www.cve.org/CVERecord?id=CVE-2003-0001::REFERENCE:CVE-2003-0291:DESCRIPTION:router does not clear information from DHCP packets that have been previously used:LINK:https://www.cve.org/CVERecord?id=CVE-2003-0291::REFERENCE:CVE-2005-1406:DESCRIPTION:Products do not fully clear memory buffers when less data is stored into the buffer than previous.:LINK:https://www.cve.org/CVERecord?id=CVE-2005-1406::REFERENCE:CVE-2005-1858:DESCRIPTION:Products do not fully clear memory buffers when less data is stored into the buffer than previous.:LINK:https://www.cve.org/CVERecord?id=CVE-2005-1858::REFERENCE:CVE-2005-3180:DESCRIPTION:Products do not fully clear memory buffers when less data is stored into the buffer than previous.:LINK:https://www.cve.org/CVERecord?id=CVE-2005-3180::REFERENCE:CVE-2005-3276:DESCRIPTION:Product does not clear a data structure before writing to part of it, yielding information leak of previously used memory.:LINK:https://www.cve.org/CVERecord?id=CVE-2005-3276::REFERENCE:CVE-2002-2077:DESCRIPTION:Memory not properly cleared before reuse.:LINK:https://www.cve.org/CVERecord?id=CVE-2002-2077::",::Memory Management::Networking::,::Memory::,"::TAXONOMY NAME:PLOVER:ENTRY NAME:Sensitive Information Uncleared Before Use::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:MEM03-C:ENTRY NAME:Clear sensitive information stored in reusable resources returned for reuse::TAXONOMY NAME:Software Fault Patterns:ENTRY ID:SFP23:ENTRY NAME:Exposed Data::",::37::,"::TYPE:Relationship:NOTE:There is a close association between CWE-226 and CWE-212. The difference is partially that of perspective. CWE-226 is geared towards the final stage of the resource lifecycle, in which the resource is deleted, eliminated, expired, or otherwise released for reuse. Technically, this involves a transfer to a different control sphere, in which the original contents of the resource are no longer relevant. CWE-212, however, is intended for sensitive data in resources that are intentionally shared with others, so they are still active. This distinction is useful from the perspective of the CWE research view (CWE-1000).::TYPE:Maintenance:NOTE:This entry needs modification to clarify the differences with CWE-212. The description also combines two problems that are distinct from the CWE research perspective: the inadvertent transfer of information to another sphere, and improper initialization/shutdown. Some of the associated taxonomy mappings reflect these different uses.::TYPE:Research Gap:NOTE:This is frequently found for network packets, but it can also exist in local memory allocation, files, etc.::",
276,"Incorrect Default Permissions",Base,Draft,"During installation, installed file permissions are set to allow anyone to modify those files.","",::NATURE:ChildOf:CWE ID:732:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:732:VIEW ID:1003:ORDINAL:Primary::,"::ORDINALITY:Primary::",::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::TECHNOLOGY CLASS:Not Technology-Specific:TECHNOLOGY PREVALENCE:Undetermined::TECHNOLOGY CLASS:ICS/OT:TECHNOLOGY PREVALENCE:Undetermined::,"","","::PHASE:Architecture and Design::PHASE:Implementation::PHASE:Installation::PHASE:Operation::","",,"::SCOPE:Confidentiality:SCOPE:Integrity:IMPACT:Read Application Data:IMPACT:Modify Application Data::","::METHOD:Automated Static Analysis - Binary or Bytecode:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Inter-application Flow Analysis:EFFECTIVENESS:SOAR Partial::METHOD:Manual Static Analysis - Binary or Bytecode:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Binary / Bytecode disassembler - then use manual analysis for vulnerabilities & anomalies:EFFECTIVENESS:SOAR Partial::METHOD:Dynamic Analysis with Automated Results Interpretation:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Host-based Vulnerability Scanners - Examine configuration for flaws, verifying that audit mechanisms work, ensure host configuration meets certain predefined criteria Web Application Scanner Web Services Scanner Database Scanners:EFFECTIVENESS:SOAR Partial::METHOD:Dynamic Analysis with Manual Results Interpretation:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Host Application Interface Scanner Cost effective for partial coverage: Fuzz Tester Framework-based Fuzzer Automated Monitored Execution Forced Path Execution:EFFECTIVENESS:High::METHOD:Manual Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Manual Source Code Review (not inspections) Cost effective for partial coverage: Focused Manual Spotcheck - Focused manual analysis of source:EFFECTIVENESS:High::METHOD:Automated Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Context-configured Source Code Weakness Analyzer:EFFECTIVENESS:SOAR Partial::METHOD:Automated Static Analysis:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Configuration Checker:EFFECTIVENESS:SOAR Partial::METHOD:Architecture or Design Review:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Formal Methods / Correct-By-Construction Cost effective for partial coverage: Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.):EFFECTIVENESS:High::","::PHASE:Architecture and Design Operation:DESCRIPTION:The architecture needs to access and modification attributes for files to only those users who actually require those actions.::PHASE:Architecture and Design:STRATEGY:Separation of Privilege:DESCRIPTION:Compartmentalize the system to have safe areas where trust boundaries can be unambiguously drawn. Do not allow sensitive data to go outside of the trust boundary and always be careful when interfacing with a compartment outside of the safe area. Ensure that appropriate compartmentalization is built into the system design, and the compartmentalization allows for and reinforces privilege separation functionality. Architects and designers should rely on the principle of least privilege to decide the appropriate time to use privileges and the time to drop privileges.::","::REFERENCE:CVE-2005-1941:DESCRIPTION:Executables installed world-writable.:LINK:https://www.cve.org/CVERecord?id=CVE-2005-1941::REFERENCE:CVE-2002-1713:DESCRIPTION:Home directories installed world-readable.:LINK:https://www.cve.org/CVERecord?id=CVE-2002-1713::REFERENCE:CVE-2001-1550:DESCRIPTION:World-writable log files allow information loss; world-readable file has cleartext passwords.:LINK:https://www.cve.org/CVERecord?id=CVE-2001-1550::REFERENCE:CVE-2002-1711:DESCRIPTION:World-readable directory.:LINK:https://www.cve.org/CVERecord?id=CVE-2002-1711::REFERENCE:CVE-2002-1844:DESCRIPTION:Windows product uses insecure permissions when installing on Solaris (genesis: port error).:LINK:https://www.cve.org/CVERecord?id=CVE-2002-1844::REFERENCE:CVE-2001-0497:DESCRIPTION:Insecure permissions for a shared secret key file. Overlaps cryptographic problem.:LINK:https://www.cve.org/CVERecord?id=CVE-2001-0497::REFERENCE:CVE-1999-0426:DESCRIPTION:Default permissions of a device allow IP spoofing.:LINK:https://www.cve.org/CVERecord?id=CVE-1999-0426::",,,"::TAXONOMY NAME:PLOVER:ENTRY NAME:Insecure Default Permissions::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:FIO06-C:ENTRY NAME:Create files with appropriate access permissions::TAXONOMY NAME:The CERT Oracle Secure Coding Standard for Java (2011):ENTRY ID:FIO01-J:ENTRY NAME:Create files with appropriate access permission::",::1::127::81::,"",
319,"Cleartext Transmission of Sensitive Information",Base,Draft,"The product transmits sensitive or security-critical data in cleartext in a communication channel that can be sniffed by unauthorized actors.","Many communication channels can be sniffed (monitored) by adversaries during data transmission. For example, in networking, packets can traverse many intermediary nodes from the source to the destination, whether across the internet, an internal network, the cloud, etc. Some actors might have privileged access to a network interface or any link along the channel, such as a router, but they might not be authorized to collect the underlying data. As a result, network traffic could be sniffed by adversaries, spilling security-critical data. Applicable communication channels are not limited to software products. Applicable channels include hardware-specific technologies such as internal hardware networks and external debug channels, supporting remote JTAG debugging. When mitigations are not applied to combat adversaries within the product's threat model, this weakness significantly lowers the difficulty of exploitation by such adversaries. When full communications are recorded or logged, such as with a packet dump, an adversary could attempt to obtain the dump long after the transmission has occurred and try to sniff the cleartext from the recorded communications in the dump itself.",::NATURE:ChildOf:CWE ID:311:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:311:VIEW ID:1003:ORDINAL:Primary::,"",::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::TECHNOLOGY CLASS:Cloud Computing:TECHNOLOGY PREVALENCE:Undetermined::TECHNOLOGY CLASS:Mobile:TECHNOLOGY PREVALENCE:Undetermined::TECHNOLOGY CLASS:ICS/OT:TECHNOLOGY PREVALENCE:Often::TECHNOLOGY CLASS:System on Chip:TECHNOLOGY PREVALENCE:Undetermined::TECHNOLOGY NAME:Test/Debug Hardware:TECHNOLOGY PREVALENCE:Often::,"","","::PHASE:Architecture and Design:NOTE:OMISSION: This weakness is caused by missing a security tactic during the architecture and design phase.::PHASE:Architecture and Design:NOTE:For hardware, this may be introduced when design does not plan for an attacker having physical access while a legitimate user is remotely operating the device.::PHASE:Operation::PHASE:System Configuration::","",,"::SCOPE:Integrity:SCOPE:Confidentiality:IMPACT:Read Application Data:IMPACT:Modify Files or Directories:NOTE:Anyone can read the information by gaining access to the channel being used for communication.::","::METHOD:Black Box:DESCRIPTION:Use monitoring tools that examine the software's process as it interacts with the operating system and the network. This technique is useful in cases when source code is unavailable, if the software was not developed by you, or if you want to verify that the build phase did not introduce any new weaknesses. Examples include debuggers that directly attach to the running process; system-call tracing utilities such as truss (Solaris) and strace (Linux); system activity monitors such as FileMon, RegMon, Process Monitor, and other Sysinternals utilities (Windows); and sniffers and protocol analyzers that monitor network traffic. Attach the monitor to the process, trigger the feature that sends the data, and look for the presence or absence of common cryptographic functions in the call tree. Monitor the network and determine if the data packets contain readable commands. Tools exist for detecting if certain encodings are in use. If the traffic contains high entropy, this might indicate the usage of encryption.::","::PHASE:Architecture and Design:DESCRIPTION:Before transmitting, encrypt the data using reliable, confidentiality-protecting cryptographic protocols.::PHASE:Implementation:DESCRIPTION:When using web applications with SSL, use SSL for the entire session from login to logout, not just for the initial login page.::PHASE:Implementation:DESCRIPTION:When designing hardware platforms, ensure that approved encryption algorithms (such as those recommended by NIST) protect paths from security critical data to trusted user applications.::PHASE:Testing:DESCRIPTION:Use tools and techniques that require manual (human) analysis, such as penetration testing, threat modeling, and interactive tools that allow the tester to record and modify an active session. These may be more effective than strictly automated techniques. This is especially the case with weaknesses that are related to design and business rules.::PHASE:Operation:DESCRIPTION:Configure servers to use encrypted channels for communication, which may include SSL or other secure protocols.::","::REFERENCE:CVE-2022-29519:DESCRIPTION:Programmable Logic Controller (PLC) sends sensitive information in plaintext, including passwords and session tokens.:LINK:https://www.cve.org/CVERecord?id=CVE-2022-29519::REFERENCE:CVE-2022-30312:DESCRIPTION:Building Controller uses a protocol that transmits authentication credentials in plaintext.:LINK:https://www.cve.org/CVERecord?id=CVE-2022-30312::REFERENCE:CVE-2022-31204:DESCRIPTION:Programmable Logic Controller (PLC) sends password in plaintext.:LINK:https://www.cve.org/CVERecord?id=CVE-2022-31204::REFERENCE:CVE-2002-1949:DESCRIPTION:Passwords transmitted in cleartext.:LINK:https://www.cve.org/CVERecord?id=CVE-2002-1949::REFERENCE:CVE-2008-4122:DESCRIPTION:Chain: Use of HTTPS cookie without secure flag causes it to be transmitted across unencrypted HTTP.:LINK:https://www.cve.org/CVERecord?id=CVE-2008-4122::REFERENCE:CVE-2008-3289:DESCRIPTION:Product sends password hash in cleartext in violation of intended policy.:LINK:https://www.cve.org/CVERecord?id=CVE-2008-3289::REFERENCE:CVE-2008-4390:DESCRIPTION:Remote management feature sends sensitive information including passwords in cleartext.:LINK:https://www.cve.org/CVERecord?id=CVE-2008-4390::REFERENCE:CVE-2007-5626:DESCRIPTION:Backup routine sends password in cleartext in email.:LINK:https://www.cve.org/CVERecord?id=CVE-2007-5626::REFERENCE:CVE-2004-1852:DESCRIPTION:Product transmits Blowfish encryption key in cleartext.:LINK:https://www.cve.org/CVERecord?id=CVE-2004-1852::REFERENCE:CVE-2008-0374:DESCRIPTION:Printer sends configuration information, including administrative password, in cleartext.:LINK:https://www.cve.org/CVERecord?id=CVE-2008-0374::REFERENCE:CVE-2007-4961:DESCRIPTION:Chain: cleartext transmission of the MD5 hash of password enables attacks against a server that is susceptible to replay (CWE-294).:LINK:https://www.cve.org/CVERecord?id=CVE-2007-4961::REFERENCE:CVE-2007-4786:DESCRIPTION:Product sends passwords in cleartext to a log server.:LINK:https://www.cve.org/CVERecord?id=CVE-2007-4786::REFERENCE:CVE-2005-3140:DESCRIPTION:Product sends file with cleartext passwords in e-mail message intended for diagnostic purposes.:LINK:https://www.cve.org/CVERecord?id=CVE-2005-3140::",,,"::TAXONOMY NAME:PLOVER:ENTRY NAME:Plaintext Transmission of Sensitive Information::TAXONOMY NAME:The CERT Oracle Secure Coding Standard for Java (2011):ENTRY ID:SEC06-J:ENTRY NAME:Do not rely on the default automatic signature verification provided by URLClassLoader and java.util.jar::TAXONOMY NAME:The CERT Oracle Secure Coding Standard for Java (2011):ENTRY ID:SER02-J:ENTRY NAME:Sign then seal sensitive objects before sending them outside a trust boundary::TAXONOMY NAME:Software Fault Patterns:ENTRY ID:SFP23:ENTRY NAME:Exposed Data::TAXONOMY NAME:ISA/IEC 62443:ENTRY ID:Part 3-3:ENTRY NAME:Req SR 4.1::TAXONOMY NAME:ISA/IEC 62443:ENTRY ID:Part 4-2:ENTRY NAME:Req CR 4.1B::",::102::117::383::477::65::,"::TYPE:Maintenance:NOTE:The Taxonomy_Mappings to ISA/IEC 62443 were added in CWE 4.10, but they are still under review and might change in future CWE versions. These draft mappings were performed by members of the Mapping CWE to 62443 subgroup of the CWE-CAPEC ICS/OT Special Interest Group (SIG), and their work is incomplete as of CWE 4.10. The mappings are included to facilitate discussion and review by the broader ICS/OT community, and they are likely to change in future CWE versions.::",
325,"Missing Cryptographic Step",Base,Draft,"The product does not implement a required step in a cryptographic algorithm, resulting in weaker encryption than advertised by the algorithm.","",::NATURE:ChildOf:CWE ID:573:VIEW ID:1000:ORDINAL:Primary::NATURE:PeerOf:CWE ID:358:VIEW ID:1000::,"",::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::TECHNOLOGY CLASS:Not Technology-Specific:TECHNOLOGY PREVALENCE:Undetermined::,"","","::PHASE:Implementation:NOTE:Developers sometimes omit expensive (resource-intensive) steps in order to improve performance, especially in devices with limited memory or slower CPUs. This step may be taken under a mistaken impression that the step is unnecessary for the cryptographic algorithm.::PHASE:Architecture and Design::PHASE:Requirements:NOTE:This issue may happen when the requirements for the cryptographic algorithm are not clearly stated.::","",,"::SCOPE:Access Control:IMPACT:Bypass Protection Mechanism::SCOPE:Confidentiality:SCOPE:Integrity:IMPACT:Read Application Data:IMPACT:Modify Application Data::SCOPE:Accountability:SCOPE:Non-Repudiation:IMPACT:Hide Activities::","","","::REFERENCE:CVE-2001-1585:DESCRIPTION:Missing challenge-response step allows authentication bypass using public key.:LINK:https://www.cve.org/CVERecord?id=CVE-2001-1585::",::Cryptography::,,"::TAXONOMY NAME:PLOVER:ENTRY NAME:Missing Required Cryptographic Step::TAXONOMY NAME:OWASP Top Ten 2007:ENTRY ID:A8:ENTRY NAME:Insecure Cryptographic Storage:MAPPING FIT:CWE More Specific::TAXONOMY NAME:OWASP Top Ten 2007:ENTRY ID:A9:ENTRY NAME:Insecure Communications:MAPPING FIT:CWE More Specific::",::68::,"::TYPE:Relationship:NOTE:Overlaps incomplete/missing security check.::TYPE:Relationship:NOTE:Can be resultant.::",
440,"Expected Behavior Violation",Base,Draft,"A feature, API, or function does not perform according to its specification.","",::NATURE:ChildOf:CWE ID:684:VIEW ID:1000:ORDINAL:Primary::,"",::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::TECHNOLOGY CLASS:ICS/OT:TECHNOLOGY PREVALENCE:Undetermined::,"","","::PHASE:Architecture and Design::PHASE:Implementation::PHASE:Operation::","",,"::SCOPE:Other:IMPACT:Quality Degradation:IMPACT:Varies by Context::","","","::REFERENCE:CVE-2003-0187:DESCRIPTION:Program uses large timeouts on undeserving to compensate for inconsistency of support for linked lists.:LINK:https://www.cve.org/CVERecord?id=CVE-2003-0187::REFERENCE:CVE-2003-0465:DESCRIPTION:strncpy in Linux kernel acts different than libc on x86, leading to expected behavior difference - sort of a multiple interpretation error?:LINK:https://www.cve.org/CVERecord?id=CVE-2003-0465::REFERENCE:CVE-2005-3265:DESCRIPTION:Buffer overflow in product stems the use of a third party library function that is expected to have internal protection against overflows, but doesn't.:LINK:https://www.cve.org/CVERecord?id=CVE-2005-3265::",,,"::TAXONOMY NAME:PLOVER:ENTRY NAME:Expected behavior violation::",,"::TYPE:Theoretical:NOTE:The behavior of an application that is not consistent with the expectations of the developer may lead to incorrect use of the software.::",
441,"Unintended Proxy or Intermediary ('Confused Deputy')",Class,Draft,"The product receives a request, message, or directive from an upstream component, but the product does not sufficiently preserve the original source of the request before forwarding the request to an external actor that is outside of the product's control sphere. This causes the product to appear to be the source of the request, leading it to act as a proxy or other intermediary between the upstream component and the external actor.","If an attacker cannot directly contact a target, but the product has access to the target, then the attacker can send a request to the product and have it be forwarded to the target. The request would appear to be coming from the product's system, not the attacker's system. As a result, the attacker can bypass access controls (such as firewalls) or hide the source of malicious requests, since the requests would not be coming directly from the attacker. Since proxy functionality and message-forwarding often serve a legitimate purpose, this issue only becomes a vulnerability when: The product runs with different privileges or on a different system, or otherwise has different levels of access than the upstream component; The attacker is prevented from making the request directly to the target; and The attacker can create a request that the proxy does not explicitly intend to be forwarded on the behalf of the requester. Such a request might point to an unexpected hostname, port number, hardware IP, or service. Or, the request might be sent to an allowed service, but the request could contain disallowed directives, commands, or resources.",::NATURE:ChildOf:CWE ID:610:VIEW ID:1000:ORDINAL:Primary::NATURE:CanPrecede:CWE ID:668:VIEW ID:1000::,"",::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::OPERATING SYSTEM CLASS:Not OS-Specific:OPERATING SYSTEM PREVALENCE:Undetermined::ARCHITECTURE CLASS:Not Architecture-Specific:ARCHITECTURE PREVALENCE:Undetermined::TECHNOLOGY CLASS:Not Technology-Specific:TECHNOLOGY PREVALENCE:Undetermined::,"","::TERM:Confused Deputy:DESCRIPTION:This weakness is sometimes referred to as the Confused deputy problem, in which an attacker misused the authority of one victim (the confused deputy) when targeting another victim.::","::PHASE:Architecture and Design:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::","",,"::SCOPE:Non-Repudiation:SCOPE:Access Control:IMPACT:Gain Privileges or Assume Identity:IMPACT:Hide Activities:IMPACT:Execute Unauthorized Code or Commands::","","::PHASE:Architecture and Design:DESCRIPTION:Enforce the use of strong mutual authentication mechanism between the two parties.::PHASE:Architecture and Design:DESCRIPTION:Whenever a product is an intermediary or proxy for transactions between two other components, the proxy core should not drop the identity of the initiator of the transaction. The immutability of the identity of the initiator must be maintained and should be forwarded all the way to the target.::","::REFERENCE:CVE-1999-0017:DESCRIPTION:FTP bounce attack. The design of the protocol allows an attacker to modify the PORT command to cause the FTP server to connect to other machines besides the attacker's.:LINK:https://www.cve.org/CVERecord?id=CVE-1999-0017::REFERENCE:CVE-1999-0168:DESCRIPTION:RPC portmapper could redirect service requests from an attacker to another entity, which thinks the requests came from the portmapper.:LINK:https://www.cve.org/CVERecord?id=CVE-1999-0168::REFERENCE:CVE-2005-0315:DESCRIPTION:FTP server does not ensure that the IP address in a PORT command is the same as the FTP user's session, allowing port scanning by proxy.:LINK:https://www.cve.org/CVERecord?id=CVE-2005-0315::REFERENCE:CVE-2002-1484:DESCRIPTION:Web server allows attackers to request a URL from another server, including other ports, which allows proxied scanning.:LINK:https://www.cve.org/CVERecord?id=CVE-2002-1484::REFERENCE:CVE-2004-2061:DESCRIPTION:CGI script accepts and retrieves incoming URLs.:LINK:https://www.cve.org/CVERecord?id=CVE-2004-2061::REFERENCE:CVE-2001-1484:DESCRIPTION:Bounce attack allows access to TFTP from trusted side.:LINK:https://www.cve.org/CVERecord?id=CVE-2001-1484::REFERENCE:CVE-2010-1637:DESCRIPTION:Web-based mail program allows internal network scanning using a modified POP3 port number.:LINK:https://www.cve.org/CVERecord?id=CVE-2010-1637::REFERENCE:CVE-2009-0037:DESCRIPTION:URL-downloading library automatically follows redirects to file:// and scp:// URLs:LINK:https://www.cve.org/CVERecord?id=CVE-2009-0037::",,,"::TAXONOMY NAME:PLOVER:ENTRY NAME:Unintended proxy/intermediary::TAXONOMY NAME:PLOVER:ENTRY NAME:Proxied Trusted Channel::TAXONOMY NAME:WASC:ENTRY ID:32:ENTRY NAME:Routing Detour::",::219::465::,"::TYPE:Relationship:NOTE:This weakness has a chaining relationship with CWE-668 (Exposure of Resource to Wrong Sphere) because the proxy effectively provides the attacker with access to the target's resources that the attacker cannot directly obtain.::TYPE:Maintenance:NOTE:This could possibly be considered as an emergent resource.::TYPE:Theoretical:NOTE:It could be argued that the confused deputy is a fundamental aspect of most vulnerabilities that require an active attacker. Even for common implementation issues such as buffer overflows, SQL injection, OS command injection, and path traversal, the vulnerable program already has the authorization to run code or access files. The vulnerability arises when the attacker causes the program to run unexpected code or access unexpected files.::",
1053,"Missing Documentation for Design",Base,Incomplete,"The product does not have documentation that represents how it is designed.","This issue can make it more difficult to understand and maintain the product. It can make it more difficult and time-consuming to detect and/or fix vulnerabilities.",::NATURE:ChildOf:CWE ID:1059:VIEW ID:1000:ORDINAL:Primary::,"::ORDINALITY:Indirect::",,"","","","",,"","","","",,,"",,"",
1059,"Insufficient Technical Documentation",Class,Incomplete,"The product does not contain sufficient technical or engineering documentation (whether on paper or in electronic form) that contains descriptions of all the relevant software/hardware elements of the product, such as its usage, structure, architectural components, interfaces, design, implementation, configuration, operation, etc.","When technical documentation is limited or lacking, products are more difficult to maintain. This indirectly affects security by making it more difficult or time-consuming to find and/or fix vulnerabilities. When using time-limited or labor-limited third-party/in-house security consulting services (such as threat modeling, vulnerability discovery, or pentesting), insufficient documentation can force those consultants to invest unnecessary time in learning how the product is organized, instead of focusing their expertise on finding the flaws or suggesting effective mitigations. With respect to hardware design, the lack of a formal, final manufacturer reference can make it difficult or impossible to evaluate the final product, including post-manufacture verification. One cannot ensure that design functionality or operation is within acceptable tolerances, conforms to specifications, and is free from unexpected behavior. Hardware-related documentation may include engineering artifacts such as hardware description language (HDLs), netlists, Gerber files, Bills of Materials, EDA (Electronic Design Automation) tool files, etc.",::NATURE:ChildOf:CWE ID:710:VIEW ID:1000:ORDINAL:Primary::,"::ORDINALITY:Indirect::",::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::OPERATING SYSTEM CLASS:Not OS-Specific:OPERATING SYSTEM PREVALENCE:Undetermined::ARCHITECTURE CLASS:Not Architecture-Specific:ARCHITECTURE PREVALENCE:Undetermined::TECHNOLOGY CLASS:Not Technology-Specific:TECHNOLOGY PREVALENCE:Undetermined::TECHNOLOGY CLASS:ICS/OT:TECHNOLOGY PREVALENCE:Undetermined::,"","","::PHASE:Architecture and Design::PHASE:Documentation::","",,"::SCOPE:Other:IMPACT:Varies by Context:IMPACT:Hide Activities:IMPACT:Reduce Reliability:IMPACT:Quality Degradation:IMPACT:Reduce Maintainability:NOTE:Without a method of verification, one cannot be sure that everything only functions as expected.::","","::PHASE:Documentation Architecture and Design:DESCRIPTION:Ensure that design documentation is detailed enough to allow for post-manufacturing verification.::","",,,"",,"",
1189,"Improper Isolation of Shared Resources on System-on-a-Chip (SoC)",Base,Stable,"The System-On-a-Chip (SoC) does not properly isolate shared resources between trusted and untrusted agents.","A System-On-a-Chip (SoC) has a lot of functionality, but it may have a limited number of pins or pads. A pin can only perform one function at a time. However, it can be configured to perform multiple different functions. This technique is called pin multiplexing. Similarly, several resources on the chip may be shared to multiplex and support different features or functions. When such resources are shared between trusted and untrusted agents, untrusted agents may be able to access the assets intended to be accessed only by the trusted agents.",::NATURE:ChildOf:CWE ID:653:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:668:VIEW ID:1000::NATURE:PeerOf:CWE ID:1331:VIEW ID:1000::,"::ORDINALITY:Primary::",::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::TECHNOLOGY CLASS:System on Chip:TECHNOLOGY PREVALENCE:Undetermined::,"","","::PHASE:Architecture and Design::PHASE:Implementation::","",,"::SCOPE:Access Control:IMPACT:Bypass Protection Mechanism:NOTE:If resources being used by a trusted user are shared with an untrusted user, the untrusted user may be able to modify the functionality of the shared resource of the trusted user.::SCOPE:Integrity:IMPACT:Quality Degradation:NOTE:The functionality of the shared resource may be intentionally degraded.::","::METHOD:Automated Dynamic Analysis:DESCRIPTION:Pre-silicon / post-silicon: Test access to shared systems resources (memory ranges, control registers, etc.) from untrusted software to verify that the assets are not incorrectly exposed to untrusted agents. Note that access to shared resources can be dynamically allowed or revoked based on system flows. Security testing should cover such dynamic shared resource allocation and access control modification flows.:EFFECTIVENESS:High::","::PHASE:Architecture and Design:STRATEGY:Separation of Privilege:DESCRIPTION:When sharing resources, avoid mixing agents of varying trust levels. Untrusted agents should not share resources with trusted agents.::","::REFERENCE:CVE-2019-6260:DESCRIPTION:Baseboard Management Controller (BMC) device implements Advanced High-performance Bus (AHB) bridges that do not require authentication for arbitrary read and write access to the BMC's physical address space from the host, and possibly the network [REF-1138].:LINK:https://www.cve.org/CVERecord?id=CVE-2019-6260::",,,"",::124::,"",
1190,"DMA Device Enabled Too Early in Boot Phase",Base,Draft,"The product enables a Direct Memory Access (DMA) capable device before the security configuration settings are established, which allows an attacker to extract data from or gain privileges on the product.","DMA is included in a number of devices because it allows data transfer between the computer and the connected device, using direct hardware access to read or write directly to main memory without any OS interaction. An attacker could exploit this to access secrets. Several virtualization-based mitigations have been introduced to thwart DMA attacks. These are usually configured/setup during boot time. However, certain IPs that are powered up before boot is complete (known as early boot IPs) may be DMA capable. Such IPs, if not trusted, could launch DMA attacks and gain access to assets that should otherwise be protected.",::NATURE:ChildOf:CWE ID:696:VIEW ID:1000:ORDINAL:Primary::,"",::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::TECHNOLOGY CLASS:System on Chip:TECHNOLOGY PREVALENCE:Undetermined::,"","","::PHASE:Architecture and Design::","",,"::SCOPE:Access Control:IMPACT:Bypass Protection Mechanism:IMPACT:Modify Memory:LIKELIHOOD:High:NOTE:DMA devices have direct write access to main memory and due to time of attack will be able to bypass OS or Bootloader access control.::","","::PHASE:Architecture and Design:DESCRIPTION:Utilize an IOMMU to orchestrate IO access from the start of the boot process.::","",,,"",::180::,"",
1191,"On-Chip Debug and Test Interface With Improper Access Control",Base,Stable,"The chip does not implement or does not correctly perform access control to check whether users are authorized to access internal registers and test modes through the physical debug/test interface.","A device's internal information may be accessed through a scan chain of interconnected internal registers, usually through a JTAG interface. The JTAG interface provides access to these registers in a serial fashion in the form of a scan chain for the purposes of debugging programs running on a device. Since almost all information contained within a device may be accessed over this interface, device manufacturers typically insert some form of authentication and authorization to prevent unintended use of this sensitive information. This mechanism is implemented in addition to on-chip protections that are already present. If authorization, authentication, or some other form of access control is not implemented or not implemented correctly, a user may be able to bypass on-chip protection mechanisms through the debug interface. Sometimes, designers choose not to expose the debug pins on the motherboard. Instead, they choose to hide these pins in the intermediate layers of the board. This is primarily done to work around the lack of debug authorization inside the chip. In such a scenario (without debug authorization), when the debug interface is exposed, chip internals are accessible to an attacker.",::NATURE:ChildOf:CWE ID:284:VIEW ID:1000:ORDINAL:Primary::,"::ORDINALITY:Primary::",::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::OPERATING SYSTEM CLASS:Not OS-Specific:OPERATING SYSTEM PREVALENCE:Undetermined::ARCHITECTURE CLASS:Not Architecture-Specific:ARCHITECTURE PREVALENCE:Undetermined::TECHNOLOGY CLASS:Not Technology-Specific:TECHNOLOGY PREVALENCE:Undetermined::,"","","::PHASE:Architecture and Design::PHASE:Implementation::","",,"::SCOPE:Confidentiality:IMPACT:Read Application Data:LIKELIHOOD:High::SCOPE:Confidentiality:IMPACT:Read Memory:LIKELIHOOD:High::SCOPE:Authorization:IMPACT:Execute Unauthorized Code or Commands:LIKELIHOOD:High::SCOPE:Integrity:IMPACT:Modify Memory:LIKELIHOOD:High::SCOPE:Integrity:IMPACT:Modify Application Data:LIKELIHOOD:High::SCOPE:Access Control:IMPACT:Bypass Protection Mechanism:LIKELIHOOD:High::","::METHOD:Dynamic Analysis with Manual Results Interpretation:DESCRIPTION:Authentication and authorization of debug and test interfaces should be part of the architecture and design review process. Withholding of private register documentation from the debug and test interface public specification (Security by obscurity) should not be considered as sufficient security.::METHOD:Dynamic Analysis with Manual Results Interpretation:DESCRIPTION:Dynamic tests should be done in the pre-silicon and post-silicon stages to verify that the debug and test interfaces are not open by default.::METHOD:Fuzzing:DESCRIPTION:Tests that fuzz Debug and Test Interfaces should ensure that no access without appropriate authentication and authorization is possible.:EFFECTIVENESS:Moderate::","::PHASE:Architecture and Design:STRATEGY:Separation of Privilege:DESCRIPTION:If feasible, the manufacturer should disable the JTAG interface or implement authentication and authorization for the JTAG interface. If authentication logic is added, it should be resistant to timing attacks. Security-sensitive data stored in registers, such as keys, etc. should be cleared when entering debug mode.:EFFECTIVENESS:High::","::REFERENCE:CVE-2019-18827:DESCRIPTION:chain: JTAG interface is not disabled (CWE-1191) during ROM code execution, introducing a race condition (CWE-362) to extract encryption keys:LINK:https://www.cve.org/CVERecord?id=CVE-2019-18827::",,,"",::1::180::,"::TYPE:Relationship:NOTE:CWE-1191 and CWE-1244 both involve physical debug access, but the weaknesses are different. CWE-1191 is effectively about missing authorization for a debug interface, i.e. JTAG. CWE-1244 is about providing internal assets with the wrong debug access level, exposing the asset to untrusted debug agents.::",
1192,"System-on-Chip (SoC) Using Components without Unique, Immutable Identifiers",Base,Draft,"The System-on-Chip (SoC) does not have unique, immutable identifiers for each of its components.","A System-on-Chip (SoC) comprises several components (IP) with varied trust requirements. It is required that each IP is identified uniquely and should distinguish itself from other entities in the SoC without any ambiguity. The unique secured identity is required for various purposes. Most of the time the identity is used to route a transaction or perform certain actions, including resetting, retrieving a sensitive information, and acting upon or on behalf of something else. There are several variants of this weakness: A missing identifier is when the SoC does not define any mechanism to uniquely identify the IP. An insufficient identifier might provide some defenses - for example, against the most common attacks - but it does not protect against everything that is intended. A misconfigured mechanism occurs when a mechanism is available but not implemented correctly. An ignored identifier occurs when the SoC/IP has not applied any policies or does not act upon the identifier securely.",::NATURE:ChildOf:CWE ID:657:VIEW ID:1000:ORDINAL:Primary::,"",::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::TECHNOLOGY CLASS:System on Chip:TECHNOLOGY PREVALENCE:Undetermined::,"","","::PHASE:Architecture and Design::PHASE:Implementation::PHASE:Operation::","",,"::SCOPE:Access Control:IMPACT:Bypass Protection Mechanism:LIKELIHOOD:High::","","::PHASE:Architecture and Design:STRATEGY:Separation of Privilege:DESCRIPTION:Every identity generated in the SoC should be unique and immutable in hardware. The actions that an IP is trusted or not trusted should be clearly defined, implemented, configured, and tested. If the definition is implemented via a policy, then the policy should be immutable or protected with clear authentication and authorization.::","",,,"",::113::,"",
1193,"Power-On of Untrusted Execution Core Before Enabling Fabric Access Control",Base,Draft,"The product enables components that contain untrusted firmware before memory and fabric access controls have been enabled.","After initial reset, System-on-Chip (SoC) fabric access controls and other security features need to be programmed by trusted firmware as part of the boot sequence. If untrusted IPs or peripheral microcontrollers are enabled first, then the untrusted component can master transactions on the hardware bus and target memory or other assets to compromise the SoC boot firmware.",::NATURE:ChildOf:CWE ID:696:VIEW ID:1000:ORDINAL:Primary::,"",,"","","","",,"::SCOPE:Access Control:IMPACT:Bypass Protection Mechanism:LIKELIHOOD:High:NOTE:An untrusted component can master transactions on the HW bus and target memory or other assets to compromise the SoC boot firmware.::","","::PHASE:Architecture and Design:DESCRIPTION:The boot sequence should enable fabric access controls and memory protections before enabling third-party hardware IPs and peripheral microcontrollers that use untrusted firmware.::","",,,"",::1::180::,"",
1209,"Failure to Disable Reserved Bits",Base,Incomplete,"The reserved bits in a hardware design are not disabled prior to production. Typically, reserved bits are used for future capabilities and should not support any functional logic in the design. However, designers might covertly use these bits to debug or further develop new capabilities in production hardware. Adversaries with access to these bits will write to them in hopes of compromising hardware state.","Reserved bits are labeled as such so they can be allocated for a later purpose. They are not to do anything in the current design. However, designers might want to use these bits to debug or control/configure a future capability to help minimize time to market (TTM). If the logic being controlled by these bits is still enabled in production, an adversary could use the logic to induce unwanted/unsupported behavior in the hardware.",::NATURE:ChildOf:CWE ID:710:VIEW ID:1000:ORDINAL:Primary::,"",::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::OPERATING SYSTEM CLASS:Not OS-Specific:OPERATING SYSTEM PREVALENCE:Undetermined::ARCHITECTURE CLASS:Not Architecture-Specific:ARCHITECTURE PREVALENCE:Undetermined::TECHNOLOGY CLASS:System on Chip:TECHNOLOGY PREVALENCE:Undetermined::,"","","::PHASE:Architecture and Design:NOTE:The Designer and Implementer have to make a conscious choice to do this::PHASE:Implementation:NOTE:The Designer and Implementer have to make a conscious choice to do this::PHASE:Documentation:NOTE:If documentation labels anything for future use, reserved, or the like, such labeling could indicate to an attacker a potential attack point::","",,"::SCOPE:Confidentiality:SCOPE:Integrity:SCOPE:Availability:SCOPE:Access Control:SCOPE:Accountability:SCOPE:Authentication:SCOPE:Authorization:SCOPE:Non-Repudiation:IMPACT:Varies by Context:NOTE:This type of weakness all depends on the capabilities of the logic being controlled or configured by the reserved bits::","","::PHASE:Architecture and Design Implementation:DESCRIPTION:Include a feature to disable reserved bits.::PHASE:Integration:DESCRIPTION:Any writes to these reserve bits are blocked (e.g., ignored, access-protected, etc.), or an exception can be asserted.::","",,,"",::121::,"",
1220,"Insufficient Granularity of Access Control",Base,Incomplete,"The product implements access controls via a policy or other feature with the intention to disable or restrict accesses (reads and/or writes) to assets in a system from untrusted agents. However, implemented access controls lack required granularity, which renders the control policy too broad because it allows accesses from unauthorized agents to the security-sensitive assets.","Integrated circuits and hardware engines can expose accesses to assets (device configuration, keys, etc.) to trusted firmware or a software module (commonly set by BIOS/bootloader). This access is typically access-controlled. Upon a power reset, the hardware or system usually starts with default values in registers, and the trusted firmware (Boot firmware) configures the necessary access-control protection. A common weakness that can exist in such protection schemes is that access controls or policies are not granular enough. This condition allows agents beyond trusted agents to access assets and could lead to a loss of functionality or the ability to set up the device securely. This further results in security risks from leaked, sensitive, key material to modification of device configuration.",::NATURE:ChildOf:CWE ID:284:VIEW ID:1000:ORDINAL:Primary::,"",::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::OPERATING SYSTEM CLASS:Not OS-Specific:OPERATING SYSTEM PREVALENCE:Undetermined::ARCHITECTURE CLASS:Not Architecture-Specific:ARCHITECTURE PREVALENCE:Undetermined::TECHNOLOGY CLASS:Not Technology-Specific:TECHNOLOGY PREVALENCE:Undetermined::,"","","::PHASE:Architecture and Design:NOTE:Such issues could be introduced during hardware architecture and design and identified later during Testing or System Configuration phases.::PHASE:Implementation:NOTE:Such issues could be introduced during hardware implementation and identified later during Testing or System Configuration phases.::","",,"::SCOPE:Confidentiality:SCOPE:Integrity:SCOPE:Availability:SCOPE:Access Control:IMPACT:Modify Memory:IMPACT:Read Memory:IMPACT:Execute Unauthorized Code or Commands:IMPACT:Gain Privileges or Assume Identity:IMPACT:Bypass Protection Mechanism:IMPACT:Other:LIKELIHOOD:High::","","::PHASE:Architecture and Design Implementation Testing:DESCRIPTION:Access-control-policy protections must be reviewed for design inconsistency and common weaknesses. Access-control-policy definition and programming flow must be tested in pre-silicon, post-silicon testing.:EFFECTIVENESS:High::","",,,"",::1::180::,"",
1221,"Incorrect Register Defaults or Module Parameters",Base,Incomplete,"Hardware description language code incorrectly defines register defaults or hardware IP parameters to insecure values.","Integrated circuits and hardware IP software programmable controls and settings are commonly stored in register circuits. These register contents have to be initialized at hardware reset to defined default values that are hard coded in the hardware description language (HDL) code of the hardware unit. Hardware descriptive languages also support definition of parameter variables, which can be defined in code during instantiation of the hardware IP module. Such parameters are generally used to configure a specific instance of a hardware IP in the design. The system security settings of a hardware design can be affected by incorrectly defined default values or IP parameters. The hardware IP would be in an insecure state at power reset, and this can be exposed or exploited by untrusted software running on the system. Both register defaults and parameters are hardcoded values, which cannot be changed using software or firmware patches but must be changed in hardware silicon. Thus, such security issues are considerably more difficult to address later in the lifecycle. Hardware designs can have a large number of such parameters and register defaults settings, and it is important to have design tool support to check these settings in an automated way and be able to identify which settings are security sensitive.",::NATURE:ChildOf:CWE ID:665:VIEW ID:1000:ORDINAL:Primary::,"",::LANGUAGE NAME:Verilog:LANGUAGE PREVALENCE:Undetermined::LANGUAGE NAME:VHDL:LANGUAGE PREVALENCE:Undetermined::TECHNOLOGY CLASS:Not Technology-Specific:TECHNOLOGY PREVALENCE:Undetermined::,"","","::PHASE:Implementation:NOTE:Such issues could be introduced during implementation of hardware design, since IP parameters and defaults are defined in HDL code and identified later during Testing or System Configuration phases.::","",,"::SCOPE:Confidentiality:SCOPE:Integrity:SCOPE:Availability:SCOPE:Access Control:IMPACT:Varies by Context:NOTE:Degradation of system functionality, or loss of access control enforcement can occur.::","","::PHASE:Architecture and Design:DESCRIPTION:During hardware design, all the system parameters and register defaults must be reviewed to identify security sensitive settings.::PHASE:Implementation:DESCRIPTION:The default values of these security sensitive settings need to be defined as part of the design review phase.::PHASE:Testing:DESCRIPTION:Testing phase should use automated tools to test that values are configured per design specifications.::","",,,"",::166::,"",
1222,"Insufficient Granularity of Address Regions Protected by Register Locks",Variant,Incomplete,"The product defines a large address region protected from modification by the same register lock control bit. This results in a conflict between the functional requirement that some addresses need to be writable by software during operation and the security requirement that the system configuration lock bit must be set during the boot process.","Integrated circuits and hardware IPs can expose the device configuration controls that need to be programmed after device power reset by a trusted firmware or software module (commonly set by BIOS/bootloader) and then locked from any further modification. In hardware design, this is commonly implemented using a programmable lock bit which enables/disables writing to a protected set of registers or address regions. When the programmable lock bit is set, the relevant address region can be implemented as a hardcoded value in hardware logic that cannot be changed later. A problem can arise wherein the protected region definition is not granular enough. After the programmable lock bit has been set, then this new functionality cannot be implemented without change to the hardware design.",::NATURE:ChildOf:CWE ID:1220:VIEW ID:1000:ORDINAL:Primary::,"",::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::OPERATING SYSTEM CLASS:Not OS-Specific:OPERATING SYSTEM PREVALENCE:Undetermined::ARCHITECTURE CLASS:Not Architecture-Specific:ARCHITECTURE PREVALENCE:Undetermined::TECHNOLOGY CLASS:System on Chip:TECHNOLOGY PREVALENCE:Undetermined::,"","","::PHASE:Architecture and Design:NOTE:Such issues are introduced during hardware architecture and design since software controls and configuration are defined during these phases and identified later during Testing or System Configuration phases.::","",,"::SCOPE:Access Control:IMPACT:Other:NOTE:System security configuration cannot be defined in a way that does not conflict with functional requirements of device.::","","::PHASE:Architecture and Design:DESCRIPTION:The defining of protected locked registers should be reviewed or tested early in the design phase with software teams to ensure software flows are not blocked by the security locks. As an alternative to using register lock control bits and fixed access control regions, the hardware design could use programmable security access control configuration so that device trusted firmware can configure and change the protected regions based on software usage and security models.::","",,,"",::679::,"",
1223,"Race Condition for Write-Once Attributes",Base,Incomplete,"A write-once register in hardware design is programmable by an untrusted software component earlier than the trusted software component, resulting in a race condition issue.","Integrated circuits and hardware IP software programmable controls and settings are commonly stored in register circuits. These register contents have to be initialized at hardware reset to defined default values that are hard coded in the hardware description language (HDL) code of the hardware unit. A common security protection method used to protect register settings from modification by software is to make them write-once. This means the hardware implementation only allows writing to such registers once, and they become read-only after having been written once by software. This is useful to allow initial boot software to configure systems settings to secure values while blocking runtime software from modifying such hardware settings. Implementation issues in hardware design of such controls can expose such registers to a race condition security flaw. For example, consider a hardware design that has two different software/firmware modules executing in parallel. One module is trusted (module A) and another is untrusted (module B). In this design it could be possible for Module B to send write cycles to the write-once register before Module A. Since the field is write-once the programmed value from Module A will be ignored and the pre-empted value programmed by Module B will be used by hardware.",::NATURE:ChildOf:CWE ID:362:VIEW ID:1000:ORDINAL:Primary::,"",::LANGUAGE NAME:Verilog:LANGUAGE PREVALENCE:Undetermined::LANGUAGE NAME:VHDL:LANGUAGE PREVALENCE:Undetermined::TECHNOLOGY CLASS:System on Chip:TECHNOLOGY PREVALENCE:Undetermined::,"","","::PHASE:Architecture and Design:NOTE:This weakness can appear in designs that use register write-once attributes with two or more software/firmware modules with varying levels of trust executing in parallel.::","",,"::SCOPE:Access Control:IMPACT:Bypass Protection Mechanism:NOTE:System configuration cannot be programmed in a secure way.::","","::PHASE:Architecture and Design:DESCRIPTION:During hardware design all register write-once or sticky fields must be evaluated for proper configuration.::PHASE:Testing:DESCRIPTION:The testing phase should use automated tools to test that values are not reprogrammable and that write-once fields lock on writing zeros.::","",,,"",::26::,"",
1224,"Improper Restriction of Write-Once Bit Fields",Base,Incomplete,"The hardware design control register sticky bits or write-once bit fields are improperly implemented, such that they can be reprogrammed by software.","Integrated circuits and hardware IP software programmable controls and settings are commonly stored in register circuits. These register contents have to be initialized at hardware reset to define default values that are hard coded in the hardware description language (HDL) code of the hardware unit. A common security protection method used to protect register settings from modification by software is to make the settings write-once or sticky. This allows writing to such registers only once, whereupon they become read-only. This is useful to allow initial boot software to configure systems settings to secure values while blocking runtime software from modifying such hardware settings. Failure to implement write-once restrictions in hardware design can expose such registers to being re-programmed by software and written multiple times. For example, write-once fields could be implemented to only be write-protected if they have been set to value 1, wherein they would work as write-1-once and not write-once.",::NATURE:ChildOf:CWE ID:284:VIEW ID:1000:ORDINAL:Primary::,"",::LANGUAGE NAME:Verilog:LANGUAGE PREVALENCE:Undetermined::LANGUAGE NAME:VHDL:LANGUAGE PREVALENCE:Undetermined::TECHNOLOGY CLASS:System on Chip:TECHNOLOGY PREVALENCE:Undetermined::,"","","::PHASE:Architecture and Design::PHASE:Implementation:NOTE:Such issues could be introduced during implementation of hardware design, since IP parameters and defaults are defined in HDL code and identified later during Testing or System Configuration phases.::","",,"::SCOPE:Confidentiality:SCOPE:Integrity:SCOPE:Availability:SCOPE:Access Control:IMPACT:Varies by Context:NOTE:System configuration cannot be programmed in a secure way.::","","::PHASE:Architecture and Design:DESCRIPTION:During hardware design all register write-once or sticky fields must be evaluated for proper configuration.::PHASE:Testing:DESCRIPTION:The testing phase should use automated tools to test that values are not reprogrammable and that write-once fields lock on writing zeros.::","",,,"",::680::,"",
1231,"Improper Prevention of Lock Bit Modification",Base,Stable,"The product uses a trusted lock bit for restricting access to registers, address regions, or other resources, but the product does not prevent the value of the lock bit from being modified after it has been set.","In integrated circuits and hardware intellectual property (IP) cores, device configuration controls are commonly programmed after a device power reset by a trusted firmware or software module (e.g., BIOS/bootloader) and then locked from any further modification. This behavior is commonly implemented using a trusted lock bit. When set, the lock bit disables writes to a protected set of registers or address regions. Design or coding errors in the implementation of the lock bit protection feature may allow the lock bit to be modified or cleared by software after it has been set. Attackers might be able to unlock the system and features that the bit is intended to protect.",::NATURE:ChildOf:CWE ID:284:VIEW ID:1000:ORDINAL:Primary::,"::ORDINALITY:Primary::",::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::OPERATING SYSTEM CLASS:Not OS-Specific:OPERATING SYSTEM PREVALENCE:Undetermined::ARCHITECTURE CLASS:Not Architecture-Specific:ARCHITECTURE PREVALENCE:Undetermined::TECHNOLOGY CLASS:Not Technology-Specific:TECHNOLOGY PREVALENCE:Undetermined::,"","","::PHASE:Architecture and Design:NOTE:Such issues could be introduced during hardware architecture and design and identified later during Testing or System Configuration phases.::PHASE:Implementation:NOTE:Such issues could be introduced during implementation and identified later during Testing or System Configuration phases.::","",,"::SCOPE:Access Control:IMPACT:Modify Memory:LIKELIHOOD:High:NOTE:Registers protected by lock bit can be modified even when lock is set.::","::METHOD:Manual Analysis:DESCRIPTION:Set the lock bit. Power cycle the device. Attempt to clear the lock bit. If the information is changed, implement a design fix. Retest. Also, attempt to indirectly clear the lock bit or bypass it.:EFFECTIVENESS:High::","::PHASE:Architecture and Design Implementation Testing:DESCRIPTION:Security lock bit protections must be reviewed for design inconsistency and common weaknesses. Security lock programming flow and lock properties must be tested in pre-silicon and post-silicon testing.:EFFECTIVENESS:High::","::REFERENCE:CVE-2017-6283:DESCRIPTION:chip reset clears critical read/write lock permissions for RSA function:LINK:https://www.cve.org/CVERecord?id=CVE-2017-6283::",,,"",::680::,"",
1232,"Improper Lock Behavior After Power State Transition",Base,Incomplete,"Register lock bit protection disables changes to system configuration once the bit is set. Some of the protected registers or lock bits become programmable after power state transitions (e.g., Entry and wake from low power sleep modes) causing the system configuration to be changeable.","Devices may allow device configuration controls which need to be programmed after device power reset via a trusted firmware or software module (commonly set by BIOS/bootloader) and then locked from any further modification. This action is commonly implemented using a programmable lock bit, which, when set, disables writes to a protected set of registers or address regions. After a power state transition, the lock bit is set to unlocked. Some common weaknesses that can exist in such a protection scheme are that the lock gets cleared, the values of the protected registers get reset, or the lock become programmable.",::NATURE:ChildOf:CWE ID:667:VIEW ID:1000:ORDINAL:Primary::,"",::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::OPERATING SYSTEM CLASS:Not OS-Specific:OPERATING SYSTEM PREVALENCE:Undetermined::ARCHITECTURE CLASS:Not Architecture-Specific:ARCHITECTURE PREVALENCE:Undetermined::TECHNOLOGY CLASS:Not Technology-Specific:TECHNOLOGY PREVALENCE:Undetermined::,"","","::PHASE:Architecture and Design::PHASE:Implementation::","",,"::SCOPE:Access Control:IMPACT:Modify Memory:LIKELIHOOD:High::","","::PHASE:Architecture and Design Implementation Testing:DESCRIPTION:Security Lock bit protections should be reviewed for behavior across supported power state transitions. Security lock programming flow and lock properties should be tested in pre-silicon and post-silicon testing including testing across power transitions.:EFFECTIVENESS:High::","",,,"",::166::,"",
1233,"Security-Sensitive Hardware Controls with Missing Lock Bit Protection",Base,Stable,"The product uses a register lock bit protection mechanism, but it does not ensure that the lock bit prevents modification of system registers or controls that perform changes to important hardware system configuration.","Integrated circuits and hardware intellectual properties (IPs) might provide device configuration controls that need to be programmed after device power reset by a trusted firmware or software module, commonly set by BIOS/bootloader. After reset, there can be an expectation that the controls cannot be used to perform any further modification. This behavior is commonly implemented using a trusted lock bit, which can be set to disable writes to a protected set of registers or address regions. The lock protection is intended to prevent modification of certain system configuration (e.g., memory/memory protection unit configuration). However, if the lock bit does not effectively write-protect all system registers or controls that could modify the protected system configuration, then an adversary may be able to use software to access the registers/controls and modify the protected hardware configuration.",::NATURE:ChildOf:CWE ID:284:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:667:VIEW ID:1000::,"::ORDINALITY:Primary::",::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::OPERATING SYSTEM CLASS:Not OS-Specific:OPERATING SYSTEM PREVALENCE:Undetermined::ARCHITECTURE CLASS:Not Architecture-Specific:ARCHITECTURE PREVALENCE:Undetermined::TECHNOLOGY CLASS:Not Technology-Specific:TECHNOLOGY PREVALENCE:Undetermined::,"","","::PHASE:Architecture and Design:NOTE:Such issues could be introduced during hardware architecture and design and identified later during Testing or System Configuration phases.::PHASE:Implementation:NOTE:Such issues could be introduced during implementation and identified later during Testing or System Configuration phases.::","",,"::SCOPE:Access Control:IMPACT:Modify Memory:NOTE:System Configuration protected by the lock bit can be modified even when the lock is set.::","::METHOD:Manual Analysis:DESCRIPTION:Set the lock bit. Attempt to modify the information protected by the lock bit. If the information is changed, implement a design fix. Retest. Also, attempt to indirectly clear the lock bit or bypass it.:EFFECTIVENESS:High::","::PHASE:Architecture and Design Implementation Testing:DESCRIPTION:Security lock bit protections must be reviewed for design inconsistency and common weaknesses. Security lock programming flow and lock properties must be tested in pre-silicon and post-silicon testing.::","::REFERENCE:CVE-2018-9085:DESCRIPTION:Certain servers leave a write protection lock bit unset after boot, potentially allowing modification of parts of flash memory.:LINK:https://www.cve.org/CVERecord?id=CVE-2018-9085::REFERENCE:CVE-2014-8273:DESCRIPTION:Chain: chipset has a race condition (CWE-362) between when an interrupt handler detects an attempt to write-enable the BIOS (in violation of the lock bit), and when the handler resets the write-enable bit back to 0, allowing attackers to issue BIOS writes during the timing window [REF-1237].:LINK:https://www.cve.org/CVERecord?id=CVE-2014-8273::",,,"",::176::680::,"",
1234,"Hardware Internal or Debug Modes Allow Override of Locks",Base,Incomplete,"System configuration protection may be bypassed during debug mode.","Device configuration controls are commonly programmed after a device power reset by a trusted firmware or software module (e.g., BIOS/bootloader) and then locked from any further modification. This is commonly implemented using a trusted lock bit, which when set, disables writes to a protected set of registers or address regions. The lock protection is intended to prevent modification of certain system configuration (e.g., memory/memory protection unit configuration). If debug features supported by hardware or internal modes/system states are supported in the hardware design, modification of the lock protection may be allowed allowing access and modification of configuration information.",::NATURE:ChildOf:CWE ID:667:VIEW ID:1000:ORDINAL:Primary::,"",::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::OPERATING SYSTEM CLASS:Not OS-Specific:OPERATING SYSTEM PREVALENCE:Undetermined::ARCHITECTURE CLASS:Not Architecture-Specific:ARCHITECTURE PREVALENCE:Undetermined::TECHNOLOGY CLASS:Not Technology-Specific:TECHNOLOGY PREVALENCE:Undetermined::,"","","::PHASE:Architecture and Design::PHASE:Implementation::","",,"::SCOPE:Access Control:IMPACT:Bypass Protection Mechanism:LIKELIHOOD:High:NOTE:Bypass of lock bit allows access and modification of system configuration even when the lock bit is set.::","","::PHASE:Architecture and Design Implementation Testing:DESCRIPTION:Security Lock bit protections should be reviewed for any bypass/override modes supported. Any supported override modes either should be removed or protected using authenticated debug modes. Security lock programming flow and lock properties should be tested in pre-silicon and post-silicon testing.:EFFECTIVENESS:High::","",,,"",::176::,"",
1239,"Improper Zeroization of Hardware Register",Variant,Draft,"The hardware product does not properly clear sensitive information from built-in registers when the user of the hardware block changes.","Hardware logic operates on data stored in registers local to the hardware block. Most hardware IPs, including cryptographic accelerators, rely on registers to buffer I/O, store intermediate values, and interface with software. The result of this is that sensitive information, such as passwords or encryption keys, can exist in locations not transparent to the user of the hardware logic. When a different entity obtains access to the IP due to a change in operating mode or conditions, the new entity can extract information belonging to the previous user if no mechanisms are in place to clear register contents. It is important to clear information stored in the hardware if a physical attack on the product is detected, or if the user of the hardware block changes. The process of clearing register contents in a hardware IP is referred to as zeroization in standards for cryptographic hardware modules such as FIPS-140-2 [REF-267].",::NATURE:ChildOf:CWE ID:226:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:226:VIEW ID:1194:ORDINAL:Primary::,"",::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::OPERATING SYSTEM CLASS:Not OS-Specific:OPERATING SYSTEM PREVALENCE:Undetermined::ARCHITECTURE CLASS:Not Architecture-Specific:ARCHITECTURE PREVALENCE:Undetermined::TECHNOLOGY CLASS:System on Chip:TECHNOLOGY PREVALENCE:Undetermined::,"","","::PHASE:Architecture and Design:NOTE:Lack of hardware mechanisms to zeroize or clear registers in the design or specification.::PHASE:Implementation:NOTE:Mechanisms to zeroize and clear registers are in the design but implemented incorrectly.::PHASE:Operation:NOTE:Hardware-provided zeroization mechanisms are not used appropriately by the IP user (ex. firmware), or data remanence issues are not taken into account.::","",,"::SCOPE:Confidentiality:IMPACT:Varies by Context:NOTE:The consequences will depend on the information disclosed due to the vulnerability.::","","::PHASE:Architecture and Design:DESCRIPTION:Every register potentially containing sensitive information must have a policy specifying how and when information is cleared, in addition to clarifying if it is the responsibility of the hardware logic or IP user to initiate the zeroization procedure at the appropriate time.::","",,,"",::150::204::37::545::,"",
1240,"Use of a Cryptographic Primitive with a Risky Implementation",Base,Draft,"To fulfill the need for a cryptographic primitive, the product implements a cryptographic algorithm using a non-standard, unproven, or disallowed/non-compliant cryptographic implementation.","Cryptographic protocols and systems depend on cryptographic primitives (and associated algorithms) as their basic building blocks. Some common examples of primitives are digital signatures, one-way hash functions, ciphers, and public key cryptography; however, the notion of primitive can vary depending on point of view. See Terminology Notes for further explanation of some concepts. Cryptographic primitives are defined to accomplish one very specific task in a precisely defined and mathematically reliable fashion. For example, suppose that for a specific cryptographic primitive (such as an encryption routine), the consensus is that the primitive can only be broken after trying out N different inputs (where the larger the value of N, the stronger the cryptography). For an encryption scheme like AES-256, one would expect N to be so large as to be infeasible to execute in a reasonable amount of time. If a vulnerability is ever found that shows that one can break a cryptographic primitive in significantly less than the expected number of attempts, then that primitive is considered weakened (or sometimes in extreme cases, colloquially it is broken). As a result, anything using this cryptographic primitive would now be considered insecure or risky. Thus, even breaking or weakening a seemingly small cryptographic primitive has the potential to render the whole system vulnerable, due to its reliance on the primitive. A historical example can be found in TLS when using DES. One would colloquially call DES the cryptographic primitive for transport encryption in this version of TLS. In the past, DES was considered strong, because no weaknesses were found in it; importantly, DES has a key length of 56 bits. Trying N=2^56 keys was considered impractical for most actors. Unfortunately, attacking a system with 56-bit keys is now practical via brute force, which makes defeating DES encryption practical. It is now practical for an adversary to read any information sent under this version of TLS and use this information to attack the system. As a result, it can be claimed that this use of TLS is weak, and that any system depending on TLS with DES could potentially render the entire system vulnerable to attack. Cryptographic primitives and associated algorithms are only considered safe after extensive research and review from experienced cryptographers from academia, industry, and government entities looking for any possible flaws. Furthermore, cryptographic primitives and associated algorithms are frequently reevaluated for safety when new mathematical and attack techniques are discovered. As a result and over time, even well-known cryptographic primitives can lose their compliance status with the discovery of novel attacks that might either defeat the algorithm or reduce its robustness significantly. If ad-hoc cryptographic primitives are implemented, it is almost certain that the implementation will be vulnerable to attacks that are well understood by cryptographers, resulting in the exposure of sensitive information and other consequences. This weakness is even more difficult to manage for hardware-implemented deployment of cryptographic algorithms. First, because hardware is not patchable as easily as software, any flaw discovered after release and production typically cannot be fixed without a recall of the product. Secondly, the hardware product is often expected to work for years, during which time computation power available to the attacker only increases. Therefore, for hardware implementations of cryptographic primitives, it is absolutely essential that only strong, proven cryptographic primitives are used.",::NATURE:ChildOf:CWE ID:327:VIEW ID:1000:ORDINAL:Primary::,"::ORDINALITY:Primary::",::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::OPERATING SYSTEM CLASS:Not OS-Specific:OPERATING SYSTEM PREVALENCE:Undetermined::ARCHITECTURE CLASS:Not Architecture-Specific:ARCHITECTURE PREVALENCE:Undetermined::TECHNOLOGY CLASS:System on Chip:TECHNOLOGY PREVALENCE:Undetermined::,"","","::PHASE:Architecture and Design:NOTE:This weakness is primarily introduced during the architecture and design phase as risky primitives are included.::PHASE:Implementation:NOTE:Even in cases where the Architectural phase properly specifies a cryptographically secure design, the design may be changed during implementation due to unforeseen constraints.::","",,"::SCOPE:Confidentiality:IMPACT:Read Application Data:LIKELIHOOD:High:NOTE:Incorrect usage of crypto primitives could render the supposedly encrypted data as unencrypted plaintext in the worst case.::","::METHOD:Architecture or Design Review:DESCRIPTION:Review requirements, documentation, and product design to ensure that primitives are consistent with the strongest-available recommendations from trusted parties. If the product appears to be using custom or proprietary implementations that have not had sufficient public review and approval, then this is a significant concern.:EFFECTIVENESS:High::METHOD:Manual Analysis:DESCRIPTION:Analyze the product to ensure that implementations for each primitive do not contain any known vulnerabilities and are not using any known-weak algorithms, including MD4, MD5, SHA1, DES, etc.:EFFECTIVENESS:Moderate::METHOD:Dynamic Analysis with Manual Results Interpretation:DESCRIPTION:For hardware, during the implementation (pre-Silicon / post-Silicon) phase, dynamic tests should be done to ensure that outputs from cryptographic routines are indeed working properly, such as test vectors provided by NIST [REF-1236].:EFFECTIVENESS:Moderate::METHOD:Dynamic Analysis with Manual Results Interpretation:DESCRIPTION:It needs to be determined if the output of a cryptographic primitive is lacking entropy, which is one clear sign that something went wrong with the crypto implementation. There exist many methods of measuring the entropy of a bytestream, from sophisticated ones (like calculating Shannon's entropy of a sequence of characters) to crude ones (by compressing it and comparing the size of the original bytestream vs. the compressed - a truly random byte stream should not be compressible and hence the uncompressed and compressed bytestreams should be nearly identical in size).:EFFECTIVENESS:Moderate::","::PHASE:Requirements:DESCRIPTION:Require compliance with the strongest-available recommendations from trusted parties, and require that compliance must be kept up-to-date, since recommendations evolve over time. For example, US government systems require FIPS 140-3 certification, which supersedes FIPS 140-2 [REF-1192] [REF-1226].:EFFECTIVENESS:High::PHASE:Architecture and Design:DESCRIPTION:Ensure that the architecture/design uses the strongest-available primitives and algorithms from trusted parties. For example, US government systems require FIPS 140-3 certification, which supersedes FIPS 140-2 [REF-1192] [REF-1226].:EFFECTIVENESS:High::PHASE:Architecture and Design:DESCRIPTION:Do not develop custom or private cryptographic algorithms. They will likely be exposed to attacks that are well-understood by cryptographers. As with all cryptographic mechanisms, the source code should be available for analysis. If the algorithm may be compromised when attackers find out how it works, then it is especially weak.:EFFECTIVENESS:Discouraged Common Practice::PHASE:Architecture and Design:DESCRIPTION:Try not to use cryptographic algorithms in novel ways or with new modes of operation even when you know it is secure. For example, using SHA-2 chaining to create a 1-time pad for encryption might sound like a good idea, but one should not do this.:EFFECTIVENESS:Discouraged Common Practice::PHASE:Architecture and Design:DESCRIPTION:Ensure that the design can replace one cryptographic primitive or algorithm with another in the next generation (cryptographic agility). Where possible, use wrappers to make the interfaces uniform. This will make it easier to upgrade to stronger algorithms. This is especially important for hardware, which can be more difficult to upgrade quickly than software; design the hardware at a replaceable block level.:EFFECTIVENESS:Defense in Depth::PHASE:Architecture and Design:DESCRIPTION:Do not use outdated or non-compliant cryptography algorithms. Some older algorithms, once thought to require a billion years of computing time, can now be broken in days or hours. This includes MD4, MD5, SHA1, DES, and other algorithms that were once regarded as strong [REF-267].:EFFECTIVENESS:Discouraged Common Practice::PHASE:Architecture and Design Implementation:DESCRIPTION:Do not use a linear-feedback shift register (LFSR) or other legacy methods as a substitute for an accepted and standard Random Number Generator.:EFFECTIVENESS:Discouraged Common Practice::PHASE:Architecture and Design Implementation:DESCRIPTION:Do not use a checksum as a substitute for a cryptographically generated hash.:EFFECTIVENESS:Discouraged Common Practice::PHASE:Architecture and Design:STRATEGY:Libraries or Frameworks:DESCRIPTION:Use a vetted cryptographic library or framework. Industry-standard implementations will save development time and are more likely to avoid errors that can occur during implementation of cryptographic algorithms. However, the library/framework could be used incorrectly during implementation.:EFFECTIVENESS:High::PHASE:Architecture and Design Implementation:DESCRIPTION:When using industry-approved techniques, use them correctly. Don't cut corners by skipping resource-intensive steps (CWE-325). These steps are often essential for the prevention of common attacks.:EFFECTIVENESS:Moderate::PHASE:Architecture and Design Implementation:DESCRIPTION:Do not store keys in areas accessible to untrusted agents. Carefully manage and protect the cryptographic keys (see CWE-320). If the keys can be guessed or stolen, then the strength of the cryptography algorithm is irrelevant.:EFFECTIVENESS:Moderate::","::REFERENCE:CVE-2020-4778:DESCRIPTION:software uses MD5, which is less safe than the default SHA-256 used by related products:LINK:https://www.cve.org/CVERecord?id=CVE-2020-4778::REFERENCE:CVE-2005-2946:DESCRIPTION:Default configuration of product uses MD5 instead of stronger algorithms that are available, simplifying forgery of certificates.:LINK:https://www.cve.org/CVERecord?id=CVE-2005-2946::REFERENCE:CVE-2019-3907:DESCRIPTION:identity card uses MD5 hash of a salt and password:LINK:https://www.cve.org/CVERecord?id=CVE-2019-3907::REFERENCE:CVE-2021-34687:DESCRIPTION:personal key is transmitted over the network using a substitution cipher:LINK:https://www.cve.org/CVERecord?id=CVE-2021-34687::REFERENCE:CVE-2020-14254:DESCRIPTION:product does not disable TLS-RSA cipher suites, allowing decryption of traffic if TLS 2.0 and secure ciphers are not enabled.:LINK:https://www.cve.org/CVERecord?id=CVE-2020-14254::REFERENCE:CVE-2019-1543:DESCRIPTION:SSL/TLS library generates 16-byte nonces but reduces them to 12 byte nonces for the ChaCha20-Poly1305 cipher, converting them in a way that violates the cipher's requirements for unique nonces.:LINK:https://www.cve.org/CVERecord?id=CVE-2019-1543::REFERENCE:CVE-2017-9267:DESCRIPTION:LDAP interface allows use of weak ciphers:LINK:https://www.cve.org/CVERecord?id=CVE-2017-9267::REFERENCE:CVE-2017-7971:DESCRIPTION:SCADA product allows use of outdated cipher suites:LINK:https://www.cve.org/CVERecord?id=CVE-2017-7971::REFERENCE:CVE-2020-6616:DESCRIPTION:Chip implementing Bluetooth uses a low-entropy PRNG instead of a hardware RNG, allowing spoofing.:LINK:https://www.cve.org/CVERecord?id=CVE-2020-6616::REFERENCE:CVE-2019-1715:DESCRIPTION:security product has insufficient entropy in the DRBG, allowing collisions and private key discovery:LINK:https://www.cve.org/CVERecord?id=CVE-2019-1715::REFERENCE:CVE-2014-4192:DESCRIPTION:Dual_EC_DRBG implementation in RSA toolkit does not correctly handle certain byte requests, simplifying plaintext recovery:LINK:https://www.cve.org/CVERecord?id=CVE-2014-4192::REFERENCE:CVE-2007-6755:DESCRIPTION:Recommendation for Dual_EC_DRBG algorithm contains point Q constants that could simplify decryption:LINK:https://www.cve.org/CVERecord?id=CVE-2007-6755::",,,"",::97::,"::TYPE:Terminology:NOTE:Terminology for cryptography varies widely, from informal and colloquial to mathematically-defined, with different precision and formalism depending on whether the stakeholder is a developer, cryptologist, etc. Yet there is a need for CWE to be self-consistent while remaining understandable and acceptable to multiple audiences. As of CWE 4.6, CWE terminology around primitives and algorithms is emerging as shown by the following example, subject to future consultation and agreement within the CWE and cryptography communities. Suppose one wishes to send encrypted data using a CLI tool such as OpenSSL. One might choose to use AES with a 256-bit key and require tamper protection (GCM mode, for instance). For compatibility's sake, one might also choose the ciphertext to be formatted to the PKCS#5 standard. In this case, the cryptographic system would be AES-256-GCM with PKCS#5 formatting. The cryptographic function would be AES-256 in the GCM mode of operation, and the algorithm would be AES. Colloquially, one would say that AES (and sometimes AES-256) is the cryptographic primitive, because it is the algorithm that realizes the concept of symmetric encryption (without modes of operation or other protocol related modifications). In practice, developers and architects typically refer to base cryptographic algorithms (AES, SHA, etc.) as cryptographic primitives.::TYPE:Maintenance:NOTE:Since CWE 4.4, various cryptography-related entries, including CWE-327 and CWE-1240, have been slated for extensive research, analysis, and community consultation to define consistent terminology, improve relationships, and reduce overlap or duplication. As of CWE 4.6, this work is still ongoing.::",
1241,"Use of Predictable Algorithm in Random Number Generator",Base,Draft,"The device uses an algorithm that is predictable and generates a pseudo-random number.","",::NATURE:ChildOf:CWE ID:330:VIEW ID:1000:ORDINAL:Primary::,"",::TECHNOLOGY CLASS:System on Chip:TECHNOLOGY PREVALENCE:Undetermined::,"","","::PHASE:Architecture and Design::PHASE:Implementation:NOTE:In many cases, the design originally defines a cryptographically secure random number generator, but is then changed during implementation due to unforeseen constraints.::","",,"::SCOPE:Confidentiality:IMPACT:Read Application Data:LIKELIHOOD:High::","","::PHASE:Architecture and Design:DESCRIPTION:A true random number generator should be specified for cryptographic algorithms.::PHASE:Implementation:DESCRIPTION:A true random number generator should be implemented for cryptographic algorithms.::","",,,"",::97::,"::TYPE:Maintenance:NOTE:As of CWE 4.5, terminology related to randomness, entropy, and predictability can vary widely. Within the developer and other communities, randomness is used heavily. However, within cryptography, entropy is distinct, typically implied as a measurement. There are no commonly-used definitions, even within standards documents and cryptography papers. Future versions of CWE will attempt to define these terms and, if necessary, distinguish between them in ways that are appropriate for different communities but do not reduce the usability of CWE for mapping, understanding, or other scenarios.::",
1242,"Inclusion of Undocumented Features or Chicken Bits",Base,Incomplete,"The device includes chicken bits or undocumented features that can create entry points for unauthorized actors.","A common design practice is to use undocumented bits on a device that can be used to disable certain functional security features. These bits are commonly referred to as chicken bits. They can facilitate quick identification and isolation of faulty components, features that negatively affect performance, or features that do not provide the required controllability for debug and test. Another way to achieve this is through implementation of undocumented features. An attacker might exploit these interfaces for unauthorized access.",::NATURE:ChildOf:CWE ID:284:VIEW ID:1000:ORDINAL:Primary::,"",::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::OPERATING SYSTEM CLASS:Not OS-Specific:OPERATING SYSTEM PREVALENCE:Undetermined::ARCHITECTURE CLASS:Not Architecture-Specific:ARCHITECTURE PREVALENCE:Undetermined::TECHNOLOGY CLASS:Not Technology-Specific:TECHNOLOGY PREVALENCE:Undetermined::TECHNOLOGY CLASS:ICS/OT:TECHNOLOGY PREVALENCE:Undetermined::,"","","::PHASE:Architecture and Design::PHASE:Implementation::PHASE:Documentation::","",,"::SCOPE:Confidentiality:SCOPE:Integrity:SCOPE:Availability:SCOPE:Access Control:IMPACT:Modify Memory:IMPACT:Read Memory:IMPACT:Execute Unauthorized Code or Commands:IMPACT:Gain Privileges or Assume Identity:IMPACT:Bypass Protection Mechanism::","","::PHASE:Architecture and Design Implementation:DESCRIPTION:The implementation of chicken bits in a released product is highly discouraged. If implemented at all, ensure that they are disabled in production devices. All interfaces to a device should be documented.:EFFECTIVENESS:High::","",,,"",::212::36::,"",
1243,"Sensitive Non-Volatile Information Not Protected During Debug",Base,Incomplete,"Access to security-sensitive information stored in fuses is not limited during debug.","Several security-sensitive values are programmed into fuses to be used during early-boot flows or later at runtime. Examples of these security-sensitive values include root keys, encryption keys, manufacturing-specific information, chip-manufacturer-specific information, and original-equipment-manufacturer (OEM) data. After the chip is powered on, these values are sensed from fuses and stored in temporary locations such as registers and local memories. These locations are typically access-control protected from untrusted agents capable of accessing them. Even to trusted agents, only read-access is provided. However, these locations are not blocked during debug operations, allowing a user to access this sensitive information.",::NATURE:ChildOf:CWE ID:1263:VIEW ID:1000:ORDINAL:Primary::,"",::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::OPERATING SYSTEM CLASS:Not OS-Specific:OPERATING SYSTEM PREVALENCE:Undetermined::ARCHITECTURE CLASS:Not Architecture-Specific:ARCHITECTURE PREVALENCE:Undetermined::TECHNOLOGY CLASS:Not Technology-Specific:TECHNOLOGY PREVALENCE:Undetermined::,"","","::PHASE:Architecture and Design::PHASE:Implementation::","",,"::SCOPE:Confidentiality:SCOPE:Access Control:IMPACT:Modify Memory:IMPACT:Bypass Protection Mechanism::","","::PHASE:Architecture and Design Implementation:DESCRIPTION:Disable access to security-sensitive information stored in fuses directly and also reflected from temporary storage locations when in debug mode.::","",,,"",::116::545::,"",
1244,"Internal Asset Exposed to Unsafe Debug Access Level or State",Base,Stable,"The product uses physical debug or test interfaces with support for multiple access levels, but it assigns the wrong debug access level to an internal asset, providing unintended access to the asset from untrusted debug agents.","Debug authorization can have multiple levels of access, defined such that different system internal assets are accessible based on the current authorized debug level. Other than debugger authentication (e.g., using passwords or challenges), the authorization can also be based on the system state or boot stage. For example, full system debug access might only be allowed early in boot after a system reset to ensure that previous session data is not accessible to the authenticated debugger. If this protection mechanism does not ensure that internal assets have the correct debug access level during each boot stage or change in system state, an attacker could obtain sensitive information from the internal asset using a debugger.",::NATURE:ChildOf:CWE ID:863:VIEW ID:1000:ORDINAL:Primary::,"::ORDINALITY:Primary::",::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::OPERATING SYSTEM CLASS:Not OS-Specific:OPERATING SYSTEM PREVALENCE:Undetermined::ARCHITECTURE CLASS:Not Architecture-Specific:ARCHITECTURE PREVALENCE:Undetermined::TECHNOLOGY CLASS:System on Chip:TECHNOLOGY PREVALENCE:Undetermined::,"","","::PHASE:Architecture and Design::PHASE:Implementation::","",,"::SCOPE:Confidentiality:IMPACT:Read Memory::SCOPE:Integrity:IMPACT:Modify Memory::SCOPE:Authorization:SCOPE:Access Control:IMPACT:Gain Privileges or Assume Identity:IMPACT:Bypass Protection Mechanism::","::METHOD:Manual Analysis:DESCRIPTION:Check 2 devices for their passcode to authenticate access to JTAG/debugging ports. If the passcodes are missing or the same, update the design to fix and retest. Check communications over JTAG/debugging ports for encryption. If the communications are not encrypted, fix the design and retest.:EFFECTIVENESS:Moderate::","::PHASE:Architecture and Design Implementation:DESCRIPTION:For security-sensitive assets accessible over debug/test interfaces, only allow trusted agents.:EFFECTIVENESS:High::PHASE:Architecture and Design:DESCRIPTION:Apply blinding [REF-1219] or masking techniques in strategic areas.:EFFECTIVENESS:Limited::PHASE:Implementation:DESCRIPTION:Add shielding or tamper-resistant protections to the device, which increases the difficulty and cost for accessing debug/test interfaces.:EFFECTIVENESS:Limited::","::REFERENCE:CVE-2019-18827:DESCRIPTION:After ROM code execution, JTAG access is disabled. But before the ROM code is executed, JTAG access is possible, allowing a user full system access. This allows a user to modify the boot flow and successfully bypass the secure-boot process.:LINK:https://www.cve.org/CVERecord?id=CVE-2019-18827::",,,"",::114::,"::TYPE:Relationship:NOTE:CWE-1191 and CWE-1244 both involve physical debug access, but the weaknesses are different. CWE-1191 is effectively about missing authorization for a debug interface, i.e. JTAG. CWE-1244 is about providing internal assets with the wrong debug access level, exposing the asset to untrusted debug agents.::",
1245,"Improper Finite State Machines (FSMs) in Hardware Logic",Base,Incomplete,"Faulty finite state machines (FSMs) in the hardware logic allow an attacker to put the system in an undefined state, to cause a denial of service (DoS) or gain privileges on the victim's system.","The functionality and security of the system heavily depend on the implementation of FSMs. FSMs can be used to indicate the current security state of the system. Lots of secure data operations and data transfers rely on the state reported by the FSM. Faulty FSM designs that do not account for all states, either through undefined states (left as don't cares) or through incorrect implementation, might lead an attacker to drive the system into an unstable state from which the system cannot recover without a reset, thus causing a DoS. Depending on what the FSM is used for, an attacker might also gain additional privileges to launch further attacks and compromise the security guarantees.",::NATURE:ChildOf:CWE ID:684:VIEW ID:1000:ORDINAL:Primary::,"",::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::OPERATING SYSTEM CLASS:Not OS-Specific:OPERATING SYSTEM PREVALENCE:Undetermined::ARCHITECTURE CLASS:Not Architecture-Specific:ARCHITECTURE PREVALENCE:Undetermined::TECHNOLOGY CLASS:System on Chip:TECHNOLOGY PREVALENCE:Undetermined::,"","","::PHASE:Architecture and Design::PHASE:Implementation::","",,"::SCOPE:Availability:SCOPE:Access Control:IMPACT:Unexpected State:IMPACT:DoS: Crash, Exit, or Restart:IMPACT:DoS: Instability:IMPACT:Gain Privileges or Assume Identity::","","::PHASE:Architecture and Design Implementation:DESCRIPTION:Define all possible states and handle all unused states through default statements. Ensure that system defaults to a secure state.:EFFECTIVENESS:High::","",,,"",::74::,"",
1246,"Improper Write Handling in Limited-write Non-Volatile Memories",Base,Incomplete,"The product does not implement or incorrectly implements wear leveling operations in limited-write non-volatile memories.","Non-volatile memories such as NAND Flash, EEPROM, etc. have individually erasable segments, each of which can be put through a limited number of program/erase or write cycles. For example, the device can only endure a limited number of writes, after which the device becomes unreliable. In order to wear out the cells in a uniform manner, non-volatile memory and storage products based on the above-mentioned technologies implement a technique called wear leveling. Once a set threshold is reached, wear leveling maps writes of a logical block to a different physical block. This prevents a single physical block from prematurely failing due to a high concentration of writes. If wear leveling is improperly implemented, attackers may be able to programmatically cause the storage to become unreliable within a much shorter time than would normally be expected.",::NATURE:ChildOf:CWE ID:400:VIEW ID:1000:ORDINAL:Primary::,"",::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::OPERATING SYSTEM CLASS:Not OS-Specific:OPERATING SYSTEM PREVALENCE:Undetermined::ARCHITECTURE CLASS:Not Architecture-Specific:ARCHITECTURE PREVALENCE:Undetermined::TECHNOLOGY CLASS:System on Chip:TECHNOLOGY PREVALENCE:Undetermined::TECHNOLOGY NAME:Memory Hardware:TECHNOLOGY PREVALENCE:Undetermined::TECHNOLOGY NAME:Storage Hardware:TECHNOLOGY PREVALENCE:Undetermined::,"","","::PHASE:Architecture and Design::PHASE:Implementation::","",,"::SCOPE:Availability:IMPACT:DoS: Instability::","","::PHASE:Architecture and Design Implementation Testing:DESCRIPTION:Include secure wear leveling algorithms and ensure they may not be bypassed.:EFFECTIVENESS:High::","",,,"",::212::,"",
1247,"Improper Protection Against Voltage and Clock Glitches",Base,Stable,"The device does not contain or contains incorrectly implemented circuitry or sensors to detect and mitigate voltage and clock glitches and protect sensitive information or software contained on the device.","A device might support features such as secure boot which are supplemented with hardware and firmware support. This involves establishing a chain of trust, starting with an immutable root of trust by checking the signature of the next stage (culminating with the OS and runtime software) against a golden value before transferring control. The intermediate stages typically set up the system in a secure state by configuring several access control settings. Similarly, security logic for exercising a debug or testing interface may be implemented in hardware, firmware, or both. A device needs to guard against fault attacks such as voltage glitches and clock glitches that an attacker may employ in an attempt to compromise the system.",::NATURE:ChildOf:CWE ID:1384:VIEW ID:1000:ORDINAL:Primary::,"::ORDINALITY:Primary::",::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::OPERATING SYSTEM CLASS:Not OS-Specific:OPERATING SYSTEM PREVALENCE:Undetermined::ARCHITECTURE CLASS:Not Architecture-Specific:ARCHITECTURE PREVALENCE:Undetermined::TECHNOLOGY CLASS:ICS/OT:TECHNOLOGY PREVALENCE:Undetermined::TECHNOLOGY CLASS:System on Chip:TECHNOLOGY PREVALENCE:Undetermined::TECHNOLOGY NAME:Power Management Hardware:TECHNOLOGY PREVALENCE:Undetermined::TECHNOLOGY NAME:Clock/Counter Hardware:TECHNOLOGY PREVALENCE:Undetermined::TECHNOLOGY NAME:Sensor Hardware:TECHNOLOGY PREVALENCE:Undetermined::,"","","::PHASE:Operation::","",,"::SCOPE:Confidentiality:SCOPE:Integrity:SCOPE:Availability:SCOPE:Access Control:IMPACT:Gain Privileges or Assume Identity:IMPACT:Bypass Protection Mechanism:IMPACT:Read Memory:IMPACT:Modify Memory:IMPACT:Execute Unauthorized Code or Commands::","::METHOD:Manual Analysis:DESCRIPTION:Put the processor in an infinite loop, which is then followed by instructions that should not ever be executed, since the loop is not expected to exit. After the loop, toggle an I/O bit (for oscilloscope monitoring purposes), print a console message, and reenter the loop. Note that to ensure that the loop exit is actually captured, many NOP instructions should be coded after the loop branch instruction and before the I/O bit toggle and the print statement. Margining the clock consists of varying the clock frequency until an anomaly occurs. This could be a continuous frequency change or it could be a single cycle. The single cycle method is described here. For every 1000th clock pulse, the clock cycle is shortened by 10 percent. If no effect is observed, the width is shortened by 20%. This process is continued in 10% increments up to and including 50%. Note that the cycle time may be increased as well, down to seconds per cycle. Separately, the voltage is margined. Note that the voltage could be increased or decreased. Increasing the voltage has limits, as the circuitry may not be able to withstand a drastically increased voltage. This process starts with a 5% reduction of the DC supply to the CPU chip for 5 millisecond repeated at 1KHz. If this has no effect, the process is repeated, but a 10% reduction is used. This process is repeated at 10% increments down to a 50% reduction. If no effects are observed at 5 millisecond, the whole process is repeated using a 10 millisecond pulse. If no effects are observed, the process is repeated in 10 millisecond increments out to 100 millisecond pulses. While these are suggested starting points for testing circuitry for weaknesses, the limits may need to be pushed further at the risk of device damage. See [REF-1217] for descriptions of Smart Card attacks against a clock (section 14.6.2) and using a voltage glitch (section 15.5.3).:EFFECTIVENESS:Moderate::METHOD:Dynamic Analysis with Manual Results Interpretation:DESCRIPTION:During the implementation phase where actual hardware is available, specialized hardware tools and apparatus such as ChipWhisperer may be used to check if the platform is indeed susceptible to voltage and clock glitching attacks.::METHOD:Architecture or Design Review:DESCRIPTION:Review if the protections against glitching merely transfer the attack target. For example, suppose a critical authentication routine that an attacker would want to bypass is given the protection of modifying certain artifacts from within that specific routine (so that if the routine is bypassed, one can examine the artifacts and figure out that an attack must have happened). However, if the attacker has the ability to bypass the critical authentication routine, they might also have the ability to bypass the other protection routine that checks the artifacts. Basically, depending on these kind of protections is akin to resorting to Security by Obscurity.::METHOD:Architecture or Design Review:DESCRIPTION:Many SoCs come equipped with a built-in Dynamic Voltage and Frequency Scaling (DVFS) that can control the voltage and clocks via software alone. However, there have been demonstrated attacks (like Plundervolt and CLKSCREW) that target this DVFS [REF-1081] [REF-1082]. During the design and implementation phases, one needs to check if the interface to this power management feature is available from unprivileged SW (CWE-1256), which would make the attack very easy.::","::PHASE:Architecture and Design Implementation:DESCRIPTION:At the circuit-level, using Tunable Replica Circuits (TRCs) or special flip-flops such as Razor flip-flops helps mitigate glitch attacks. Working at the SoC or platform base, level sensors may be implemented to detect glitches. Implementing redundancy in security-sensitive code (e.g., where checks are performed)also can help with mitigation of glitch attacks.::","::REFERENCE:CVE-2019-17391:DESCRIPTION:Lack of anti-glitch protections allows an attacker to launch a physical attack to bypass the secure boot and read protected eFuses.:LINK:https://www.cve.org/CVERecord?id=CVE-2019-17391::",::Power::Clock::,,"",::624::625::,"",
1248,"Semiconductor Defects in Hardware Logic with Security-Sensitive Implications",Base,Incomplete,"The security-sensitive hardware module contains semiconductor defects.","A semiconductor device can fail for various reasons. While some are manufacturing and packaging defects, the rest are due to prolonged use or usage under extreme conditions. Some mechanisms that lead to semiconductor defects include encapsulation failure, die-attach failure, wire-bond failure, bulk-silicon defects, oxide-layer faults, aluminum-metal faults (including electromigration, corrosion of aluminum, etc.), and thermal/electrical stress. These defects manifest as faults on chip-internal signals or registers, have the effect of inputs, outputs, or intermediate signals being always 0 or always 1, and do not switch as expected. If such faults occur in security-sensitive hardware modules, security guarantees offered by the device will be compromised.",::NATURE:ChildOf:CWE ID:693:VIEW ID:1000:ORDINAL:Primary::,"",::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::OPERATING SYSTEM CLASS:Not OS-Specific:OPERATING SYSTEM PREVALENCE:Undetermined::ARCHITECTURE CLASS:Not Architecture-Specific:ARCHITECTURE PREVALENCE:Undetermined::TECHNOLOGY CLASS:Not Technology-Specific:TECHNOLOGY PREVALENCE:Undetermined::,"","","::PHASE:Manufacturing:NOTE:May be introduced due to issues in the manufacturing environment or improper handling of components, for example.::PHASE:Operation:NOTE:May be introduced by improper handling or usage outside of rated operating environments (temperature, humidity, etc.)::","",,"::SCOPE:Availability:SCOPE:Access Control:IMPACT:DoS: Instability::","","::PHASE:Testing:DESCRIPTION:While semiconductor-manufacturing companies implement several mechanisms to continuously improve the semiconductor manufacturing process to ensure reduction of defects, some defects can only be fixed after manufacturing. Post-manufacturing testing of silicon die is critical. Fault models such as stuck-at-0 or stuck-at-1 must be used to develop post-manufacturing test cases and achieve good coverage. Once the silicon packaging is done, extensive post-silicon testing must be performed to ensure that hardware logic implementing security functionalities is defect-free.::PHASE:Operation:DESCRIPTION:Operating the hardware outside device specification, such as at extremely high temperatures, voltage, etc., accelerates semiconductor degradation and results in defects. When these defects manifest as faults in security-critical, hardware modules, it results in compromise of security guarantees. Thus, operating the device within the specification is important.::","",,,"",::624::625::,"",
1250,"Improper Preservation of Consistency Between Independent Representations of Shared State",Base,Incomplete,"The product has or supports multiple distributed components or sub-systems that are each required to keep their own local copy of shared data - such as state or cache - but the product does not ensure that all local copies remain consistent with each other.","In highly distributed environments, or on systems with distinct physical components that operate independently, there is often a need for each component to store and update its own local copy of key data such as state or cache, so that all components have the same view of the overall system and operate in a coordinated fashion. For example, users of a social media service or a massively multiplayer online game might be using their own personal computers while also interacting with different physical hosts in a globally distributed service, but all participants must be able to have the same view of the world. Alternately, a processor's Memory Management Unit (MMU) might have shadow MMUs to distribute its workload, and all shadow MMUs are expected to have the same accessible ranges of memory. In such environments, it becomes critical for the product to ensure that this shared state is consistently modified across all distributed systems. If state is not consistently maintained across all systems, then critical transactions might take place out of order, or some users might not get the same data as other users. When this inconsistency affects correctness of operations, it can introduce vulnerabilities in mechanisms that depend on consistent state.",::NATURE:ChildOf:CWE ID:664:VIEW ID:1000:ORDINAL:Primary::,"",::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::OPERATING SYSTEM CLASS:Not OS-Specific:OPERATING SYSTEM PREVALENCE:Undetermined::ARCHITECTURE CLASS:Not Architecture-Specific:ARCHITECTURE PREVALENCE:Undetermined::TECHNOLOGY CLASS:Cloud Computing:TECHNOLOGY PREVALENCE:Undetermined::TECHNOLOGY NAME:Security Hardware:TECHNOLOGY PREVALENCE:Undetermined::,"","","","",,"","","","",,,"",,"::TYPE:Research Gap:NOTE:Issues related to state and cache - creation, preservation, and update - are a significant gap in CWE that is expected to be addressed in future versions. It likely has relationships to concurrency and synchronization, incorrect behavior order, and other areas that already have some coverage in CWE, although the focus has typically been on independent processes on the same operating system - not on independent systems that are all a part of a larger system-of-systems.::",
1251,"Mirrored Regions with Different Values",Base,Incomplete,"The product's architecture mirrors regions without ensuring that their contents always stay in sync.","Having mirrored regions with different values might result in the exposure of sensitive information or possibly system compromise. In the interest of increased performance, one might need to duplicate a resource. A cache memory is a common example of this concept, which keeps a local copy of a data element in the high speed cache memory. Unfortunately, this speed improvement comes with a downside, since the product needs to ensure that the local copy always mirrors the original copy truthfully. If they get out of sync, the computational result is no longer true. During hardware design, memory is not the only item which gets mirrored. There are many other entities that get mirrored, as well: registers, memory regions, and, in some cases, even whole computational units. For example, within a multi-core processor, if all memory accesses for each and every core goes through a single Memory-Management Unit (MMU) then the MMU will become a performance bottleneck. In such cases, duplicating local MMUs that will serve only a subset of the cores rather than all of them may resolve the performance issue. These local copies are also called shadow copies or mirrored copies. If the original resource never changed, local duplicate copies getting out of sync would never be an issue. However, the values of the original copy will sometimes change. When the original copy changes, the mirrored copies must also change, and change fast. This situation of shadow-copy-possibly-out-of-sync-with-original-copy might occur as a result of multiple scenarios, including the following: After the values in the original copy change, due to some reason the original copy does not send the update request to its shadow copies. After the values in the original copy change, the original copy dutifully sends the update request to its shadow copies, but due to some reason the shadow copy does not execute this update request. After the values in the original copy change, the original copy sends the update request to its shadow copies, and the shadow copy executes this update request faithfully. However, during the small time period when the original copy has new values and the shadow copy is still holding the old values, an attacker can exploit the old values. Then it becomes a race condition between the attacker and the update process of who can reach the target, shadow copy first, and, if the attacker reaches first, the attacker wins. The attacker might send a spoofed update request to the target shadow copy, pretending that this update request is coming from the original copy. This spoofed request might cause the targeted shadow copy to update its values to some attacker-friendly values, while the original copies remain unchanged by the attacker. Suppose a situation where the original copy has a system of reverting back to its original value if it does not hear back from all the shadow copies that such copies have successfully completed the update request. In such a case, an attack might occur as follows: (1) the original copy might send an update request; (2) the shadow copy updates it; (3) the shadow copy sends back the successful completion message; (4) through a separate issue, the attacker is able to intercept the shadow copy's completion message. In this case, the original copy thinks that the update did not succeed, hence it reverts to its original value. Now there is a situation where the original copy has the old value, and the shadow copy has the new value.",::NATURE:ChildOf:CWE ID:1250:VIEW ID:1000:ORDINAL:Primary::,"",::LANGUAGE NAME:VHDL:LANGUAGE PREVALENCE:Undetermined::LANGUAGE NAME:Verilog:LANGUAGE PREVALENCE:Undetermined::OPERATING SYSTEM CLASS:Not OS-Specific:OPERATING SYSTEM PREVALENCE:Undetermined::ARCHITECTURE CLASS:Not Architecture-Specific:ARCHITECTURE PREVALENCE:Undetermined::TECHNOLOGY CLASS:System on Chip:TECHNOLOGY PREVALENCE:Undetermined::,"","","","",,"::SCOPE:Confidentiality:SCOPE:Integrity:SCOPE:Availability:SCOPE:Access Control:SCOPE:Accountability:SCOPE:Authentication:SCOPE:Authorization:SCOPE:Non-Repudiation:IMPACT:Varies by Context::","","::PHASE:Architecture and Design:DESCRIPTION:Whenever there are multiple, physically different copies of the same value that might change and the process to update them is not instantaneous and atomic, it is impossible to assert that the original and shadow copies will always be in sync - there will always be a time period when they are out of sync. To mitigate the consequential risk, the recommendations essentially are: Make this out-of-sync time period as small as possible, and Make the update process as robust as possible.:EFFECTIVENESS:Moderate::","",,,"",,"::TYPE:Research Gap:NOTE:Issues related to state and cache - creation, preservation, and update - are a significant gap in CWE that is expected to be addressed in future versions. It has relationships to concurrency and synchronization, incorrect behavior order, and other areas that already have some coverage in CWE, although the focus has typically been on independent processes on the same operating system - not on independent systems that are all a part of a larger system-of-systems.::",
1252,"CPU Hardware Not Configured to Support Exclusivity of Write and Execute Operations",Base,Incomplete,"The CPU is not configured to provide hardware support for exclusivity of write and execute operations on memory. This allows an attacker to execute data from all of memory.","CPUs provide a special bit that supports exclusivity of write and execute operations. This bit is used to segregate areas of memory to either mark them as code (instructions, which can be executed) or data (which should not be executed). In this way, if a user can write to a region of memory, the user cannot execute from that region and vice versa. This exclusivity provided by special hardware bit is leveraged by the operating system to protect executable space. While this bit is available in most modern processors by default, in some CPUs the exclusivity is implemented via a memory-protection unit (MPU) and memory-management unit (MMU) in which memory regions can be carved out with exact read, write, and execute permissions. However, if the CPU does not have an MMU/MPU, then there is no write exclusivity. Without configuring exclusivity of operations via segregated areas of memory, an attacker may be able to inject malicious code onto memory and later execute it.",::NATURE:ChildOf:CWE ID:284:VIEW ID:1000:ORDINAL:Primary::,"",::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::OPERATING SYSTEM CLASS:Not OS-Specific:OPERATING SYSTEM PREVALENCE:Undetermined::ARCHITECTURE CLASS:Not Architecture-Specific:ARCHITECTURE PREVALENCE:Undetermined::TECHNOLOGY NAME:Microcontroller Hardware:TECHNOLOGY PREVALENCE:Undetermined::TECHNOLOGY NAME:Processor Hardware:TECHNOLOGY PREVALENCE:Undetermined::,"","","::PHASE:Architecture and Design::","",,"::SCOPE:Confidentiality:SCOPE:Integrity:IMPACT:Execute Unauthorized Code or Commands::","","::PHASE:Architecture and Design:DESCRIPTION:Implement a dedicated bit that can be leveraged by the Operating System to mark data areas as non-executable. If such a bit is not available in the CPU, implement MMU/MPU (memory management unit / memory protection unit).::PHASE:Integration:DESCRIPTION:If MMU/MPU are not available, then the firewalls need to be implemented in the SoC interconnect to mimic the write-exclusivity operation.::","",,,"",::679::,"",
1253,"Incorrect Selection of Fuse Values",Base,Draft,"The logic level used to set a system to a secure state relies on a fuse being unblown. An attacker can set the system to an insecure state merely by blowing the fuse.","Fuses are often used to store secret data, including security configuration data. When not blown, a fuse is considered to store a logic 0, and, when blown, it indicates a logic 1. Fuses are generally considered to be one-directional, i.e., once blown to logic 1, it cannot be reset to logic 0. However, if the logic used to determine system-security state (by leveraging the values sensed from the fuses) uses negative logic, an attacker might blow the fuse and drive the system to an insecure state.",::NATURE:ChildOf:CWE ID:693:VIEW ID:1000:ORDINAL:Primary::,"",::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::OPERATING SYSTEM CLASS:Not OS-Specific:OPERATING SYSTEM PREVALENCE:Undetermined::ARCHITECTURE CLASS:Not Architecture-Specific:ARCHITECTURE PREVALENCE:Undetermined::TECHNOLOGY CLASS:Not Technology-Specific:TECHNOLOGY PREVALENCE:Undetermined::,"","","::PHASE:Architecture and Design::PHASE:Implementation::","",,"::SCOPE:Access Control:SCOPE:Authorization:IMPACT:Bypass Protection Mechanism:IMPACT:Gain Privileges or Assume Identity::SCOPE:Availability:IMPACT:DoS: Crash, Exit, or Restart::SCOPE:Confidentiality:IMPACT:Read Memory::SCOPE:Integrity:IMPACT:Modify Memory:IMPACT:Execute Unauthorized Code or Commands::","","::PHASE:Architecture and Design:DESCRIPTION:Logic should be designed in a way that blown fuses do not put the product into an insecure state that can be leveraged by an attacker.::","",,,"",::74::,"::TYPE:Maintenance:NOTE:This entry is still under development and will continue to see updates and content improvements.::",
1254,"Incorrect Comparison Logic Granularity",Base,Draft,"The product's comparison logic is performed over a series of steps rather than across the entire string in one operation. If there is a comparison logic failure on one of these steps, the operation may be vulnerable to a timing attack that can result in the interception of the process for nefarious purposes.","Comparison logic is used to compare a variety of objects including passwords, Message Authentication Codes (MACs), and responses to verification challenges. When comparison logic is implemented at a finer granularity (e.g., byte-by-byte comparison) and breaks in the case of a comparison failure, an attacker can exploit this implementation to identify when exactly the failure occurred. With multiple attempts, the attacker may be able to guesses the correct password/response to challenge and elevate their privileges.",::NATURE:ChildOf:CWE ID:208:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:697:VIEW ID:1000::,"",::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::OPERATING SYSTEM CLASS:Not OS-Specific:OPERATING SYSTEM PREVALENCE:Undetermined::ARCHITECTURE CLASS:Not Architecture-Specific:ARCHITECTURE PREVALENCE:Undetermined::TECHNOLOGY CLASS:Not Technology-Specific:TECHNOLOGY PREVALENCE:Undetermined::,"","","::PHASE:Architecture and Design::PHASE:Implementation::","",,"::SCOPE:Confidentiality:SCOPE:Authorization:IMPACT:Bypass Protection Mechanism::","","::PHASE:Implementation:DESCRIPTION:The hardware designer should ensure that comparison logic is implemented so as to compare in one operation instead in smaller chunks.::","::REFERENCE:CVE-2014-0984:DESCRIPTION:The passwordCheck function in SAP Router 721 patch 117, 720 patch 411, 710 patch 029, and earlier terminates validation of a Route Permission Table entry password upon encountering the first incorrect character, which allows remote attackers to obtain passwords via a brute-force attack that relies on timing differences in responses to incorrect password guesses, aka a timing side-channel attack.:LINK:https://www.cve.org/CVERecord?id=CVE-2014-0984::",,,"",::26::,"",
1255,"Comparison Logic is Vulnerable to Power Side-Channel Attacks",Variant,Draft,"A device's real time power consumption may be monitored during security token evaluation and the information gleaned may be used to determine the value of the reference token.","The power consumed by a device may be instrumented and monitored in real time. If the algorithm for evaluating security tokens is not sufficiently robust, the power consumption may vary by token entry comparison against the reference value. Further, if retries are unlimited, the power difference between a good entry and a bad entry may be observed and used to determine whether each entry itself is correct thereby allowing unauthorized parties to calculate the reference value.",::NATURE:ChildOf:CWE ID:1300:VIEW ID:1000:ORDINAL:Primary::NATURE:PeerOf:CWE ID:1259:VIEW ID:1194:ORDINAL:Primary::,"",::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::OPERATING SYSTEM CLASS:Not OS-Specific:OPERATING SYSTEM PREVALENCE:Undetermined::ARCHITECTURE CLASS:Not Architecture-Specific:ARCHITECTURE PREVALENCE:Undetermined::TECHNOLOGY CLASS:Not Technology-Specific:TECHNOLOGY PREVALENCE:Undetermined::,"","","::PHASE:Architecture and Design:NOTE:The design of the algorithm itself may intrinsically allow the power side channel attack to be effective::PHASE:Implementation:NOTE:This weakness may be introduced during implementation despite a robust design that otherwise prevents exploitation::","",,"::SCOPE:Confidentiality:SCOPE:Integrity:SCOPE:Availability:SCOPE:Access Control:SCOPE:Accountability:SCOPE:Authentication:SCOPE:Authorization:SCOPE:Non-Repudiation:IMPACT:Modify Memory:IMPACT:Read Memory:IMPACT:Read Files or Directories:IMPACT:Modify Files or Directories:IMPACT:Execute Unauthorized Code or Commands:IMPACT:Gain Privileges or Assume Identity:IMPACT:Bypass Protection Mechanism:IMPACT:Read Application Data:IMPACT:Modify Application Data:IMPACT:Hide Activities:NOTE:As compromising a security token may result in complete system control, the impacts are relatively universal::","","::PHASE:Architecture and Design:DESCRIPTION:The design phase must consider each check of a security token against a standard and the amount of power consumed during the check of a good token versus a bad token. The alternative is an all at once check where a retry counter is incremented PRIOR to the check.::PHASE:Architecture and Design:DESCRIPTION:Another potential mitigation is to parallelize shifting of secret data (see example 2 below). Note that the wider the bus the more effective the result.::PHASE:Architecture and Design:DESCRIPTION:An additional potential mitigation is to add random data to each crypto operation then subtract it out afterwards. This is highly effective but costly in performance, area, and power consumption. It also requires a random number generator.::PHASE:Implementation:DESCRIPTION:If the architecture is unable to prevent the attack, using filtering components may reduce the ability to implement an attack, however, consideration must be given to the physical removal of the filter elements.::PHASE:Integration:DESCRIPTION:During integration, avoid use of a single secret for an extended period (e.g. frequent key updates). This limits the amount of data compromised but at the cost of complexity of use.::","::REFERENCE:CVE-2020-12788:DESCRIPTION:CMAC verification vulnerable to timing and power attacks.:LINK:https://www.cve.org/CVERecord?id=CVE-2020-12788::",::Power::,,"",::189::,"",
1256,"Improper Restriction of Software Interfaces to Hardware Features",Base,Stable,"The product provides software-controllable device functionality for capabilities such as power and clock management, but it does not properly limit functionality that can lead to modification of hardware memory or register bits, or the ability to observe physical side channels.","It is frequently assumed that physical attacks such as fault injection and side-channel analysis require an attacker to have physical access to the target device. This assumption may be false if the device has improperly secured power management features, or similar features. For mobile devices, minimizing power consumption is critical, but these devices run a wide variety of applications with different performance requirements. Software-controllable mechanisms to dynamically scale device voltage and frequency and monitor power consumption are common features in today's chipsets, but they also enable attackers to mount fault injection and side-channel attacks without having physical access to the device. Fault injection attacks involve strategic manipulation of bits in a device to achieve a desired effect such as skipping an authentication step, elevating privileges, or altering the output of a cryptographic operation. Manipulation of the device clock and voltage supply is a well-known technique to inject faults and is cheap to implement with physical device access. Poorly protected power management features allow these attacks to be performed from software. Other features, such as the ability to write repeatedly to DRAM at a rapid rate from unprivileged software, can result in bit flips in other memory locations (Rowhammer, [REF-1083]). Side channel analysis requires gathering measurement traces of physical quantities such as power consumption. Modern processors often include power metering capabilities in the hardware itself (e.g., Intel RAPL) which if not adequately protected enable attackers to gather measurements necessary for performing side-channel attacks from software.",::NATURE:ChildOf:CWE ID:285:VIEW ID:1000:ORDINAL:Primary::,"::ORDINALITY:Primary::",::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::OPERATING SYSTEM CLASS:Not OS-Specific:OPERATING SYSTEM PREVALENCE:Undetermined::ARCHITECTURE CLASS:Not Architecture-Specific:ARCHITECTURE PREVALENCE:Undetermined::TECHNOLOGY CLASS:Not Technology-Specific:TECHNOLOGY PREVALENCE:Undetermined::TECHNOLOGY NAME:Memory Hardware:TECHNOLOGY PREVALENCE:Undetermined::TECHNOLOGY NAME:Power Management Hardware:TECHNOLOGY PREVALENCE:Undetermined::TECHNOLOGY NAME:Clock/Counter Hardware:TECHNOLOGY PREVALENCE:Undetermined::,"","","::PHASE:Architecture and Design:NOTE:An architect may initiate introduction of this weakness via exacting requirements for software accessible power/clock management requirements::PHASE:Implementation:NOTE:An implementer may introduce this weakness by assuming there are no consequences to unbounded power and clock management for secure components from untrusted ones.::","",,"::SCOPE:Integrity:IMPACT:Modify Memory:IMPACT:Modify Application Data:IMPACT:Bypass Protection Mechanism::","::METHOD:Manual Analysis:DESCRIPTION:Perform a security evaluation of system-level architecture and design with software-aided physical attacks in scope.::METHOD:Automated Dynamic Analysis:DESCRIPTION:Use custom software to change registers that control clock settings or power settings to try to bypass security locks, or repeatedly write DRAM to try to change adjacent locations. This can be effective in extracting or changing data. The drawback is that it cannot be run before manufacturing, and it may require specialized software.:EFFECTIVENESS:Moderate::","::PHASE:Architecture and Design Implementation:DESCRIPTION:Ensure proper access control mechanisms protect software-controllable features altering physical operating conditions such as clock frequency and voltage.::","::REFERENCE:CVE-2019-11157:DESCRIPTION:Plundervolt: Improper conditions check in voltage settings for some Intel(R) Processors may allow a privileged user to potentially enable escalation of privilege and/or information disclosure via local access [REF-1081].:LINK:https://www.cve.org/CVERecord?id=CVE-2019-11157::REFERENCE:CVE-2020-8694:DESCRIPTION:PLATYPUS Attack: Insufficient access control in the Linux kernel driver for some Intel processors allows information disclosure.:LINK:https://www.cve.org/CVERecord?id=CVE-2020-8694::REFERENCE:CVE-2020-8695:DESCRIPTION:Observable discrepancy in the RAPL interface for some Intel processors allows information disclosure.:LINK:https://www.cve.org/CVERecord?id=CVE-2020-8695::REFERENCE:CVE-2020-12912:DESCRIPTION:AMD extension to a Linux service does not require privileged access to the RAPL interface, allowing side-channel attacks.:LINK:https://www.cve.org/CVERecord?id=CVE-2020-12912::REFERENCE:CVE-2015-0565:DESCRIPTION:NaCl in 2015 allowed the CLFLUSH instruction, making Rowhammer attacks possible.:LINK:https://www.cve.org/CVERecord?id=CVE-2015-0565::",::Power::Clock::,,"",::624::625::,"",
1257,"Improper Access Control Applied to Mirrored or Aliased Memory Regions",Base,Incomplete,"Aliased or mirrored memory regions in hardware designs may have inconsistent read/write permissions enforced by the hardware. A possible result is that an untrusted agent is blocked from accessing a memory region but is not blocked from accessing the corresponding aliased memory region.","Hardware product designs often need to implement memory protection features that enable privileged software to define isolated memory regions and access control (read/write) policies. Isolated memory regions can be defined on different memory spaces in a design (e.g. system physical address, virtual address, memory mapped IO). Each memory cell should be mapped and assigned a system address that the core software can use to read/write to that memory. It is possible to map the same memory cell to multiple system addresses such that read/write to any of the aliased system addresses would be decoded to the same memory cell. This is commonly done in hardware designs for redundancy and simplifying address decoding logic. If one of the memory regions is corrupted or faulty, then that hardware can switch to using the data in the mirrored memory region. Memory aliases can also be created in the system address map if the address decoder unit ignores higher order address bits when mapping a smaller address region into the full system address. A common security weakness that can exist in such memory mapping is that aliased memory regions could have different read/write access protections enforced by the hardware such that an untrusted agent is blocked from accessing a memory address but is not blocked from accessing the corresponding aliased memory address. Such inconsistency can then be used to bypass the access protection of the primary memory block and read or modify the protected memory. An untrusted agent could also possibly create memory aliases in the system address map for malicious purposes if it is able to change the mapping of an address region or modify memory region sizes.",::NATURE:ChildOf:CWE ID:284:VIEW ID:1000:ORDINAL:Primary::NATURE:CanPrecede:CWE ID:119:VIEW ID:1000::,"",::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::OPERATING SYSTEM CLASS:Not OS-Specific:OPERATING SYSTEM PREVALENCE:Undetermined::ARCHITECTURE CLASS:Not Architecture-Specific:ARCHITECTURE PREVALENCE:Undetermined::TECHNOLOGY NAME:Memory Hardware:TECHNOLOGY PREVALENCE:Undetermined::TECHNOLOGY NAME:Processor Hardware:TECHNOLOGY PREVALENCE:Undetermined::TECHNOLOGY NAME:Microcontroller Hardware:TECHNOLOGY PREVALENCE:Undetermined::TECHNOLOGY NAME:Network on Chip Hardware:TECHNOLOGY PREVALENCE:Undetermined::TECHNOLOGY CLASS:System on Chip:TECHNOLOGY PREVALENCE:Undetermined::,"","","::PHASE:Architecture and Design::PHASE:Implementation::","",,"::SCOPE:Confidentiality:IMPACT:Read Memory:LIKELIHOOD:High::SCOPE:Integrity:IMPACT:Modify Memory:LIKELIHOOD:High::SCOPE:Availability:IMPACT:DoS: Instability:LIKELIHOOD:High::","","::PHASE:Architecture and Design Implementation:DESCRIPTION:The checks should be applied for consistency access rights between primary memory regions and any mirrored or aliased memory regions. If different memory protection units (MPU) are protecting the aliased regions, their protected range definitions and policies should be synchronized.::PHASE:Architecture and Design Implementation:DESCRIPTION:The controls that allow enabling memory aliases or changing the size of mapped memory regions should only be programmable by trusted software components.::","",,,"",::456::679::,"",
1258,"Exposure of Sensitive System Information Due to Uncleared Debug Information",Base,Draft,"The hardware does not fully clear security-sensitive values, such as keys and intermediate values in cryptographic operations, when debug mode is entered.","Security sensitive values, keys, intermediate steps of cryptographic operations, etc. are stored in temporary registers in the hardware. If these values are not cleared when debug mode is entered they may be accessed by a debugger allowing sensitive information to be accessible by untrusted parties.",::NATURE:ChildOf:CWE ID:212:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:200:VIEW ID:1000::,"",::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::OPERATING SYSTEM CLASS:Not OS-Specific:OPERATING SYSTEM PREVALENCE:Undetermined::ARCHITECTURE CLASS:Not Architecture-Specific:ARCHITECTURE PREVALENCE:Undetermined::TECHNOLOGY CLASS:Not Technology-Specific:TECHNOLOGY PREVALENCE:Undetermined::,"","","::PHASE:Architecture and Design::PHASE:Implementation::","",,"::SCOPE:Confidentiality:IMPACT:Read Memory::SCOPE:Access Control:IMPACT:Bypass Protection Mechanism::","","::PHASE:Architecture and Design:DESCRIPTION:Whenever debug mode is enabled, all registers containing sensitive assets must be cleared.::","",,,"",::150::204::37::545::,"",
1259,"Improper Restriction of Security Token Assignment",Base,Incomplete,"The System-On-A-Chip (SoC) implements a Security Token mechanism to differentiate what actions are allowed or disallowed when a transaction originates from an entity. However, the Security Tokens are improperly protected.","Systems-On-A-Chip (Integrated circuits and hardware engines) implement Security Tokens to differentiate and identify which actions originated from which agent. These actions may be one of the directives: 'read', 'write', 'program', 'reset', 'fetch', 'compute', etc. Security Tokens are assigned to every agent in the System that is capable of generating an action or receiving an action from another agent. Multiple Security Tokens may be assigned to an agent and may be unique based on the agent's trust level or allowed privileges. Since the Security Tokens are integral for the maintenance of security in an SoC, they need to be protected properly. A common weakness afflicting Security Tokens is improperly restricting the assignment to trusted components. Consequently, an improperly protected Security Token may be able to be programmed by a malicious agent (i.e., the Security Token is mutable) to spoof the action as if it originated from a trusted agent.",::NATURE:ChildOf:CWE ID:284:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:1294:VIEW ID:1194:ORDINAL:Primary::,"",::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::OPERATING SYSTEM CLASS:Not OS-Specific:OPERATING SYSTEM PREVALENCE:Undetermined::ARCHITECTURE CLASS:Not Architecture-Specific:ARCHITECTURE PREVALENCE:Undetermined::TECHNOLOGY NAME:Processor HardwareTECHNOLOGY CLASS:Not Technology-Specific:TECHNOLOGY PREVALENCE:Undetermined::TECHNOLOGY CLASS:System on Chip:TECHNOLOGY PREVALENCE:Undetermined::,"","","::PHASE:Architecture and Design::PHASE:Implementation::","",,"::SCOPE:Confidentiality:SCOPE:Integrity:SCOPE:Availability:SCOPE:Access Control:IMPACT:Modify Files or Directories:IMPACT:Execute Unauthorized Code or Commands:IMPACT:Bypass Protection Mechanism:IMPACT:Gain Privileges or Assume Identity:IMPACT:Modify Memory:IMPACT:Modify Memory:IMPACT:DoS: Crash, Exit, or Restart:LIKELIHOOD:High::","","::PHASE:Architecture and Design Implementation:DESCRIPTION:Security Token assignment review checks for design inconsistency and common weaknesses. Security-Token definition and programming flow is tested in both pre-silicon and post-silicon testing.::","",,,"",::121::681::,"::TYPE:Maintenance:NOTE:This entry is still under development and will continue to see updates and content improvements. Currently it is expressed as a general absence of a protection mechanism as opposed to a specific mistake, and the entry's name and description could be interpreted as applying to software.::",
1260,"Improper Handling of Overlap Between Protected Memory Ranges",Base,Stable,"The product allows address regions to overlap, which can result in the bypassing of intended memory protection.","Isolated memory regions and access control (read/write) policies are used by hardware to protect privileged software. Software components are often allowed to change or remap memory region definitions in order to enable flexible and dynamically changeable memory management by system software. If a software component running at lower privilege can program a memory address region to overlap with other memory regions used by software running at higher privilege, privilege escalation may be available to attackers. The memory protection unit (MPU) logic can incorrectly handle such an address overlap and allow the lower-privilege software to read or write into the protected memory region, resulting in privilege escalation attack. An address overlap weakness can also be used to launch a denial of service attack on the higher-privilege software memory regions.",::NATURE:ChildOf:CWE ID:284:VIEW ID:1000:ORDINAL:Primary::NATURE:CanPrecede:CWE ID:119:VIEW ID:1000:ORDINAL:Primary::,"::ORDINALITY:Primary::ORDINALITY:Resultant::",::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::OPERATING SYSTEM CLASS:Not OS-Specific:OPERATING SYSTEM PREVALENCE:Undetermined::ARCHITECTURE CLASS:Not Architecture-Specific:ARCHITECTURE PREVALENCE:Undetermined::TECHNOLOGY NAME:Memory Hardware:TECHNOLOGY PREVALENCE:Undetermined::TECHNOLOGY NAME:Processor Hardware:TECHNOLOGY PREVALENCE:Undetermined::,"","","::PHASE:Architecture and Design:NOTE:Such issues could be introduced during hardware architecture and design or implementation and identified later during the Testing phase.::PHASE:Implementation::","",,"::SCOPE:Confidentiality:SCOPE:Integrity:SCOPE:Availability:IMPACT:Modify Memory:IMPACT:Read Memory:IMPACT:DoS: Instability:LIKELIHOOD:High::","::METHOD:Manual Analysis:DESCRIPTION:Create a high privilege memory block of any arbitrary size. Attempt to create a lower privilege memory block with an overlap of the high privilege memory block. If the creation attempt works, fix the hardware. Repeat the test.:EFFECTIVENESS:High::","::PHASE:Architecture and Design:DESCRIPTION:Ensure that memory regions are isolated as intended and that access control (read/write) policies are used by hardware to protect privileged software.::PHASE:Implementation:DESCRIPTION:For all of the programmable memory protection regions, the memory protection unit (MPU) design can define a priority scheme. For example: if three memory regions can be programmed (Region_0, Region_1, and Region_2), the design can enforce a priority scheme, such that, if a system address is within multiple regions, then the region with the lowest ID takes priority and the access-control policy of that region will be applied. In some MPU designs, the priority scheme can also be programmed by trusted software. Hardware logic or trusted firmware can also check for region definitions and block programming of memory regions with overlapping addresses. The memory-access-control-check filter can also be designed to apply a policy filter to all of the overlapping ranges, i.e., if an address is within Region_0 and Region_1, then access to this address is only granted if both Region_0 and Region_1 policies allow the access.:EFFECTIVENESS:High::","::REFERENCE:CVE-2008-7096:DESCRIPTION:virtualization product allows compromise of hardware product by accessing certain remapping registers.:LINK:https://www.cve.org/CVERecord?id=CVE-2008-7096::REFERENCE:[REF-1100]:DESCRIPTION:processor design flaw allows ring 0 code to access more privileged rings by causing a register window to overlap a range of protected system RAM [REF-1100]:LINK:https://github.com/xoreaxeaxeax/sinkhole/blob/master/us-15-Domas-TheMemorySinkhole-wp.pdf::",,,"",::456::679::,"::TYPE:Maintenance:NOTE:As of CWE 4.6, CWE-1260 and CWE-1316 are siblings under view 1000, but CWE-1260 might be a parent of CWE-1316. More analysis is warranted.::",
1261,"Improper Handling of Single Event Upsets",Base,Draft,"The hardware logic does not effectively handle when single-event upsets (SEUs) occur.","Technology trends such as CMOS-transistor down-sizing, use of new materials, and system-on-chip architectures continue to increase the sensitivity of systems to soft errors. These errors are random, and their causes might be internal (e.g., interconnect coupling) or external (e.g., cosmic radiation). These soft errors are not permanent in nature and cause temporary bit flips known as single-event upsets (SEUs). SEUs are induced errors in circuits caused when charged particles lose energy by ionizing the medium through which they pass, leaving behind a wake of electron-hole pairs that cause temporary failures. If these failures occur in security-sensitive modules in a chip, it might compromise the security guarantees of the chip. For instance, these temporary failures could be bit flips that change the privilege of a regular user to root.",::NATURE:ChildOf:CWE ID:1384:VIEW ID:1000:ORDINAL:Primary::NATURE:PeerOf:CWE ID:1254:VIEW ID:1000:ORDINAL:Primary::,"",::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::OPERATING SYSTEM CLASS:Not OS-Specific:OPERATING SYSTEM PREVALENCE:Undetermined::ARCHITECTURE CLASS:Not Architecture-Specific:ARCHITECTURE PREVALENCE:Undetermined::TECHNOLOGY CLASS:Not Technology-Specific:TECHNOLOGY PREVALENCE:Undetermined::,"","","::PHASE:Architecture and Design::PHASE:Implementation::","",,"::SCOPE:Availability:SCOPE:Access Control:IMPACT:DoS: Crash, Exit, or Restart:IMPACT:DoS: Instability:IMPACT:Gain Privileges or Assume Identity:IMPACT:Bypass Protection Mechanism::","","::PHASE:Architecture and Design:DESCRIPTION:Implement triple-modular redundancy around security-sensitive modules.::PHASE:Architecture and Design:DESCRIPTION:SEUs mostly affect SRAMs. For SRAMs storing security-critical data, implement Error-Correcting-Codes (ECC) and Address Interleaving.::","",,,"",,"",
1262,"Improper Access Control for Register Interface",Base,Stable,"The product uses memory-mapped I/O registers that act as an interface to hardware functionality from software, but there is improper access control to those registers.","Software commonly accesses peripherals in a System-on-Chip (SoC) or other device through a memory-mapped register interface. Malicious software could tamper with any security-critical hardware data that is accessible directly or indirectly through the register interface, which could lead to a loss of confidentiality and integrity.",::NATURE:ChildOf:CWE ID:284:VIEW ID:1000:ORDINAL:Primary::,"::ORDINALITY:Primary::",::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::OPERATING SYSTEM CLASS:Not OS-Specific:OPERATING SYSTEM PREVALENCE:Undetermined::ARCHITECTURE CLASS:Not Architecture-Specific:ARCHITECTURE PREVALENCE:Undetermined::TECHNOLOGY CLASS:Not Technology-Specific:TECHNOLOGY PREVALENCE:Undetermined::,"","","::PHASE:Architecture and Design:NOTE:This weakness may be exploited if the register interface design does not adequately protect hardware assets from software.::PHASE:Implementation:NOTE:Mis-implementation of access control policies may inadvertently allow access to hardware assets through the register interface.::","",,"::SCOPE:Confidentiality:SCOPE:Integrity:IMPACT:Read Memory:IMPACT:Read Application Data:IMPACT:Modify Memory:IMPACT:Modify Application Data:IMPACT:Gain Privileges or Assume Identity:IMPACT:Bypass Protection Mechanism:IMPACT:Unexpected State:IMPACT:Alter Execution Logic:NOTE:Confidentiality of hardware assets may be violated if the protected information can be read out by software through the register interface. Registers storing security state, settings, other security-critical data may be corruptible by software without correctly implemented protections.::","::METHOD:Manual Analysis:DESCRIPTION:This is applicable in the Architecture phase before implementation started. Make sure access policy is specified for the entire memory map. Manual analysis may not ensure the implementation is correct.:EFFECTIVENESS:Moderate::METHOD:Manual Analysis:DESCRIPTION:Registers controlling hardware should have access control implemented. This access control may be checked manually for correct implementation. Items to check consist of how are trusted parties set, how are trusted parties verified, how are accesses verified, etc. Effectiveness of a manual analysis will vary depending upon how complicated the interface is constructed.:EFFECTIVENESS:Moderate::METHOD:Simulation / Emulation:DESCRIPTION:Functional simulation is applicable during the Implementation Phase. Testcases must be created and executed for memory mapped registers to verify adherence to the access control policy. This method can be effective, since functional verification needs to be performed on the design, and verification for this weakness will be included. There can be difficulty covering the entire memory space during the test.:EFFECTIVENESS:Moderate::METHOD:Formal Verification:DESCRIPTION:Formal verification is applicable during the Implementation phase. Assertions need to be created in order to capture illegal register access scenarios and prove that they cannot occur. Formal methods are exhaustive and can be very effective, but creating the cases for large designs may be complex and difficult.:EFFECTIVENESS:High::METHOD:Automated Analysis:DESCRIPTION:Information flow tracking can be applicable during the Implementation phase. Security sensitive data (assets) - for example, as stored in registers - is automatically tracked over time through the design to verify the data doesn't reach illegal destinations that violate the access policies for the memory map. This method can be very effective when used together with simulation and emulation, since detecting violations doesn't rely on specific scenarios or data values. This method does rely on simulation and emulation, so testcases must exist in order to use this method.:EFFECTIVENESS:High::METHOD:Architecture or Design Review:DESCRIPTION:Manual documentation review of the system memory map, register specification, and permissions associated with accessing security-relevant functionality exposed via memory-mapped registers.:EFFECTIVENESS:Moderate::METHOD:Fuzzing:DESCRIPTION:Perform penetration testing (either manual or semi-automated with fuzzing) to verify that access control mechanisms such as the memory protection units or on-chip bus firewall settings adequately protect critical hardware registers from software access.:EFFECTIVENESS:Moderate::","::PHASE:Architecture and Design:DESCRIPTION:Design proper policies for hardware register access from software.::PHASE:Implementation:DESCRIPTION:Ensure that access control policies for register access are implemented in accordance with the specified design.::","::REFERENCE:CVE-2014-2915:DESCRIPTION:virtualization product does not restrict access to debug and other processor registers in the hardware, allowing a crash of the host or guest OS:LINK:https://www.cve.org/CVERecord?id=CVE-2014-2915::REFERENCE:CVE-2021-3011:DESCRIPTION:virtual interrupt controller in a virtualization product allows crash of host by writing a certain invalid value to a register, which triggers a fatal error instead of returning an error code:LINK:https://www.cve.org/CVERecord?id=CVE-2021-3011::REFERENCE:CVE-2020-12446:DESCRIPTION:Driver exposes access to Model Specific Register (MSR) registers, allowing admin privileges.:LINK:https://www.cve.org/CVERecord?id=CVE-2020-12446::REFERENCE:CVE-2015-2150:DESCRIPTION:Virtualization product does not restrict access to PCI command registers, allowing host crash from the guest.:LINK:https://www.cve.org/CVERecord?id=CVE-2015-2150::",,,"",::680::,"",
1263,"Improper Physical Access Control",Class,Incomplete,"The product is designed with access restricted to certain information, but it does not sufficiently protect against an unauthorized actor with physical access to these areas.","Sections of a product intended to have restricted access may be inadvertently or intentionally rendered accessible when the implemented physical protections are insufficient. The specific requirements around how robust the design of the physical protection mechanism needs to be depends on the type of product being protected. Selecting the correct physical protection mechanism and properly enforcing it through implementation and manufacturing are critical to the overall physical security of the product.",::NATURE:ChildOf:CWE ID:284:VIEW ID:1000:ORDINAL:Primary::NATURE:PeerOf:CWE ID:1191:VIEW ID:1000::,"",::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::OPERATING SYSTEM CLASS:Not OS-Specific:OPERATING SYSTEM PREVALENCE:Undetermined::ARCHITECTURE CLASS:Not Architecture-Specific:ARCHITECTURE PREVALENCE:Undetermined::TECHNOLOGY CLASS:Not Technology-Specific:TECHNOLOGY PREVALENCE:Undetermined::,"","","::PHASE:Architecture and Design:NOTE:This weakness can arise if design decisions are made that do not align with the intended physical protection of the product::PHASE:Manufacturing:NOTE:While the architecture and design phase of the product may have accurately met the intended robustness for product physical protections, this phase may introduce the weakness through errors in physically manufacturing the product.::","",,"::SCOPE:Confidentiality:SCOPE:Integrity:SCOPE:Access Control:IMPACT:Varies by Context::","","::PHASE:Architecture and Design:DESCRIPTION:Specific protection requirements depend strongly on contextual factors including the level of acceptable risk associated with compromise to the product's protection mechanism. Designers could incorporate anti-tampering measures that protect against or detect when the product has been tampered with.::PHASE:Testing:DESCRIPTION:The testing phase of the lifecycle should establish a method for determining whether the protection mechanism is sufficient to prevent unauthorized access.::PHASE:Manufacturing:DESCRIPTION:Ensure that all protection mechanisms are fully activated at the time of manufacturing and distribution.::","",,,"",::401::,"::TYPE:Maintenance:NOTE:This entry is still under development and will continue to see updates and content improvements.::",
1264,"Hardware Logic with Insecure De-Synchronization between Control and Data Channels",Base,Incomplete,"The hardware logic for error handling and security checks can incorrectly forward data before the security check is complete.","Many high-performance on-chip bus protocols and processor data-paths employ separate channels for control and data to increase parallelism and maximize throughput. Bugs in the hardware logic that handle errors and security checks can make it possible for data to be forwarded before the completion of the security checks. If the data can propagate to a location in the hardware observable to an attacker, loss of data confidentiality can occur. 'Meltdown' is a concrete example of how de-synchronization between data and permissions checking logic can violate confidentiality requirements. Data loaded from a page marked as privileged was returned to the cpu regardless of current privilege level for performance reasons. The assumption was that the cpu could later remove all traces of this data during the handling of the illegal memory access exception, but this assumption was proven false as traces of the secret data were not removed from the microarchitectural state.",::NATURE:ChildOf:CWE ID:821:VIEW ID:1000:ORDINAL:Primary::NATURE:PeerOf:CWE ID:1037:VIEW ID:1000::,"::ORDINALITY:Primary::",::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::OPERATING SYSTEM CLASS:Not OS-Specific:OPERATING SYSTEM PREVALENCE:Undetermined::ARCHITECTURE CLASS:Not Architecture-Specific:ARCHITECTURE PREVALENCE:Undetermined::TECHNOLOGY CLASS:Not Technology-Specific:TECHNOLOGY PREVALENCE:Undetermined::,"","","::PHASE:Architecture and Design:NOTE:The weakness can be introduced in the data transfer or bus protocol itself or in the implementation.::PHASE:Implementation::","",,"::SCOPE:Confidentiality:IMPACT:Read Memory:IMPACT:Read Application Data::","","::PHASE:Architecture and Design:DESCRIPTION:Thoroughly verify the data routing logic to ensure that any error handling or security checks effectively block illegal dataflows.::","::REFERENCE:CVE-2017-5754:DESCRIPTION:Systems with microprocessors utilizing speculative execution and indirect branch prediction may allow unauthorized disclosure of information to an attacker with local user access via a side-channel analysis of the data cache.:LINK:https://www.cve.org/CVERecord?id=CVE-2017-5754::",,,"",::233::663::,"::TYPE:Maintenance:NOTE:As of CWE 4.9, members of the CWE Hardware SIG are closely analyzing this entry and others to improve CWE's coverage of transient execution weaknesses, which include issues related to Spectre, Meltdown, and other attacks. Additional investigation may include other weaknesses related to microarchitectural state. As a result, this entry might change significantly in CWE 4.10.::",