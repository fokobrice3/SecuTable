CWE-ID,Description,Background Details,Modes Of Introduction,Exploitation Factors,Detection Methods,Functional Areas,Affected Resources,Related Attack Patterns,
15,One or more system settings or configuration elements can be externally controlled by a user.,,"::PHASE:Implementation:NOTE:Setting manipulation vulnerabilities occur when an attacker can control values that govern the behavior of the system, manage specific resources, or in some way affect the functionality of the application.::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::",,,,,::13::146::176::203::270::271::579::69::76::77::,
22,"The product uses external input to construct a pathname that is intended to identify a file or directory that is located underneath a restricted parent directory, but the product does not properly neutralize special elements within the pathname that can cause the pathname to resolve to a location that is outside of the restricted directory.",,::PHASE:Architecture and Design::PHASE:Implementation::,,"::METHOD:Automated Static Analysis:DESCRIPTION:Automated techniques can find areas where path traversal weaknesses exist. However, tuning or customization may be required to remove or de-prioritize path-traversal problems that are only exploitable by the product's administrator - or other privileged users - and thus potentially valid behavior or, at worst, a bug instead of a vulnerability.:EFFECTIVENESS:High::METHOD:Manual Static Analysis:DESCRIPTION:Manual white box techniques may be able to provide sufficient code coverage and reduction of false positives if all file access operations can be assessed within limited time constraints.:EFFECTIVENESS:High::METHOD:Automated Static Analysis - Binary or Bytecode:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Bytecode Weakness Analysis - including disassembler + source code weakness analysis Cost effective for partial coverage: Binary Weakness Analysis - including disassembler + source code weakness analysis:EFFECTIVENESS:High::METHOD:Manual Static Analysis - Binary or Bytecode:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Binary / Bytecode disassembler - then use manual analysis for vulnerabilities & anomalies:EFFECTIVENESS:SOAR Partial::METHOD:Dynamic Analysis with Automated Results Interpretation:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Web Application Scanner Web Services Scanner Database Scanners:EFFECTIVENESS:High::METHOD:Dynamic Analysis with Manual Results Interpretation:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Fuzz Tester Framework-based Fuzzer:EFFECTIVENESS:High::METHOD:Manual Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Manual Source Code Review (not inspections) Cost effective for partial coverage: Focused Manual Spotcheck - Focused manual analysis of source:EFFECTIVENESS:High::METHOD:Automated Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Source code Weakness Analyzer Context-configured Source Code Weakness Analyzer:EFFECTIVENESS:High::METHOD:Architecture or Design Review:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Formal Methods / Correct-By-Construction Cost effective for partial coverage: Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.):EFFECTIVENESS:High::",::File Processing::,::File or Directory::,::126::64::76::78::79::,
23,"The product uses external input to construct a pathname that should be within a restricted directory, but it does not properly neutralize sequences such as .. that can resolve to a location that is outside of that directory.",,::PHASE:Implementation::,,,,,::139::76::,
36,"The product uses external input to construct a pathname that should be within a restricted directory, but it does not properly neutralize absolute path sequences such as /abs/path that can resolve to a location that is outside of that directory.",,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,::597::,
41,The product is vulnerable to file system contents disclosure through path equivalence. Path equivalence involves the use of special characters in file and directory names. The associated manipulations are intended to generate multiple names for the same object.,,::PHASE:Implementation::,,"::METHOD:Automated Static Analysis - Binary or Bytecode:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Bytecode Weakness Analysis - including disassembler + source code weakness analysis:EFFECTIVENESS:SOAR Partial::METHOD:Manual Static Analysis - Binary or Bytecode:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Binary / Bytecode disassembler - then use manual analysis for vulnerabilities & anomalies:EFFECTIVENESS:SOAR Partial::METHOD:Dynamic Analysis with Automated Results Interpretation:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Web Application Scanner Web Services Scanner Database Scanners:EFFECTIVENESS:SOAR Partial::METHOD:Dynamic Analysis with Manual Results Interpretation:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Fuzz Tester Framework-based Fuzzer:EFFECTIVENESS:SOAR Partial::METHOD:Manual Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Focused Manual Spotcheck - Focused manual analysis of source Manual Source Code Review (not inspections):EFFECTIVENESS:High::METHOD:Automated Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Source code Weakness Analyzer Context-configured Source Code Weakness Analyzer:EFFECTIVENESS:SOAR Partial::METHOD:Architecture or Design Review:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Formal Methods / Correct-By-Construction Cost effective for partial coverage: Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.):EFFECTIVENESS:High::",,::File or Directory::,::3::,
59,"The product attempts to access a file based on the filename, but it does not properly prevent that filename from identifying a link or shortcut that resolves to an unintended resource.",::Soft links are a UNIX term that is synonymous with simple shortcuts on Windows-based platforms.::,::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::,,"::METHOD:Automated Static Analysis - Binary or Bytecode:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Bytecode Weakness Analysis - including disassembler + source code weakness analysis:EFFECTIVENESS:SOAR Partial::METHOD:Manual Static Analysis - Binary or Bytecode:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Binary / Bytecode disassembler - then use manual analysis for vulnerabilities & anomalies:EFFECTIVENESS:SOAR Partial::METHOD:Dynamic Analysis with Automated Results Interpretation:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Web Application Scanner Web Services Scanner Database Scanners:EFFECTIVENESS:SOAR Partial::METHOD:Dynamic Analysis with Manual Results Interpretation:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Fuzz Tester Framework-based Fuzzer:EFFECTIVENESS:SOAR Partial::METHOD:Manual Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Focused Manual Spotcheck - Focused manual analysis of source Manual Source Code Review (not inspections):EFFECTIVENESS:High::METHOD:Automated Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Source code Weakness Analyzer Context-configured Source Code Weakness Analyzer:EFFECTIVENESS:SOAR Partial::METHOD:Architecture or Design Review:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Formal Methods / Correct-By-Construction Cost effective for partial coverage: Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.):EFFECTIVENESS:High::",::File Processing::,::File or Directory::,::132::17::35::76::,
66,"The product does not handle or incorrectly handles a file name that identifies a virtual resource that is not directly specified within the directory that is associated with the file name, causing the product to perform file-based operations on a resource that is not a file.",,::PHASE:Architecture and Design::PHASE:Implementation::PHASE:Operation::,,"::METHOD:Automated Static Analysis - Binary or Bytecode:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Bytecode Weakness Analysis - including disassembler + source code weakness analysis:EFFECTIVENESS:SOAR Partial::METHOD:Manual Static Analysis - Binary or Bytecode:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Binary / Bytecode disassembler - then use manual analysis for vulnerabilities & anomalies:EFFECTIVENESS:SOAR Partial::METHOD:Dynamic Analysis with Automated Results Interpretation:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Web Application Scanner Web Services Scanner Database Scanners:EFFECTIVENESS:SOAR Partial::METHOD:Dynamic Analysis with Manual Results Interpretation:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Fuzz Tester Framework-based Fuzzer:EFFECTIVENESS:SOAR Partial::METHOD:Manual Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Focused Manual Spotcheck - Focused manual analysis of source Manual Source Code Review (not inspections):EFFECTIVENESS:High::METHOD:Automated Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Source code Weakness Analyzer Context-configured Source Code Weakness Analyzer:EFFECTIVENESS:SOAR Partial::METHOD:Architecture or Design Review:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Formal Methods / Correct-By-Construction Cost effective for partial coverage: Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.):EFFECTIVENESS:High::",::File Processing::,::File or Directory::,,
73,The product allows user input to control or influence paths or file names that are used in filesystem operations.,,::PHASE:Architecture and Design::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::,,"::METHOD:Automated Static Analysis:DESCRIPTION:The external control or influence of filenames can often be detected using automated static analysis that models data flow within the product. Automated static analysis might not be able to recognize when proper input validation is being performed, leading to false positives - i.e., warnings that do not have any security consequences or require any code changes.::",,,::13::267::64::72::76::78::79::80::,
76,"The product correctly neutralizes certain special elements, but it improperly neutralizes equivalent special elements.",,::PHASE:Architecture and Design::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::,,,,,,
78,"The product constructs all or part of an OS command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended OS command when it is sent to a downstream component.",,::PHASE:Architecture and Design::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::,,"::METHOD:Automated Static Analysis:DESCRIPTION:This weakness can often be detected using automated static analysis tools. Many modern tools use data flow analysis or constraint-based techniques to minimize the number of false positives. Automated static analysis might not be able to recognize when proper input validation is being performed, leading to false positives - i.e., warnings that do not have any security consequences or require any code changes. Automated static analysis might not be able to detect the usage of custom API functions or third-party libraries that indirectly invoke OS commands, leading to false negatives - especially if the API/library code is not available for analysis.::METHOD:Automated Dynamic Analysis:DESCRIPTION:This weakness can be detected using dynamic tools and techniques that interact with the software using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The software's operation may slow down, but it should not become unstable, crash, or generate incorrect results.:EFFECTIVENESS:Moderate::METHOD:Manual Static Analysis:DESCRIPTION:Since this weakness does not typically appear frequently within a single software package, manual white box techniques may be able to provide sufficient code coverage and reduction of false positives if all potentially-vulnerable operations can be assessed within limited time constraints.:EFFECTIVENESS:High::METHOD:Automated Static Analysis - Binary or Bytecode:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Bytecode Weakness Analysis - including disassembler + source code weakness analysis Binary Weakness Analysis - including disassembler + source code weakness analysis:EFFECTIVENESS:High::METHOD:Dynamic Analysis with Automated Results Interpretation:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Web Application Scanner Web Services Scanner Database Scanners:EFFECTIVENESS:SOAR Partial::METHOD:Dynamic Analysis with Manual Results Interpretation:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Fuzz Tester Framework-based Fuzzer:EFFECTIVENESS:SOAR Partial::METHOD:Manual Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Manual Source Code Review (not inspections) Cost effective for partial coverage: Focused Manual Spotcheck - Focused manual analysis of source:EFFECTIVENESS:High::METHOD:Automated Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Source code Weakness Analyzer Context-configured Source Code Weakness Analyzer:EFFECTIVENESS:High::METHOD:Architecture or Design Review:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Formal Methods / Correct-By-Construction Cost effective for partial coverage: Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.):EFFECTIVENESS:High::",::Program Invocation::,::System Process::,::108::15::43::6::88::,
79,The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.,"::The Same Origin Policy states that browsers should limit the resources accessible to scripts running on a given web site, or origin, to the resources associated with that web site on the client-side, and not the client-side resources of any other sites or origins. The goal is to prevent one site from being able to modify or read the contents of an unrelated site. Since the World Wide Web involves interactions between many sites, this policy is important for browsers to enforce. When referring to XSS, the Domain of a website is roughly equivalent to the resources associated with that website on the client-side of the connection. That is, the domain can be thought of as all resources the browser is storing for the user's interactions with this particular site.::",::PHASE:Architecture and Design::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::,,"::METHOD:Automated Static Analysis:DESCRIPTION:Use automated static analysis tools that target this type of weakness. Many modern techniques use data flow analysis to minimize the number of false positives. This is not a perfect solution, since 100% accuracy and coverage are not feasible, especially when multiple components are involved.:EFFECTIVENESS:Moderate::METHOD:Black Box:DESCRIPTION:Use the XSS Cheat Sheet [REF-714] or automated test-generation tools to help launch a wide variety of attacks against your web application. The Cheat Sheet contains many subtle XSS variations that are specifically targeted against weak XSS defenses.:EFFECTIVENESS:Moderate::",,,::209::588::591::592::63::85::,
88,"The product constructs a string for a command to executed by a separate component in another control sphere, but it does not properly delimit the intended arguments, options, or switches within that command string.",,::PHASE:Architecture and Design::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::,,,,::System Process::,::137::174::41::460::88::,
89,"The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",,::PHASE:Architecture and Design:NOTE:This weakness typically appears in data-rich applications that save user inputs in a database.::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::,,"::METHOD:Automated Static Analysis:DESCRIPTION:This weakness can often be detected using automated static analysis tools. Many modern tools use data flow analysis or constraint-based techniques to minimize the number of false positives. Automated static analysis might not be able to recognize when proper input validation is being performed, leading to false positives - i.e., warnings that do not have any security consequences or do not require any code changes. Automated static analysis might not be able to detect the usage of custom API functions or third-party libraries that indirectly invoke SQL commands, leading to false negatives - especially if the API/library code is not available for analysis.::METHOD:Automated Dynamic Analysis:DESCRIPTION:This weakness can be detected using dynamic tools and techniques that interact with the software using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The software's operation may slow down, but it should not become unstable, crash, or generate incorrect results.:EFFECTIVENESS:Moderate::METHOD:Manual Analysis:DESCRIPTION:Manual analysis can be useful for finding this weakness, but it might not achieve desired code coverage within limited time constraints. This becomes difficult for weaknesses that must be considered for all inputs, since the attack surface can be too large.::METHOD:Automated Static Analysis - Binary or Bytecode:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Bytecode Weakness Analysis - including disassembler + source code weakness analysis Binary Weakness Analysis - including disassembler + source code weakness analysis:EFFECTIVENESS:High::METHOD:Dynamic Analysis with Automated Results Interpretation:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Database Scanners Cost effective for partial coverage: Web Application Scanner Web Services Scanner:EFFECTIVENESS:High::METHOD:Dynamic Analysis with Manual Results Interpretation:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Fuzz Tester Framework-based Fuzzer:EFFECTIVENESS:SOAR Partial::METHOD:Manual Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Manual Source Code Review (not inspections) Cost effective for partial coverage: Focused Manual Spotcheck - Focused manual analysis of source:EFFECTIVENESS:High::METHOD:Automated Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Source code Weakness Analyzer Context-configured Source Code Weakness Analyzer:EFFECTIVENESS:High::METHOD:Architecture or Design Review:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Formal Methods / Correct-By-Construction Cost effective for partial coverage: Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.):EFFECTIVENESS:High::",,,::108::109::110::470::66::7::,
90,"The product constructs all or part of an LDAP query using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended LDAP query when it is sent to a downstream component.",,::PHASE:Architecture and Design::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::,,,,,::136::,
91,"The product does not properly neutralize special elements that are used in XML, allowing attackers to modify the syntax, content, or commands of the XML before it is processed by an end system.",,::PHASE:Architecture and Design::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::,,,,,::250::83::,
93,"The product uses CRLF (carriage return line feeds) as a special element, e.g. to separate lines or records, but it does not neutralize or incorrectly neutralizes CRLF sequences from inputs.",,::PHASE:Architecture and Design::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::,,,,,::15::81::,
94,"The product constructs all or part of a code segment using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the syntax or behavior of the intended code segment.",,::PHASE:Architecture and Design::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::,,,,,::242::35::77::,
96,"The product receives input from an upstream component, but it does not neutralize or incorrectly neutralizes code syntax before inserting the input into an executable resource, such as a library, configuration file, or template.",,"::PHASE:Architecture and Design:NOTE:This issue is most frequently found in PHP applications that allow users to set configuration variables that are stored within executable PHP files. Technically, this could also be performed in some compiled code (e.g. by byte-patching an executable), although it is highly unlikely.::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::",,,,::File or Directory::,::35::73::77::81::85::,
112,The product accepts XML from an untrusted source but does not validate the XML against the proper schema.,,::PHASE:Implementation::,,,,,::230::231::,
115,"The product misinterprets an input, whether from an attacker or another product, in a security-relevant fashion.",,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,,
117,The product does not neutralize or incorrectly neutralizes output that is written to logs.,"::Applications typically use log files to store a history of events or transactions for later review, statistics gathering, or debugging. Depending on the nature of the application, the task of reviewing log files may be performed manually on an as-needed basis or automated with a tool that automatically culls logs for important events or trending information.::",::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::,,,,,::268::81::93::,
120,"The product copies an input buffer to an output buffer without verifying that the size of the input buffer is less than the size of the output buffer, leading to a buffer overflow.",,::PHASE:Implementation::,,"::METHOD:Automated Static Analysis:DESCRIPTION:This weakness can often be detected using automated static analysis tools. Many modern tools use data flow analysis or constraint-based techniques to minimize the number of false positives. Automated static analysis generally does not account for environmental considerations when reporting out-of-bounds memory operations. This can make it difficult for users to determine which warnings should be investigated first. For example, an analysis tool might report buffer overflows that originate from command line arguments in a program that is not expected to run with setuid or other special privileges.:EFFECTIVENESS:High::METHOD:Automated Dynamic Analysis:DESCRIPTION:This weakness can be detected using dynamic tools and techniques that interact with the software using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The software's operation may slow down, but it should not become unstable, crash, or generate incorrect results.::METHOD:Manual Analysis:DESCRIPTION:Manual analysis can be useful for finding this weakness, but it might not achieve desired code coverage within limited time constraints. This becomes difficult for weaknesses that must be considered for all inputs, since the attack surface can be too large.::METHOD:Automated Static Analysis - Binary or Bytecode:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Bytecode Weakness Analysis - including disassembler + source code weakness analysis Binary Weakness Analysis - including disassembler + source code weakness analysis:EFFECTIVENESS:High::METHOD:Manual Static Analysis - Binary or Bytecode:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Binary / Bytecode disassembler - then use manual analysis for vulnerabilities & anomalies:EFFECTIVENESS:SOAR Partial::METHOD:Dynamic Analysis with Automated Results Interpretation:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Web Application Scanner Web Services Scanner Database Scanners:EFFECTIVENESS:SOAR Partial::METHOD:Dynamic Analysis with Manual Results Interpretation:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Fuzz Tester Framework-based Fuzzer:EFFECTIVENESS:SOAR Partial::METHOD:Manual Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Focused Manual Spotcheck - Focused manual analysis of source Manual Source Code Review (not inspections):EFFECTIVENESS:SOAR Partial::METHOD:Automated Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Source code Weakness Analyzer Context-configured Source Code Weakness Analyzer:EFFECTIVENESS:High::METHOD:Architecture or Design Review:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Formal Methods / Correct-By-Construction Cost effective for partial coverage: Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.):EFFECTIVENESS:High::",::Memory Management::,::Memory::,::10::100::14::24::42::44::45::46::47::67::8::9::92::,
123,"Any condition where the attacker has the ability to write an arbitrary value to an arbitrary location, often as the result of a buffer overflow.",,::PHASE:Implementation::,,,,,,
124,The product writes to a buffer using an index or pointer that references a memory location prior to the beginning of the buffer.,,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,,
125,"The product reads data past the end, or before the beginning, of the intended buffer.",,::PHASE:Implementation::,,,,,::540::,
128,"Wrap around errors occur whenever a value is incremented past the maximum value for its type and therefore wraps around to a very small, negative, or undefined value.","::Due to how addition is performed by computers, if a primitive is incremented past the maximum value possible for its storage space, the system will not recognize this, and therefore increment each bit as if it still had extra space. Because of how negative numbers are represented in binary, primitives interpreted as signed may wrap to very large negative values.::",::PHASE:Implementation::,,,,,::92::,
130,"The product parses a formatted message or structure, but it does not handle or incorrectly handles a length field that is inconsistent with the actual length of the associated data.",,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,::47::,
131,"The product does not correctly calculate the size to be used when allocating a buffer, which could lead to a buffer overflow.",,::PHASE:Implementation::,,"::METHOD:Automated Static Analysis:DESCRIPTION:This weakness can often be detected using automated static analysis tools. Many modern tools use data flow analysis or constraint-based techniques to minimize the number of false positives. Automated static analysis generally does not account for environmental considerations when reporting potential errors in buffer calculations. This can make it difficult for users to determine which warnings should be investigated first. For example, an analysis tool might report buffer overflows that originate from command line arguments in a program that is not expected to run with setuid or other special privileges.:EFFECTIVENESS:High::METHOD:Automated Dynamic Analysis:DESCRIPTION:This weakness can be detected using dynamic tools and techniques that interact with the software using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The software's operation may slow down, but it should not become unstable, crash, or generate incorrect results.:EFFECTIVENESS:Moderate::METHOD:Manual Analysis:DESCRIPTION:Manual analysis can be useful for finding this weakness, but it might not achieve desired code coverage within limited time constraints. This becomes difficult for weaknesses that must be considered for all inputs, since the attack surface can be too large.::METHOD:Manual Analysis:DESCRIPTION:This weakness can be detected using tools and techniques that require manual (human) analysis, such as penetration testing, threat modeling, and interactive tools that allow the tester to record and modify an active session. Specifically, manual static analysis is useful for evaluating the correctness of allocation calculations. This can be useful for detecting overflow conditions (CWE-190) or similar weaknesses that might have serious security impacts on the program.:EFFECTIVENESS:High::METHOD:Automated Static Analysis - Binary or Bytecode:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Bytecode Weakness Analysis - including disassembler + source code weakness analysis Binary Weakness Analysis - including disassembler + source code weakness analysis:EFFECTIVENESS:High::METHOD:Manual Static Analysis - Binary or Bytecode:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Binary / Bytecode disassembler - then use manual analysis for vulnerabilities & anomalies:EFFECTIVENESS:SOAR Partial::METHOD:Manual Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Focused Manual Spotcheck - Focused manual analysis of source Manual Source Code Review (not inspections):EFFECTIVENESS:SOAR Partial::METHOD:Automated Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Source code Weakness Analyzer Context-configured Source Code Weakness Analyzer Cost effective for partial coverage: Source Code Quality Analyzer:EFFECTIVENESS:High::METHOD:Architecture or Design Review:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Formal Methods / Correct-By-Construction Cost effective for partial coverage: Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.):EFFECTIVENESS:High::",,,::100::47::,
134,"The product uses a function that accepts a format string as an argument, but the format string originates from an external source.",,"::PHASE:Implementation:NOTE:The programmer rarely intends for a format string to be externally-controlled at all. This weakness is frequently introduced in code that constructs log messages, where a constant format string is omitted.::PHASE:Implementation:NOTE:In cases such as localization and internationalization, the language-specific message repositories could be an avenue for exploitation, but the format string issue would be resultant, since attacker control of those repositories would also allow modification of message length, format, and content.::",,"::METHOD:Automated Static Analysis:DESCRIPTION:This weakness can often be detected using automated static analysis tools. Many modern tools use data flow analysis or constraint-based techniques to minimize the number of false positives.::METHOD:Black Box:DESCRIPTION:Since format strings often occur in rarely-occurring erroneous conditions (e.g. for error message logging), they can be difficult to detect using black box methods. It is highly likely that many latent issues exist in executables that do not have associated source code (or equivalent source.:EFFECTIVENESS:Limited::METHOD:Automated Static Analysis - Binary or Bytecode:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Bytecode Weakness Analysis - including disassembler + source code weakness analysis Binary Weakness Analysis - including disassembler + source code weakness analysis Cost effective for partial coverage: Binary / Bytecode simple extractor - strings, ELF readers, etc.:EFFECTIVENESS:High::METHOD:Manual Static Analysis - Binary or Bytecode:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Binary / Bytecode disassembler - then use manual analysis for vulnerabilities & anomalies:EFFECTIVENESS:SOAR Partial::METHOD:Dynamic Analysis with Automated Results Interpretation:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Web Application Scanner Web Services Scanner Database Scanners:EFFECTIVENESS:SOAR Partial::METHOD:Dynamic Analysis with Manual Results Interpretation:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Fuzz Tester Framework-based Fuzzer:EFFECTIVENESS:SOAR Partial::METHOD:Manual Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Manual Source Code Review (not inspections) Cost effective for partial coverage: Focused Manual Spotcheck - Focused manual analysis of source:EFFECTIVENESS:High::METHOD:Automated Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Source code Weakness Analyzer Context-configured Source Code Weakness Analyzer Cost effective for partial coverage: Warning Flags:EFFECTIVENESS:High::METHOD:Architecture or Design Review:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Formal Methods / Correct-By-Construction Cost effective for partial coverage: Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.):EFFECTIVENESS:High::",::Logging::Error Handling::String Processing::,::Memory::,::135::67::,
135,The product does not correctly calculate the length of strings that can contain wide or multi-byte characters.,,"::PHASE:Implementation:NOTE:There are several ways in which improper string length checking may result in an exploitable condition. All of these, however, involve the introduction of buffer overflow conditions in order to reach an exploitable state. The first of these issues takes place when the output of a wide or multi-byte character string, string-length function is used as a size for the allocation of memory. While this will result in an output of the number of characters in the string, note that the characters are most likely not a single byte, as they are with standard character strings. So, using the size returned as the size sent to new or malloc and copying the string to this newly allocated memory will result in a buffer overflow. Another common way these strings are misused involves the mixing of standard string and wide or multi-byte string functions on a single string. Invariably, this mismatched information will result in the creation of a possibly exploitable buffer overflow condition.::",,,,,,
140,The product does not neutralize or incorrectly neutralizes delimiters.,,::PHASE:Implementation::,,,,,::15::,
166,"The product receives input from an upstream component, but it does not handle or incorrectly handles when an expected special element is missing.",,::PHASE:Implementation::,,,,,,
167,"The product receives input from an upstream component, but it does not handle or incorrectly handles when an additional unexpected special element is provided.",,::PHASE:Implementation::,,,,,,
168,The product does not properly handle input in which an inconsistency exists between two or more special characters or reserved words.,,::PHASE:Implementation::,,,,,,
170,The product does not terminate or incorrectly terminates a string or array with a null character or equivalent terminator.,,::PHASE:Implementation::,,,,,,
178,"The product does not properly account for differences in case sensitivity when accessing or determining the properties of a resource, leading to inconsistent results.",,::PHASE:Implementation::,,,::File Processing::,::File or Directory::,,
179,"The product validates input before applying protection mechanisms that modify the input, which could allow an attacker to bypass the validation via dangerous inputs that only arise after the modification.",,"::PHASE:Implementation:NOTE:Since early validation errors usually arise from improperly implemented defensive mechanisms, it is likely that these will be introduced more frequently as secure programming becomes implemented more widely.::",,,,,::3::43::71::,
182,The product filters data in a way that causes it to be reduced or collapsed into an unsafe value that violates an expected security property.,,::PHASE:Implementation::,,,,,,
183,"The product implements a protection mechanism that relies on a list of inputs (or properties of inputs) that are explicitly allowed by policy because the inputs are assumed to be safe, but the list is too permissive - that is, it allows an input that is unsafe, leading to resultant weaknesses.",,::PHASE:Implementation::,,,,,::120::3::43::71::,
184,"The product implements a protection mechanism that relies on a list of inputs (or properties of inputs) that are not allowed by policy or otherwise require other action to neutralize before additional processing takes place, but the list is incomplete, leading to resultant weaknesses.",,"::PHASE:Implementation:NOTE:Developers might begin to develop a list of bad inputs as a fast way to fix a particular weakness, instead of fixing the root cause. See [REF-141].::PHASE:Architecture and Design:NOTE:The design might rely solely on detection of malicious inputs as a protection mechanism.::",,"::METHOD:Black Box:DESCRIPTION:Exploitation of a vulnerability with commonly-used manipulations might fail, but minor variations might succeed.::",,,::120::15::182::3::43::6::71::73::85::,
186,"A regular expression is overly restrictive, which prevents dangerous values from being detected.",,::PHASE:Implementation::,,,,,,
188,"The product makes invalid assumptions about how protocol data or memory is organized at a lower level, resulting in unintended program behavior.",,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,,
190,"The product performs a calculation that can produce an integer overflow or wraparound, when the logic assumes that the resulting value will always be larger than the original value. This can introduce other weaknesses when the calculation is used for resource management or execution control.",,::PHASE:Implementation::,,"::METHOD:Automated Static Analysis:DESCRIPTION:This weakness can often be detected using automated static analysis tools. Many modern tools use data flow analysis or constraint-based techniques to minimize the number of false positives.:EFFECTIVENESS:High::METHOD:Black Box:DESCRIPTION:Sometimes, evidence of this weakness can be detected using dynamic tools and techniques that interact with the product using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The product's operation may slow down, but it should not become unstable, crash, or generate incorrect results.:EFFECTIVENESS:Moderate::METHOD:Manual Analysis:DESCRIPTION:This weakness can be detected using tools and techniques that require manual (human) analysis, such as penetration testing, threat modeling, and interactive tools that allow the tester to record and modify an active session. Specifically, manual static analysis is useful for evaluating the correctness of allocation calculations. This can be useful for detecting overflow conditions (CWE-190) or similar weaknesses that might have serious security impacts on the program.:EFFECTIVENESS:High::METHOD:Automated Static Analysis - Binary or Bytecode:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Bytecode Weakness Analysis - including disassembler + source code weakness analysis Binary Weakness Analysis - including disassembler + source code weakness analysis:EFFECTIVENESS:High::METHOD:Dynamic Analysis with Manual Results Interpretation:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Fuzz Tester Framework-based Fuzzer:EFFECTIVENESS:SOAR Partial::METHOD:Manual Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Manual Source Code Review (not inspections):EFFECTIVENESS:SOAR Partial::METHOD:Automated Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Source code Weakness Analyzer Context-configured Source Code Weakness Analyzer:EFFECTIVENESS:High::METHOD:Architecture or Design Review:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Formal Methods / Correct-By-Construction Cost effective for partial coverage: Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.):EFFECTIVENESS:High::",::Number Processing::Memory Management::Counters::,,::92::,
191,"The product subtracts one value from another, such that the result is less than the minimum allowable integer value, which produces a value that is not equal to the correct result.",,::PHASE:Implementation::,,,,,,
193,"A product calculates or uses an incorrect maximum or minimum value that is 1 more, or 1 less, than the correct value.",,::PHASE:Implementation::,,,,,,
197,Truncation errors occur when a primitive is cast to a primitive of a smaller size and data is lost in the conversion.,,::PHASE:Implementation::,,,,,,
198,"The product receives input from an upstream component, but it does not account for byte ordering (e.g. big-endian and little-endian) when processing the input, causing an incorrect number or value to be used.",,::PHASE:Architecture and Design::PHASE:Implementation::,,"::METHOD:Black Box:DESCRIPTION:Because byte ordering bugs are usually very noticeable even with normal inputs, this bug is more likely to occur in rarely triggered error conditions, making them difficult to detect using black box methods.::",,,,
201,"The code transmits data to another actor, but a portion of the data includes sensitive information that should not be accessible to that actor.",,::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::,,,,,::12::217::612::613::618::619::621::622::623::,
203,"The product behaves differently or sends different responses under different circumstances in a way that is observable to an unauthorized actor, which exposes security-relevant information about the state of the product, such as whether a particular operation was successful or not.",,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,::189::,
204,The product provides different responses to incoming requests in a way that reveals internal state information to an unauthorized actor outside of the intended control sphere.,,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,::331::332::541::580::,
205,"The product's behaviors indicate important differences that may be observed by unauthorized actors in a way that reveals (1) its internal state or decision process, or (2) differences from other products with equivalent functionality.",,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,::541::580::,
208,"Two separate operations in a product require different amounts of time to complete, in a way that is observable to an actor and reveals security-relevant information about the state of the product, such as whether a particular operation was successful or not.",,::PHASE:Architecture and Design:NOTE:COMMISSION: This weakness refers to an incorrect design related to an architectural security tactic.::PHASE:Implementation::PHASE:Operation::,,,::Cryptography::Authentication::,,::462::541::580::,
209,"The product generates an error message that includes sensitive information about its environment, users, or associated data.",,::PHASE:Architecture and Design::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::PHASE:System Configuration::PHASE:Operation::,,"::METHOD:Manual Analysis:DESCRIPTION:This weakness generally requires domain-specific interpretation using manual analysis. However, the number of potential error conditions may be too large to cover completely within limited time constraints.:EFFECTIVENESS:High::METHOD:Automated Analysis:DESCRIPTION:Automated methods may be able to detect certain idioms automatically, such as exposed stack traces or pathnames, but violation of business rules or privacy requirements is not typically feasible.:EFFECTIVENESS:Moderate::METHOD:Automated Dynamic Analysis:DESCRIPTION:This weakness can be detected using dynamic tools and techniques that interact with the software using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The software's operation may slow down, but it should not become unstable, crash, or generate incorrect results. Error conditions may be triggered with a stress-test by calling the software simultaneously from a large number of threads or processes, and look for evidence of any unexpected behavior.:EFFECTIVENESS:Moderate::METHOD:Manual Dynamic Analysis:DESCRIPTION:Identify error conditions that are not likely to occur during normal usage and trigger them. For example, run the program under low memory conditions, run with insufficient privileges or permissions, interrupt a transaction before it is completed, or disable connectivity to basic network services such as DNS. Monitor the software for any unexpected behavior. If you trigger an unhandled exception or similar error that was discovered and handled by the application's environment, it may still indicate unexpected conditions that were not handled by the application itself.::",,,::215::463::54::7::,
210,The product identifies an error condition and creates its own diagnostic or error messages that contain sensitive information.,,::PHASE:Architecture and Design::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::,,,,,,
211,"The product performs an operation that triggers an external diagnostic or error message that is not directly generated or controlled by the product, such as an error generated by the programming language interpreter that a software application uses. The error can contain sensitive system information.",,"::PHASE:Architecture and Design:NOTE:PHP applications are often targeted for having this issue when the PHP interpreter generates the error outside of the application's control. However, other languages/environments exhibit the same issue.::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::PHASE:Operation::",,,::Error Handling::,,,
212,"The product stores, transfers, or shares a resource that contains sensitive information, but it does not properly remove that information before the product makes the resource available to unauthorized actors.",,::PHASE:Architecture and Design::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::PHASE:Operation::,,,,,::168::,
213,"The product's intended functionality exposes information to certain actors in accordance with the developer's security policy, but this information is regarded as sensitive according to the intended security policies of other stakeholders such as the product's administrator, users, or others whose information is being processed.",,"::PHASE:Policy:NOTE:This can occur when the product's policy does not account for all relevant stakeholders, or when the policies of other stakeholders are not interpreted properly.::PHASE:Requirements:NOTE:This can occur when requirements do not explicitly account for all relevant stakeholders.::PHASE:Architecture and Design:NOTE:Communications or data exchange frameworks may be chosen that exchange or provide access to more information than strictly needed.::PHASE:Implementation:NOTE:This can occur when the developer does not properly track the flow of sensitive information and how it is exposed, e.g., via an API.::",,,,,,
214,"A process is invoked with sensitive command-line arguments, environment variables, or other elements that can be seen by other processes on the operating system.",,::PHASE:Architecture and Design::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::PHASE:Operation::,,,,::System Process::,,
215,"The product inserts sensitive information into debugging code, which could expose this information if the debugging code is not disabled in production.",,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,,
222,"The product truncates the display, recording, or processing of security-relevant information in a way that can obscure the source or nature of an attack.",,::PHASE:Architecture and Design::PHASE:Implementation::PHASE:Operation::,,,,,,
223,"The product does not record or display information that would be important for identifying the source or nature of an attack, or determining if an action is safe.",,::PHASE:Architecture and Design:NOTE:OMISSION: This weakness is caused by missing a security tactic during the architecture and design phase.::PHASE:Implementation::PHASE:Operation::,,,,,,
224,"The product records security-relevant information according to an alternate name of the affected entity, instead of the canonical name.",,::PHASE:Architecture and Design::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::PHASE:Operation::,,,,,,
226,"The product releases a resource such as memory or a file so that it can be made available for reuse, but it does not clear or zeroize the information contained in the resource before the product performs a critical state transition or makes the resource available for reuse by other entities.",,::PHASE:Architecture and Design::PHASE:Implementation::,,"::METHOD:Manual Analysis:DESCRIPTION:Write a known pattern into each sensitive location. Trigger the release of the resource or cause the desired state transition to occur. Read data back from the sensitive locations. If the reads are successful, and the data is the same as the pattern that was originally written, the test fails and the product needs to be fixed. Note that this test can likely be automated.:EFFECTIVENESS:High::",::Memory Management::Networking::,::Memory::,::37::,
229,"The product does not properly handle when the expected number of values for parameters, fields, or arguments is not provided in input, or if those values are undefined.",,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,,
233,"The product does not properly handle when the expected number of parameters, fields, or arguments is not provided in input, or if those parameters are undefined.",,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,::39::,
237,The product does not handle or incorrectly handles inputs that are related to complex structures.,,,,,,,,
240,"The product does not handle or incorrectly handles when two or more structural elements should be consistent, but are not.",,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,,
241,"The product does not handle or incorrectly handles when a particular element is not the expected type, e.g. it expects a digit (0-9) but is provided with a letter (A-Z).",,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,::48::,
242,The product calls a function that can never be guaranteed to work safely.,,::PHASE:Implementation::,,,,,,
248,"An exception is thrown from a function, but it is not caught.",,::PHASE:Implementation::,,,,,,
250,"The product performs an operation at a privilege level that is higher than the minimum level required, which creates new weaknesses or amplifies the consequences of other weaknesses.",,"::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::PHASE:Installation::PHASE:Architecture and Design:NOTE:If an application has this design problem, then it can be easier for the developer to make implementation-related errors such as CWE-271 (Privilege Dropping / Lowering Errors). In addition, the consequences of Privilege Chaining (CWE-268) can become more severe.::PHASE:Operation::",,"::METHOD:Manual Analysis:DESCRIPTION:This weakness can be detected using tools and techniques that require manual (human) analysis, such as penetration testing, threat modeling, and interactive tools that allow the tester to record and modify an active session.::METHOD:Black Box:DESCRIPTION:Use monitoring tools that examine the software's process as it interacts with the operating system and the network. This technique is useful in cases when source code is unavailable, if the software was not developed by you, or if you want to verify that the build phase did not introduce any new weaknesses. Examples include debuggers that directly attach to the running process; system-call tracing utilities such as truss (Solaris) and strace (Linux); system activity monitors such as FileMon, RegMon, Process Monitor, and other Sysinternals utilities (Windows); and sniffers and protocol analyzers that monitor network traffic. Attach the monitor to the process and perform a login. Look for library functions and system calls that indicate when privileges are being raised or dropped. Look for accesses of resources that are restricted to normal users.::METHOD:Automated Static Analysis - Binary or Bytecode:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Compare binary / bytecode to application permission manifest Cost effective for partial coverage: Bytecode Weakness Analysis - including disassembler + source code weakness analysis Binary Weakness Analysis - including disassembler + source code weakness analysis:EFFECTIVENESS:High::METHOD:Manual Static Analysis - Binary or Bytecode:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Binary / Bytecode disassembler - then use manual analysis for vulnerabilities & anomalies:EFFECTIVENESS:SOAR Partial::METHOD:Dynamic Analysis with Automated Results Interpretation:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Host-based Vulnerability Scanners - Examine configuration for flaws, verifying that audit mechanisms work, ensure host configuration meets certain predefined criteria:EFFECTIVENESS:SOAR Partial::METHOD:Dynamic Analysis with Manual Results Interpretation:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Host Application Interface Scanner:EFFECTIVENESS:SOAR Partial::METHOD:Manual Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Manual Source Code Review (not inspections) Cost effective for partial coverage: Focused Manual Spotcheck - Focused manual analysis of source:EFFECTIVENESS:High::METHOD:Automated Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Source code Weakness Analyzer Context-configured Source Code Weakness Analyzer:EFFECTIVENESS:SOAR Partial::METHOD:Automated Static Analysis:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Configuration Checker Permission Manifest Analysis:EFFECTIVENESS:SOAR Partial::METHOD:Architecture or Design Review:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.) Formal Methods / Correct-By-Construction Cost effective for partial coverage: Attack Modeling:EFFECTIVENESS:High::",,,::104::470::69::,
252,"The product does not check the return value from a method or function, which can prevent it from detecting unexpected states and conditions.",::Many functions will return some value about the success of their actions. This will alert the program whether or not to handle any errors caused by that function.::,::PHASE:Implementation::,,,,,,
253,"The product incorrectly checks a return value from a function, which prevents it from detecting errors or exceptional conditions.",,::PHASE:Implementation::,,,,,,
256,Storing a password in plaintext may result in a system compromise.,,"::PHASE:Architecture and Design:NOTE:OMISSION: This weakness is caused by missing a security tactic during the architecture and design phase.::PHASE:Architecture and Design:NOTE:Developers sometimes believe that they cannot defend the application from someone who has access to the configuration, but this belief makes an attacker's job easier.::",,,,,,
257,"The storage of passwords in a recoverable format makes them subject to password reuse attacks by malicious users. In fact, it should be noted that recoverable encrypted passwords provide no significant benefit over plaintext passwords since they are subject not only to reuse by malicious attackers but also by malicious insiders. If a system administrator can recover a password directly, or use a brute force search on the available information, the administrator can use the password on other accounts.",,::PHASE:Architecture and Design:NOTE:COMMISSION: This weakness refers to an incorrect design related to an architectural security tactic.::,,,,,::49::,
260,The product stores a password in a configuration file that might be accessible to actors who do not know the password.,,::PHASE:Architecture and Design:NOTE:OMISSION: This weakness is caused by missing a security tactic during the architecture and design phase.::PHASE:Implementation::,,,,::File or Directory::,,
261,Obscuring a password with a trivial encoding does not protect the password.,,::PHASE:Architecture and Design:NOTE:COMMISSION: This weakness refers to an incorrect design related to an architectural security tactic.::,,,,,::55::,
262,The product does not have a mechanism in place for managing password aging.,,::PHASE:Architecture and Design:NOTE:COMMISSION: This weakness refers to an incorrect design related to an architectural security tactic.::,,,,,::16::49::509::55::555::560::561::565::600::652::653::70::,
263,"The product supports password aging, but the expiration period is too long.",,::PHASE:Architecture and Design:NOTE:COMMISSION: This weakness refers to an incorrect design related to an architectural security tactic.::,,,,,::16::49::509::55::555::560::561::565::600::652::653::70::,
266,"A product incorrectly assigns a privilege to a particular actor, creating an unintended sphere of control for that actor.",,::PHASE:Architecture and Design::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::,,,,::System Process::,,
267,"A particular privilege, role, capability, or right can be used to perform unsafe actions that were not intended, even when it is assigned to the correct entity.",,::PHASE:Architecture and Design::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::PHASE:Operation::,,,,,::58::634::637::643::648::,
268,"Two distinct privileges, roles, capabilities, or rights can be combined in a way that allows an entity to perform unsafe actions that would not be allowed without that combination.",,::PHASE:Architecture and Design::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::PHASE:Operation::,,,,,,
270,The product does not properly manage privileges while it is switching between different contexts that have different privileges or spheres of control.,,::PHASE:Architecture and Design::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::PHASE:Operation::,,,,,::17::30::35::,
272,The elevated privilege level required to perform operations such as chroot() should be dropped immediately after the operation is performed.,,::PHASE:Architecture and Design::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::PHASE:Operation::,,"::METHOD:Automated Static Analysis - Binary or Bytecode:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Compare binary / bytecode to application permission manifest:EFFECTIVENESS:SOAR Partial::METHOD:Dynamic Analysis with Automated Results Interpretation:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Host-based Vulnerability Scanners - Examine configuration for flaws, verifying that audit mechanisms work, ensure host configuration meets certain predefined criteria:EFFECTIVENESS:SOAR Partial::METHOD:Manual Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Manual Source Code Review (not inspections) Cost effective for partial coverage: Focused Manual Spotcheck - Focused manual analysis of source:EFFECTIVENESS:High::METHOD:Automated Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Source code Weakness Analyzer Context-configured Source Code Weakness Analyzer:EFFECTIVENESS:SOAR Partial::METHOD:Automated Static Analysis:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Permission Manifest Analysis:EFFECTIVENESS:SOAR Partial::METHOD:Architecture or Design Review:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.) Formal Methods / Correct-By-Construction Cost effective for partial coverage: Attack Modeling:EFFECTIVENESS:High::",,,::17::35::76::,
273,The product attempts to drop privileges but does not check or incorrectly checks to see if the drop succeeded.,"::In Windows based environments that have access control, impersonation is used so that access checks can be performed on a client identity by a server with higher privileges. By impersonating the client, the server is restricted to client-level security -- although in different threads it may have much higher privileges.::",::PHASE:Architecture and Design::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic. This issue is likely to occur in restrictive environments in which the operating system or application provides fine-grained control over privilege management.::,,,,::System Process::,,
274,"The product does not handle or incorrectly handles when it has insufficient privileges to perform an operation, leading to resultant weaknesses.",,::PHASE:Architecture and Design::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::PHASE:Operation::,,,,,,
276,"During installation, installed file permissions are set to allow anyone to modify those files.",,::PHASE:Architecture and Design::PHASE:Implementation::PHASE:Installation::PHASE:Operation::,,"::METHOD:Automated Static Analysis - Binary or Bytecode:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Inter-application Flow Analysis:EFFECTIVENESS:SOAR Partial::METHOD:Manual Static Analysis - Binary or Bytecode:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Binary / Bytecode disassembler - then use manual analysis for vulnerabilities & anomalies:EFFECTIVENESS:SOAR Partial::METHOD:Dynamic Analysis with Automated Results Interpretation:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Host-based Vulnerability Scanners - Examine configuration for flaws, verifying that audit mechanisms work, ensure host configuration meets certain predefined criteria Web Application Scanner Web Services Scanner Database Scanners:EFFECTIVENESS:SOAR Partial::METHOD:Dynamic Analysis with Manual Results Interpretation:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Host Application Interface Scanner Cost effective for partial coverage: Fuzz Tester Framework-based Fuzzer Automated Monitored Execution Forced Path Execution:EFFECTIVENESS:High::METHOD:Manual Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Manual Source Code Review (not inspections) Cost effective for partial coverage: Focused Manual Spotcheck - Focused manual analysis of source:EFFECTIVENESS:High::METHOD:Automated Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Context-configured Source Code Weakness Analyzer:EFFECTIVENESS:SOAR Partial::METHOD:Automated Static Analysis:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Configuration Checker:EFFECTIVENESS:SOAR Partial::METHOD:Architecture or Design Review:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Formal Methods / Correct-By-Construction Cost effective for partial coverage: Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.):EFFECTIVENESS:High::",,,::1::127::81::,
280,The product does not handle or incorrectly handles when it has insufficient privileges to access resources or functionality as specified by their permissions. This may cause it to follow unexpected code paths that may leave the product in an invalid state.,,::PHASE:Architecture and Design::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::,,,,,,
281,"The product does not preserve permissions or incorrectly preserves permissions when copying, restoring, or sharing objects, which can cause them to have less restrictive permissions than intended.",,::PHASE:Architecture and Design::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::PHASE:Operation::,,,,,,
283,The product does not properly verify that a critical resource is owned by the proper entity.,,::PHASE:Architecture and Design:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::,,,,,,
288,"A product requires authentication, but the product has an alternate path or channel that does not require authentication.",,"::PHASE:Architecture and Design:NOTE:COMMISSION: This weakness refers to an incorrect design related to an architectural security tactic.::PHASE:Architecture and Design:NOTE:This is often seen in web applications that assume that access to a particular CGI program can only be obtained through a front screen, when the supporting programs are directly accessible. But this problem is not just in web apps.::",,,,,::127::665::,
289,"The product performs authentication based on the name of a resource being accessed, or the name of the actor performing the access, but it does not properly check all possible names for that resource or actor.",,::PHASE:Architecture and Design:NOTE:COMMISSION: This weakness refers to an incorrect design related to an architectural security tactic.::PHASE:Implementation::,,,,,,
290,This attack-focused weakness is caused by incorrectly implemented authentication schemes that are subject to spoofing attacks.,,::PHASE:Architecture and Design:NOTE:COMMISSION: This weakness refers to an incorrect design related to an architectural security tactic.::PHASE:Implementation::,,,,,::21::22::459::461::473::476::59::60::667::94::,
294,A capture-replay flaw exists when the design of the product makes it possible for a malicious user to sniff network traffic and bypass authentication by replaying it to the server in question to the same effect as the original message (or with minor changes).,,::PHASE:Architecture and Design:NOTE:COMMISSION: This weakness refers to an incorrect design related to an architectural security tactic.::,,,,,::102::509::555::561::60::644::645::652::701::94::,
295,"The product does not validate, or incorrectly validates, a certificate.",::A certificate is a token that associates an identity (principal) to a cryptographic key. Certificates can be used to check if a public key belongs to the assumed owner.::,"::PHASE:Architecture and Design::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::PHASE:Implementation:NOTE:When the product uses certificate pinning, the developer might not properly validate all relevant components of the certificate before pinning the certificate. This can make it difficult or expensive to test after the pinning is complete.::",,"::METHOD:Automated Static Analysis - Binary or Bytecode:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Bytecode Weakness Analysis - including disassembler + source code weakness analysis Binary Weakness Analysis - including disassembler + source code weakness analysis:EFFECTIVENESS:SOAR Partial::METHOD:Manual Static Analysis - Binary or Bytecode:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Binary / Bytecode disassembler - then use manual analysis for vulnerabilities & anomalies:EFFECTIVENESS:SOAR Partial::METHOD:Dynamic Analysis with Automated Results Interpretation:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Web Application Scanner:EFFECTIVENESS:SOAR Partial::METHOD:Dynamic Analysis with Manual Results Interpretation:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Man-in-the-middle attack tool:EFFECTIVENESS:High::METHOD:Manual Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Focused Manual Spotcheck - Focused manual analysis of source Manual Source Code Review (not inspections):EFFECTIVENESS:High::METHOD:Automated Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Source code Weakness Analyzer Context-configured Source Code Weakness Analyzer:EFFECTIVENESS:SOAR Partial::METHOD:Architecture or Design Review:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.):EFFECTIVENESS:High::",,,::459::475::,
296,"The product does not follow, or incorrectly follows, the chain of trust for a certificate back to a trusted root certificate, resulting in incorrect trust of any resource that is associated with that certificate.",,"::PHASE:Architecture and Design:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::PHASE:Implementation:NOTE:When the product uses certificate pinning, the developer might not properly validate all relevant components of the certificate before pinning the certificate. This can make it difficult or expensive to test after the pinning is complete.::",,,,,,
299,"The product does not check or incorrectly checks the revocation status of a certificate, which may cause it to use a certificate that has been compromised.",,"::PHASE:Architecture and Design:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::PHASE:Implementation:NOTE:When the product uses certificate pinning, the developer might not properly validate all relevant components of the certificate before pinning the certificate. This can make it difficult or expensive to test after the pinning is complete.::",,,,,,
301,Simple authentication protocols are subject to reflection attacks if a malicious user can use the target machine to impersonate a trusted user.,,::PHASE:Architecture and Design:NOTE:COMMISSION: This weakness refers to an incorrect design related to an architectural security tactic.::,,,,,::90::,
302,"The authentication scheme or implementation uses key data elements that are assumed to be immutable, but can be controlled or modified by the attacker.",,::PHASE:Architecture and Design:NOTE:COMMISSION: This weakness refers to an incorrect design related to an architectural security tactic.::PHASE:Implementation::,,,,,::10::13::21::274::31::39::45::77::,
303,"The requirements for the product dictate the use of an established authentication algorithm, but the implementation of the algorithm is incorrect.",,::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::,,,,,::90::,
304,"The product implements an authentication technique, but it skips a step that weakens the technique.",,::PHASE:Architecture and Design::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::,,,,,,
305,"The authentication algorithm is sound, but the implemented mechanism can be bypassed as the result of a separate weakness that is primary to the authentication error.",,::PHASE:Architecture and Design::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::,,,,,,
306,The product does not perform any authentication for functionality that requires a provable user identity or consumes a significant amount of resources.,,::PHASE:Architecture and Design:NOTE:OMISSION: This weakness is caused by missing a security tactic during the architecture and design phase.::,,"::METHOD:Manual Analysis:DESCRIPTION:This weakness can be detected using tools and techniques that require manual (human) analysis, such as penetration testing, threat modeling, and interactive tools that allow the tester to record and modify an active session. Specifically, manual static analysis is useful for evaluating the correctness of custom authentication mechanisms.::METHOD:Automated Static Analysis:DESCRIPTION:Automated static analysis is useful for detecting commonly-used idioms for authentication. A tool may be able to analyze related configuration files, such as .htaccess in Apache web servers, or detect the usage of commonly-used authentication libraries. Generally, automated static analysis tools have difficulty detecting custom authentication schemes. In addition, the software's design may include some functionality that is accessible to any user and does not require an established identity; an automated technique that detects the absence of authentication may report false positives.:EFFECTIVENESS:Limited::METHOD:Manual Static Analysis - Binary or Bytecode:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Binary / Bytecode disassembler - then use manual analysis for vulnerabilities & anomalies:EFFECTIVENESS:SOAR Partial::METHOD:Dynamic Analysis with Automated Results Interpretation:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Web Application Scanner Web Services Scanner Database Scanners:EFFECTIVENESS:SOAR Partial::METHOD:Dynamic Analysis with Manual Results Interpretation:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Host Application Interface Scanner Fuzz Tester Framework-based Fuzzer:EFFECTIVENESS:SOAR Partial::METHOD:Manual Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Focused Manual Spotcheck - Focused manual analysis of source Manual Source Code Review (not inspections):EFFECTIVENESS:SOAR Partial::METHOD:Automated Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Source code Weakness Analyzer Context-configured Source Code Weakness Analyzer:EFFECTIVENESS:SOAR Partial::METHOD:Architecture or Design Review:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.) Formal Methods / Correct-By-Construction Cost effective for partial coverage: Attack Modeling:EFFECTIVENESS:High::",,,::12::166::216::36::62::,
307,"The product does not implement sufficient measures to prevent multiple failed authentication attempts within a short time frame, making it more susceptible to brute force attacks.",,::PHASE:Architecture and Design:NOTE:COMMISSION: This weakness refers to an incorrect design related to an architectural security tactic.::,,"::METHOD:Dynamic Analysis with Automated Results Interpretation:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Web Application Scanner Web Services Scanner Database Scanners Cost effective for partial coverage: Host-based Vulnerability Scanners - Examine configuration for flaws, verifying that audit mechanisms work, ensure host configuration meets certain predefined criteria:EFFECTIVENESS:High::METHOD:Dynamic Analysis with Manual Results Interpretation:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Fuzz Tester Framework-based Fuzzer Cost effective for partial coverage: Forced Path Execution:EFFECTIVENESS:High::METHOD:Manual Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Focused Manual Spotcheck - Focused manual analysis of source Manual Source Code Review (not inspections):EFFECTIVENESS:High::METHOD:Automated Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Source code Weakness Analyzer Context-configured Source Code Weakness Analyzer:EFFECTIVENESS:SOAR Partial::METHOD:Automated Static Analysis:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Configuration Checker:EFFECTIVENESS:SOAR Partial::METHOD:Architecture or Design Review:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Formal Methods / Correct-By-Construction Cost effective for partial coverage: Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.):EFFECTIVENESS:High::",,,::16::49::560::565::600::652::653::,
308,The use of single-factor authentication can lead to unnecessary risk of compromise when compared with the benefits of a dual-factor authentication scheme.,,::PHASE:Architecture and Design:NOTE:COMMISSION: This weakness refers to an incorrect design related to an architectural security tactic.::,,,,,::16::49::509::55::555::560::561::565::600::644::645::652::653::70::,
309,"The use of password systems as the primary means of authentication may be subject to several flaws or shortcomings, each reducing the effectiveness of the mechanism.","::Password systems are the simplest and most ubiquitous authentication mechanisms. However, they are subject to such well known attacks,and such frequent compromise that their use in the most simple implementation is not practical.::",::PHASE:Architecture and Design::,,,,,::16::49::509::55::555::560::561::565::600::652::653::70::,
312,The product stores sensitive information in cleartext within a resource that might be accessible to another control sphere.,,::PHASE:Architecture and Design:NOTE:OMISSION: This weakness is caused by missing a security tactic during the architecture and design phase.::,,,,,::37::,
319,The product transmits sensitive or security-critical data in cleartext in a communication channel that can be sniffed by unauthorized actors.,,"::PHASE:Architecture and Design:NOTE:OMISSION: This weakness is caused by missing a security tactic during the architecture and design phase.::PHASE:Architecture and Design:NOTE:For hardware, this may be introduced when design does not plan for an attacker having physical access while a legitimate user is remotely operating the device.::PHASE:Operation::PHASE:System Configuration::",,"::METHOD:Black Box:DESCRIPTION:Use monitoring tools that examine the software's process as it interacts with the operating system and the network. This technique is useful in cases when source code is unavailable, if the software was not developed by you, or if you want to verify that the build phase did not introduce any new weaknesses. Examples include debuggers that directly attach to the running process; system-call tracing utilities such as truss (Solaris) and strace (Linux); system activity monitors such as FileMon, RegMon, Process Monitor, and other Sysinternals utilities (Windows); and sniffers and protocol analyzers that monitor network traffic. Attach the monitor to the process, trigger the feature that sends the data, and look for the presence or absence of common cryptographic functions in the call tree. Monitor the network and determine if the data packets contain readable commands. Tools exist for detecting if certain encodings are in use. If the traffic contains high entropy, this might indicate the usage of encryption.::",,,::102::117::383::477::65::,
322,The product performs a key exchange with an actor without verifying the identity of that actor.,,::PHASE:Architecture and Design:NOTE:OMISSION: This weakness is caused by missing a security tactic during the architecture and design phase.::,,,,,,
324,"The product uses a cryptographic key or password past its expiration date, which diminishes its safety significantly by increasing the timing window for cracking attacks against that key.",,::PHASE:Architecture and Design:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::,,,,,,
325,"The product does not implement a required step in a cryptographic algorithm, resulting in weaker encryption than advertised by the algorithm.",,"::PHASE:Implementation:NOTE:Developers sometimes omit expensive (resource-intensive) steps in order to improve performance, especially in devices with limited memory or slower CPUs. This step may be taken under a mistaken impression that the step is unnecessary for the cryptographic algorithm.::PHASE:Architecture and Design::PHASE:Requirements:NOTE:This issue may happen when the requirements for the cryptographic algorithm are not clearly stated.::",,,::Cryptography::,,::68::,
328,"The product uses an algorithm that produces a digest (output value) that does not meet security expectations for a hash function that allows an adversary to reasonably determine the original input (preimage attack), find another input that can produce the same hash (2nd preimage attack), or find multiple inputs that evaluate to the same hash (birthday attack).",,::PHASE:Architecture and Design:NOTE:COMMISSION: This weakness refers to an incorrect design related to an architectural security tactic.::,,,,,::461::68::,
331,"The product uses an algorithm or scheme that produces insufficient entropy, leaving patterns or clusters of values that are more likely to occur than others.",,::PHASE:Architecture and Design::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::,,,,,::59::,
334,"The number of possible random values is smaller than needed by the product, making it more susceptible to brute force attacks.",,::PHASE:Architecture and Design::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::,,,,,,
335,The product uses a Pseudo-Random Number Generator (PRNG) but does not correctly manage seeds.,,::PHASE:Architecture and Design::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::,,,,,,
338,"The product uses a Pseudo-Random Number Generator (PRNG) in a security context, but the PRNG's algorithm is not cryptographically strong.",,::PHASE:Architecture and Design::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::,,,,,,
341,"A number or object is predictable based on observations that the attacker can make about the state of the system or network, such as time, process ID, etc.",,::PHASE:Architecture and Design::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::,,,,,,
342,An exact value or random number can be precisely predicted by observing previous values.,,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,,
343,"The product's random number generator produces a series of values which, when observed, can be used to infer a relatively small range of possibilities for the next value that could be generated.",,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,,
344,"The product uses a constant value, name, or reference, but this value can (or should) vary across different environments.",,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,,
347,"The product does not verify, or incorrectly verifies, the cryptographic signature for data.",,::PHASE:Architecture and Design::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::,,,,,::463::475::,
348,"The product has two different sources of the same data or information, but it uses the source that has less support for verification, is less trusted, or is less resistant to attack.",,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,::141::142::73::76::85::,
349,"The product, when processing trusted data, accepts any untrusted data that is also included with the trusted data, treating the untrusted data as if it were trusted.",,::PHASE:Architecture and Design:NOTE:OMISSION: This weakness is caused by missing a security tactic during the architecture and design phase.::PHASE:Implementation::,,,,,::141::142::75::,
351,The product does not properly distinguish between different types of elements in a way that leads to insecure behavior.,,::PHASE:Implementation::,,,,,,
353,"The product uses a transmission protocol that does not include a mechanism for verifying the integrity of the data during transmission, such as a checksum.",,::PHASE:Architecture and Design:NOTE:OMISSION: This weakness is caused by missing a security tactic during the architecture and design phase.::PHASE:Implementation::,,,,,::13::14::389::39::665::74::75::,
354,The product does not validate or incorrectly validates the integrity check values or checksums of a message. This may prevent it from detecting if the data has been modified or corrupted in transmission.,,::PHASE:Architecture and Design::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::,,,,,::145::463::75::,
356,The product's user interface does not warn the user before undertaking an unsafe action on behalf of that user. This makes it easier for attackers to trick users into inflicting damage to their system.,,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,,
357,"The user interface provides a warning to a user regarding dangerous or sensitive operations, but the warning is not noticeable enough to warrant attention.",,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,,
358,"The product does not implement or incorrectly implements one or more security-relevant checks as specified by the design of a standardized algorithm, protocol, or technique.",,"::PHASE:Architecture and Design::PHASE:Implementation:NOTE:This is an implementation error, in which the algorithm/technique requires certain security-related behaviors or conditions that are not implemented or checked properly, thus causing a vulnerability.::",,,,,,
359,"The product does not properly prevent a person's private, personal information from being accessed by actors who either (1) are not explicitly authorized to access the information or (2) do not have the implicit consent of the person about whom the information is collected.",,::PHASE:Architecture and Design:NOTE:OMISSION: This weakness is caused by missing a security tactic during the architecture and design phase.::PHASE:Implementation::PHASE:Operation::,,"::METHOD:Architecture or Design Review:DESCRIPTION:Private personal data can enter a program in a variety of ways: Directly from the user in the form of a password or personal information Accessed from a database or other data store by the application Indirectly from a partner or other third party If the data is written to an external location - such as the console, file system, or network - a privacy violation may occur.:EFFECTIVENESS:High::",,,::464::467::498::508::,
360,Security based on event locations are insecure and can be spoofed.,,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,,
363,"The product checks the status of a file or directory before accessing it, which produces a race condition in which the file can be replaced with a link before the access is performed, causing the product to access the wrong file.",,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,::26::,
364,The product uses a signal handler that introduces a race condition.,,::PHASE:Architecture and Design::PHASE:Implementation::,,,::Signals::Interprocess Communication::,::System Process::,,
366,"If two threads of execution use a resource simultaneously, there exists the possibility that resources may be used while invalid, in turn making the state of execution undefined.",,::PHASE:Architecture and Design::PHASE:Implementation::,,,,::System Process::,::26::29::,
367,"The product checks the state of a resource before using that resource, but the resource's state can change between the check and the use in a way that invalidates the results of the check. This can cause the product to perform invalid actions when the resource is in an unexpected state.",,::PHASE:Implementation::,,,,,::27::29::,
368,"A product performs a series of non-atomic actions to switch between contexts that cross privilege or other security boundaries, but a race condition allows an attacker to modify or misrepresent the product's behavior during the switch.",,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,::26::29::,
369,The product divides a value by zero.,,::PHASE:Implementation::,,,,,,
372,"The product does not properly determine which state it is in, causing it to assume it is in state X when in fact it is in state Y, causing it to perform incorrect operations in a security-relevant manner.",,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,::140::74::,
374,The product sends non-cloned mutable data as an argument to a method or function.,,::PHASE:Implementation::,,,,,,
375,Sending non-cloned mutable data as a return value may result in that data being altered or deleted by the calling function.,,::PHASE:Implementation::,,,,,,
378,"Opening temporary files without appropriate measures or controls can leave the file, its contents and any function that it impacts vulnerable to attack.",,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,,
379,The product creates a temporary file in a directory whose permissions allow unintended actors to determine the file's existence or otherwise access that file.,,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,,
385,"Covert timing channels convey information by modulating some aspect of system behavior over time, so that the program receiving the information can observe system behavior and infer protected information.",,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,::462::,
386,"A constant symbolic reference to an object is used, even though the reference can resolve to a different object over time.",,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,,
390,"The product detects a specific error, but takes no actions to handle the error.",,::PHASE:Architecture and Design::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::,,,,,,
391,"[PLANNED FOR DEPRECATION. SEE MAINTENANCE NOTES AND CONSIDER CWE-252, CWE-248, OR CWE-1069.] Ignoring exceptions and other error conditions may allow an attacker to induce unexpected behavior unnoticed.",,::PHASE:Architecture and Design::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::,,,,,,
392,The product encounters an error but does not provide a status code or return value to indicate that an error has occurred.,,::PHASE:Architecture and Design:NOTE:OMISSION: This weakness is caused by missing a security tactic during the architecture and design phase.::PHASE:Implementation::,,,,,,
393,"A function or operation returns an incorrect return value or status code that does not indicate an error, but causes the product to modify its behavior based on the incorrect result.",,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,,
394,"The product does not properly check when a function or operation returns a value that is legitimate for the function, but is not expected by the product.",,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,,
395,Catching NullPointerException should not be used as an alternative to programmatic checks to prevent dereferencing a null pointer.,,::PHASE:Implementation::,,"::METHOD:Automated Static Analysis - Binary or Bytecode:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Bytecode Weakness Analysis - including disassembler + source code weakness analysis Binary Weakness Analysis - including disassembler + source code weakness analysis:EFFECTIVENESS:SOAR Partial::METHOD:Dynamic Analysis with Manual Results Interpretation:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Framework-based Fuzzer:EFFECTIVENESS:SOAR Partial::METHOD:Manual Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Manual Source Code Review (not inspections):EFFECTIVENESS:SOAR Partial::METHOD:Automated Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Source code Weakness Analyzer Context-configured Source Code Weakness Analyzer:EFFECTIVENESS:High::METHOD:Architecture or Design Review:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Formal Methods / Correct-By-Construction Cost effective for partial coverage: Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.):EFFECTIVENESS:High::",,,,
396,Catching overly broad exceptions promotes complex error handling code that is more likely to contain security vulnerabilities.,,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,,
397,Throwing overly broad exceptions promotes complex error handling code that is more likely to contain security vulnerabilities.,,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,,
403,"A process does not close sensitive file descriptors before invoking a child process, which allows the child to perform unauthorized I/O operations using those descriptors.",,::PHASE:Architecture and Design::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::,,,,::System Process::File or Directory::,,
408,The product allows an entity to perform a legitimate but expensive operation before authentication or authorization has taken place.,,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,,
409,The product does not handle or incorrectly handles a compressed input with a very high compression ratio that produces a large output.,,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,,
410,"The product's resource pool is not large enough to handle peak demand, which allows an attacker to prevent others from accessing the resource by using a (relatively) large number of requests for resources.",,::PHASE:Architecture and Design::PHASE:Implementation::PHASE:Operation::,,,,,,
412,"The product properly checks for the existence of a lock, but the lock can be externally controlled or influenced by an actor that is outside of the intended sphere of control.",,::PHASE:Architecture and Design::PHASE:Implementation::,,"::METHOD:White Box:DESCRIPTION:Automated code analysis techniques might not be able to reliably detect this weakness, since the application's behavior and general security model dictate which resource locks are critical. Interpretation of the weakness might require knowledge of the environment, e.g. if the existence of a file is used as a lock, but the file is created in a world-writable directory.::",,,::25::,
413,The product does not lock or does not correctly lock a resource when the product must have exclusive access to the resource.,,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,,
414,A product does not check to see if a lock is present before performing sensitive operations on a resource.,,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,,
419,"The product uses a primary channel for administration or restricted functionality, but it does not properly protect the channel.",,::PHASE:Architecture and Design:NOTE:OMISSION: This weakness is caused by missing a security tactic during the architecture and design phase.::PHASE:Implementation::,,,,,::383::,
420,"The product protects a primary channel, but it does not use the same level of protection for an alternate channel.",,::PHASE:Architecture and Design:NOTE:OMISSION: This weakness is caused by missing a security tactic during the architecture and design phase.::PHASE:Implementation::PHASE:Operation::,,,,,,
421,"The product opens an alternate channel to communicate with an authorized user, but the channel is accessible to other actors.",,::PHASE:Architecture and Design::,,,,::System Process::,,
425,"The web application does not adequately enforce appropriate authorization on all restricted URLs, scripts, or files.",,::PHASE:Architecture and Design:NOTE:OMISSION: This weakness is caused by missing a security tactic during the architecture and design phase.::PHASE:Implementation::PHASE:Operation::,,,,,::127::143::144::668::87::,
426,The product searches for critical resources using an externally-supplied search path that can point to resources that are not under the product's direct control.,,::PHASE:Architecture and Design::PHASE:Implementation::,,"::METHOD:Black Box:DESCRIPTION:Use monitoring tools that examine the software's process as it interacts with the operating system and the network. This technique is useful in cases when source code is unavailable, if the software was not developed by you, or if you want to verify that the build phase did not introduce any new weaknesses. Examples include debuggers that directly attach to the running process; system-call tracing utilities such as truss (Solaris) and strace (Linux); system activity monitors such as FileMon, RegMon, Process Monitor, and other Sysinternals utilities (Windows); and sniffers and protocol analyzers that monitor network traffic. Attach the monitor to the process and look for library functions and system calls that suggest when a search path is being used. One pattern is when the program performs multiple accesses of the same file but in different directories, with repeated failures until the proper filename is found. Library calls such as getenv() or their equivalent can be checked to see if any path-related variables are being accessed.::METHOD:Automated Static Analysis:DESCRIPTION:Use automated static analysis tools that target this type of weakness. Many modern techniques use data flow analysis to minimize the number of false positives. This is not a perfect solution, since 100% accuracy and coverage are not feasible.::METHOD:Manual Analysis:DESCRIPTION:Use tools and techniques that require manual (human) analysis, such as penetration testing, threat modeling, and interactive tools that allow the tester to record and modify an active session. These may be more effective than strictly automated techniques. This is especially the case with weaknesses that are related to design and business rules.::",::Program Invocation::Code Libraries::,::System Process::,::38::,
427,"The product uses a fixed or controlled search path to find resources, but one or more locations in that path can be under the control of unintended actors.",,::PHASE:Implementation::,,,,,::38::471::,
428,"The product uses a search path that contains an unquoted element, in which the element contains whitespace or other separators. This can cause the product to access resources in a parent path.",,::PHASE:Implementation::,,,::Program Invocation::,,,
430,The wrong handler is assigned to process an object.,,::PHASE:Implementation::,,,,,::11::,
431,A handler is not available or implemented.,,::PHASE:Implementation::,,,,,,
432,"The product uses a signal handler that shares state with other signal handlers, but it does not properly mask or prevent those signal handlers from being invoked while the original signal handler is still running.",,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,,
434,The product allows the attacker to upload or transfer files of dangerous types that can be automatically processed within the product's environment.,,::PHASE:Implementation::PHASE:Architecture and Design:NOTE:OMISSION: This weakness is caused by missing a security tactic during the architecture and design phase.::,,"::METHOD:Dynamic Analysis with Automated Results Interpretation:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Web Application Scanner Web Services Scanner Database Scanners:EFFECTIVENESS:SOAR Partial::METHOD:Dynamic Analysis with Manual Results Interpretation:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Fuzz Tester Framework-based Fuzzer:EFFECTIVENESS:SOAR Partial::METHOD:Manual Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Focused Manual Spotcheck - Focused manual analysis of source Manual Source Code Review (not inspections):EFFECTIVENESS:High::METHOD:Automated Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Source code Weakness Analyzer Context-configured Source Code Weakness Analyzer:EFFECTIVENESS:High::METHOD:Architecture or Design Review:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Formal Methods / Correct-By-Construction Cost effective for partial coverage: Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.):EFFECTIVENESS:High::",::File Processing::,::File or Directory::,::1::,
437,"A product acts as an intermediary or monitor between two or more endpoints, but it does not have a complete model of an endpoint's features, behaviors, or state, potentially causing the product to perform incorrect actions based on this incomplete model.",,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,,
439,"A's behavior or functionality changes with a new version of A, or a new environment, which is not known (or manageable) by B.",,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,,
440,"A feature, API, or function does not perform according to its specification.",,::PHASE:Architecture and Design::PHASE:Implementation::PHASE:Operation::,,,,,,
444,"The product acts as an intermediary HTTP agent (such as a proxy or firewall) in the data flow between two entities such as a client and server, but it does not interpret malformed HTTP requests or responses in ways that are consistent with how the messages will be processed by those entities that are at the ultimate destination.",,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,::273::33::,
447,"A UI function for a security feature appears to be supported and gives feedback to the user that suggests that it is supported, but the underlying functionality is not implemented.",,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,,
448,A UI function is obsolete and the product does not warn the user.,,::PHASE:Implementation::,,,,,,
449,The UI performs the wrong action with respect to the user's request.,,::PHASE:Implementation::,,,,,,
450,The UI has multiple interpretations of user input but does not prompt the user when it selects the less secure interpretation.,,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,,
454,The product initializes critical internal variables or data stores using inputs that can be modified by untrusted actors.,,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,,
455,"The product does not exit or otherwise modify its operation when security-relevant errors occur during initialization, such as when a configuration file has a format error or a hardware security module (HSM) cannot be activated, which can cause the product to execute in a less secure fashion than intended by the administrator.",,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,,
459,The product does not properly clean up and remove temporary or supporting resources after they have been used.,,::PHASE:Architecture and Design::PHASE:Implementation::,,,::File Processing::,,,
460,"The product does not clean up its state or incorrectly cleans up its state when an exception is thrown, leading to unexpected state or control flow.",,::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::,,,,,,
462,Duplicate keys in associative lists can lead to non-unique keys being mistaken for an error.,,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,,
463,The accidental deletion of a data-structure sentinel can cause serious programming logic problems.,,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,,
464,The accidental addition of a data-structure sentinel can cause serious programming logic problems.,,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,,
466,A function can return a pointer to memory that is outside of the buffer that the pointer is expected to reference.,,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,,
468,"In C and C++, one may often accidentally refer to the wrong memory due to the semantics of when math operations are implicitly scaled.",,::PHASE:Implementation:NOTE:Programmers may try to index from a pointer by adding a number of bytes. This is incorrect because C and C++ implicitly scale the operand by the size of the data type.::,,,,,,
469,"The product subtracts one pointer from another in order to determine size, but this calculation can be incorrect if the pointers do not exist in the same memory chunk.",,::PHASE:Implementation::,,,,,,
470,"The product uses external input with reflection to select which classes or code to use, but it does not sufficiently prevent the input from selecting improper classes or code.",,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,::138::,
471,The product does not properly protect an assumed-immutable element from being modified by an attacker.,,::PHASE:Implementation::PHASE:Architecture and Design::,,,,,::384::385::386::387::388::,
472,"The web application does not sufficiently verify inputs that are assumed to be immutable but are actually externally controllable, such as hidden form fields.",,::PHASE:Implementation:NOTE:OMISSION: This weakness is caused by missing a security tactic during the architecture and design phase.::,,,,,::146::226::31::39::,
474,The code uses a function that has inconsistent implementations across operating systems and versions.,,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,,
475,The behavior of this function is undefined unless its control parameter is set to a specific value.,,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,,
476,"A NULL pointer dereference occurs when the application dereferences a pointer that it expects to be valid, but is NULL, typically causing a crash or exit.",,::PHASE:Implementation::,,"::METHOD:Automated Dynamic Analysis:DESCRIPTION:This weakness can be detected using dynamic tools and techniques that interact with the software using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The software's operation may slow down, but it should not become unstable, crash, or generate incorrect results.:EFFECTIVENESS:Moderate::METHOD:Manual Dynamic Analysis:DESCRIPTION:Identify error conditions that are not likely to occur during normal usage and trigger them. For example, run the program under low memory conditions, run with insufficient privileges or permissions, interrupt a transaction before it is completed, or disable connectivity to basic network services such as DNS. Monitor the software for any unexpected behavior. If you trigger an unhandled exception or similar error that was discovered and handled by the application's environment, it may still indicate unexpected conditions that were not handled by the application itself.::",,,,
477,"The code uses deprecated or obsolete functions, which suggests that the code has not been actively reviewed or maintained.",,::PHASE:Implementation::,,"::METHOD:Automated Static Analysis - Binary or Bytecode:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Binary / Bytecode Quality Analysis Cost effective for partial coverage: Bytecode Weakness Analysis - including disassembler + source code weakness analysis:EFFECTIVENESS:High::METHOD:Manual Static Analysis - Binary or Bytecode:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Binary / Bytecode disassembler - then use manual analysis for vulnerabilities & anomalies:EFFECTIVENESS:SOAR Partial::METHOD:Dynamic Analysis with Manual Results Interpretation:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Debugger:EFFECTIVENESS:High::METHOD:Manual Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Manual Source Code Review (not inspections) Cost effective for partial coverage: Focused Manual Spotcheck - Focused manual analysis of source:EFFECTIVENESS:High::METHOD:Automated Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Source Code Quality Analyzer Source code Weakness Analyzer Context-configured Source Code Weakness Analyzer:EFFECTIVENESS:High::METHOD:Automated Static Analysis:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Origin Analysis:EFFECTIVENESS:High::METHOD:Architecture or Design Review:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Formal Methods / Correct-By-Construction Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.):EFFECTIVENESS:High::",,,,
478,"The code does not have a default case in an expression with multiple conditions, such as a switch statement.",,::PHASE:Implementation::,,,,,,
480,"The product accidentally uses the wrong operator, which changes the logic in security-relevant ways.",,::PHASE:Implementation::,,"::METHOD:Automated Static Analysis:DESCRIPTION:This weakness can be found easily using static analysis. However in some cases an operator might appear to be incorrect, but is actually correct and reflects unusual logic within the program.::METHOD:Manual Static Analysis:DESCRIPTION:This weakness can be found easily using static analysis. However in some cases an operator might appear to be incorrect, but is actually correct and reflects unusual logic within the program.::",,,,
483,"The code does not explicitly delimit a block that is intended to contain 2 or more statements, creating a logic error.",,::PHASE:Implementation::,,,,,,
484,"The product omits a break statement within a switch or similar construct, causing code associated with multiple conditions to execute. This can cause problems when the programmer only intended to execute code associated with one condition.",,::PHASE:Implementation::,,"::METHOD:White Box:DESCRIPTION:Omission of a break statement might be intentional, in order to support fallthrough. Automated detection methods might therefore be erroneous. Semantic understanding of expected product behavior is required to interpret whether the code is correct.::METHOD:Black Box:DESCRIPTION:Since this weakness is associated with a code construct, it would be indistinguishable from other errors that produce the same behavior.::",,,,
487,"Java packages are not inherently closed; therefore, relying on them for code security is not a good practice.",,::PHASE:Implementation::,,,,,,
488,"The product does not sufficiently enforce boundaries between the states of different sessions, causing data to be provided to, or used by, the wrong session.",,::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::,,,,,::59::60::,
489,"The product is deployed to unauthorized actors with debugging code still enabled or active, which can create unintended entry points or expose sensitive information.",,"::PHASE:Implementation:NOTE:In web-based applications, debug code is used to test and modify web application properties, configuration information, and functions. If a debug application is left on a production server, this oversight during the software process allows attackers access to debug functionality.::PHASE:Build and Compilation::PHASE:Operation::",,,,,::121::661::,
494,The product downloads source code or an executable from a remote location and executes the code without sufficiently verifying the origin and integrity of the code.,,::PHASE:Architecture and Design:NOTE:OMISSION: This weakness is caused by missing a security tactic during the architecture and design phase.::PHASE:Implementation::,,"::METHOD:Manual Analysis:DESCRIPTION:This weakness can be detected using tools and techniques that require manual (human) analysis, such as penetration testing, threat modeling, and interactive tools that allow the tester to record and modify an active session. Specifically, manual static analysis is typically required to find the behavior that triggers the download of code, and to determine whether integrity-checking methods are in use.::METHOD:Black Box:DESCRIPTION:Use monitoring tools that examine the software's process as it interacts with the operating system and the network. This technique is useful in cases when source code is unavailable, if the software was not developed by you, or if you want to verify that the build phase did not introduce any new weaknesses. Examples include debuggers that directly attach to the running process; system-call tracing utilities such as truss (Solaris) and strace (Linux); system activity monitors such as FileMon, RegMon, Process Monitor, and other Sysinternals utilities (Windows); and sniffers and protocol analyzers that monitor network traffic. Attach the monitor to the process and also sniff the network connection. Trigger features related to product updates or plugin installation, which is likely to force a code download. Monitor when files are downloaded and separately executed, or if they are otherwise read back into the process. Look for evidence of cryptographic library calls that use integrity checking.::",,,::184::185::186::187::533::538::657::662::691::692::693::695::,
497,The product does not properly prevent sensitive system-level information from being accessed by unauthorized actors who do not have the same level of access to the underlying system as the product does.,,::PHASE:Implementation::,,,,,::170::694::,
501,The product mixes trusted and untrusted data in the same data structure or structured message.,,::PHASE:Architecture and Design::,,,,,,
502,The product deserializes untrusted data without sufficiently verifying that the resulting data will be valid.,"::Serialization and deserialization refer to the process of taking program-internal object-related data, packaging it in a way that allows the data to be externally stored or transferred (serialization), then extracting the serialized data to reconstruct the original object (deserialization).::",::PHASE:Architecture and Design:NOTE:OMISSION: This weakness is caused by missing a security tactic during the architecture and design phase.::PHASE:Implementation::,,,,,::586::,
507,"The product appears to contain benign or useful functionality, but it also contains code that is hidden from normal operation that violates the intended security policy of the user or the system administrator.",,::PHASE:Implementation::PHASE:Operation::,,,,,::698::,
508,Non-replicating malicious code only resides on the target system or product that is attacked; it does not attempt to spread to other systems.,,::PHASE:Implementation::PHASE:Operation::,,,,,,
509,"Replicating malicious code, including viruses and worms, will attempt to attack other systems once it has successfully compromised the target system or the product.",,::PHASE:Implementation::PHASE:Operation::,,,,,,
510,"A trapdoor is a hidden piece of code that responds to a special input, allowing its user access to resources without passing through the normal security enforcement mechanism.",,::PHASE:Architecture and Design::PHASE:Implementation::PHASE:Operation::,,"::METHOD:Automated Static Analysis - Binary or Bytecode:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Inter-application Flow Analysis Binary / Bytecode simple extractor - strings, ELF readers, etc.:EFFECTIVENESS:SOAR Partial::METHOD:Manual Static Analysis - Binary or Bytecode:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Binary / Bytecode disassembler - then use manual analysis for vulnerabilities & anomalies Generated Code Inspection:EFFECTIVENESS:SOAR Partial::METHOD:Dynamic Analysis with Manual Results Interpretation:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Automated Monitored Execution Forced Path Execution Debugger Monitored Virtual Environment - run potentially malicious code in sandbox / wrapper / virtual machine, see if it does anything suspicious:EFFECTIVENESS:SOAR Partial::METHOD:Manual Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Manual Source Code Review (not inspections) Cost effective for partial coverage: Focused Manual Spotcheck - Focused manual analysis of source:EFFECTIVENESS:High::METHOD:Automated Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Context-configured Source Code Weakness Analyzer:EFFECTIVENESS:SOAR Partial::METHOD:Architecture or Design Review:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.) Cost effective for partial coverage: Formal Methods / Correct-By-Construction:EFFECTIVENESS:High::",,,,
511,"The product contains code that is designed to disrupt the legitimate operation of the product (or its environment) when a certain time passes, or when a certain logical condition is met.",,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,,
512,"The product collects personally identifiable information about a human user or the user's activities, but the product accesses this information using other resources besides itself, and it does not require that user's explicit approval or direct input into the product.",,::PHASE:Architecture and Design::PHASE:Implementation::PHASE:Operation::,,,,,,
515,A covert storage channel transfers information through the setting of bits by one program and the reading of those bits by another. What distinguishes this case from that of ordinary operation is that the bits are used to convey encoded information.,,::PHASE:Implementation::,,,,,,
521,"The product does not require that users should have strong passwords, which makes it easier for attackers to compromise user accounts.",,::PHASE:Architecture and Design:NOTE:COMMISSION: This weakness refers to an incorrect design related to an architectural security tactic.::PHASE:Implementation:NOTE:Not enforcing the password policy stated in a products design can allow users to create passwords that do not provide the necessary level of protection.::,,,,,::112::16::49::509::55::555::561::565::70::,
523,Login pages do not use adequate measures to protect the user name and password while they are in transit from the client to the server.,"::SSL (Secure Socket Layer) provides data confidentiality and integrity to HTTP. By encrypting HTTP messages, SSL protects from attackers eavesdropping or altering message contents.::",::PHASE:Architecture and Design:NOTE:OMISSION: This weakness is caused by missing a security tactic during the architecture and design phase.::,,,,,::102::,
524,"The code uses a cache that contains sensitive information, but the cache can be read by an actor outside of the intended control sphere.",,::PHASE:Implementation::,,,,,::204::,
532,Information written to log files can be of a sensitive nature and give valuable guidance to an attacker or expose sensitive user information.,,::PHASE:Architecture and Design:NOTE:COMMISSION: This weakness refers to an incorrect design related to an architectural security tactic.::PHASE:Implementation::PHASE:Operation::,,,,,::215::,
538,"The product places sensitive information into files or directories that are accessible to actors who are allowed to have access to the files, but not to the sensitive information.",,::PHASE:Implementation:NOTE:OMISSION: This weakness is caused by missing a security tactic during the architecture and design phase.::PHASE:Operation:NOTE:OMISSION: This weakness is caused by missing a security tactic during the architecture and design phase.::,,,,,::95::,
540,Source code on a web server or repository often contains sensitive information and should generally not be accessible to users.,,::PHASE:Implementation::,,,,,,
544,"The product does not use a standardized method for handling errors throughout the code, which might introduce inconsistent error handling and resultant weaknesses.",,::PHASE:Architecture and Design:NOTE:OMISSION: This weakness is caused by missing a security tactic during the architecture and design phase.::,,,,,,
549,"The product does not mask passwords during entry, increasing the potential for attackers to observe and capture passwords.",,::PHASE:Implementation::,,,,,,
551,"If a web server does not fully parse requested URLs before it examines them for authorization, it may be possible for an attacker to bypass authorization protection.",,::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::,,,,,,
552,"The product makes files or directories accessible to unauthorized actors, even though they should not be.",,::PHASE:Implementation:NOTE:OMISSION: This weakness is caused by missing a security tactic during the architecture and design phase.::PHASE:Operation:NOTE:OMISSION: This weakness is caused by missing a security tactic during the architecture and design phase.::,,,,::File or Directory::,::150::639::,
561,"The product contains dead code, which can never be executed.",,::PHASE:Implementation::,,"::METHOD:Architecture or Design Review:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.) Formal Methods / Correct-By-Construction Cost effective for partial coverage: Attack Modeling:EFFECTIVENESS:High::METHOD:Automated Static Analysis - Binary or Bytecode:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Binary / Bytecode Quality Analysis Compare binary / bytecode to application permission manifest:EFFECTIVENESS:High::METHOD:Dynamic Analysis with Manual Results Interpretation:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Automated Monitored Execution:EFFECTIVENESS:SOAR Partial::METHOD:Automated Static Analysis:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Permission Manifest Analysis:EFFECTIVENESS:SOAR Partial::METHOD:Automated Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Source Code Quality Analyzer Cost effective for partial coverage: Warning Flags Source code Weakness Analyzer Context-configured Source Code Weakness Analyzer:EFFECTIVENESS:High::METHOD:Dynamic Analysis with Automated Results Interpretation:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Web Application Scanner Web Services Scanner Database Scanners:EFFECTIVENESS:SOAR Partial::METHOD:Manual Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Manual Source Code Review (not inspections) Cost effective for partial coverage: Focused Manual Spotcheck - Focused manual analysis of source:EFFECTIVENESS:High::",,,,
562,"A function returns the address of a stack variable, which will cause unintended program behavior, typically in the form of a crash.",,::PHASE:Implementation::,,,,,,
565,"The product relies on the existence or values of cookies when performing security-critical operations, but it does not properly ensure that the setting is valid for the associated user.",,::PHASE:Architecture and Design:NOTE:OMISSION: This weakness is caused by missing a security tactic during the architecture and design phase.::PHASE:Implementation::,,,,,::226::31::39::,
567,"The product does not properly synchronize shared data, such as static variables across threads, which can lead to undefined behavior and unpredictable data changes.",,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,::25::,
570,The product contains an expression that will always evaluate to false.,,::PHASE:Implementation::,,,,,,
571,The product contains an expression that will always evaluate to true.,,::PHASE:Implementation::,,,,,,
581,The product does not maintain equal hashcodes for equal objects.,,::PHASE:Implementation::,,,,,,
584,"The code has a return statement inside a finally block, which will cause any thrown exception in the try block to be discarded.",,::PHASE:Implementation::,,,,,,
585,The product contains an empty synchronized block.,,::PHASE:Implementation::,,,,,,
587,The product sets a pointer to a specific address other than NULL or 0.,,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,,
600,"The Servlet does not catch all exceptions, which may reveal sensitive debugging information.",,::PHASE:Implementation::,,,,,,
601,"A web application accepts a user-controlled input that specifies a link to an external site, and uses that link in a Redirect. This simplifies phishing attacks.",::Phishing is a general term for deceptive attempts to coerce private information from users that will be used for identity theft.::,::PHASE:Architecture and Design:NOTE:OMISSION: This weakness is caused by missing a security tactic during the architecture and design phase.::PHASE:Implementation::,,"::METHOD:Manual Static Analysis:DESCRIPTION:Since this weakness does not typically appear frequently within a single software package, manual white box techniques may be able to provide sufficient code coverage and reduction of false positives if all potentially-vulnerable operations can be assessed within limited time constraints.:EFFECTIVENESS:High::METHOD:Automated Dynamic Analysis:DESCRIPTION:Automated black box tools that supply URLs to every input may be able to spot Location header modifications, but test case coverage is a factor, and custom redirects may not be detected.::METHOD:Automated Static Analysis:DESCRIPTION:Automated static analysis tools may not be able to determine whether input influences the beginning of a URL, which is important for reducing false positives.::METHOD:Other:DESCRIPTION:Whether this issue poses a vulnerability will be subject to the intended behavior of the application. For example, a search engine might intentionally provide redirects to arbitrary URLs.::METHOD:Automated Static Analysis - Binary or Bytecode:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Bytecode Weakness Analysis - including disassembler + source code weakness analysis Binary Weakness Analysis - including disassembler + source code weakness analysis:EFFECTIVENESS:High::METHOD:Dynamic Analysis with Automated Results Interpretation:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Web Application Scanner Web Services Scanner Database Scanners:EFFECTIVENESS:High::METHOD:Dynamic Analysis with Manual Results Interpretation:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Fuzz Tester Framework-based Fuzzer:EFFECTIVENESS:High::METHOD:Manual Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Manual Source Code Review (not inspections):EFFECTIVENESS:High::METHOD:Automated Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Source code Weakness Analyzer Context-configured Source Code Weakness Analyzer:EFFECTIVENESS:High::METHOD:Architecture or Design Review:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Formal Methods / Correct-By-Construction Cost effective for partial coverage: Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.):EFFECTIVENESS:High::",,,::178::,
603,"A client/server product performs authentication within client code but not in server code, allowing server-side authentication to be bypassed via a modified client that omits the authentication check.",,::PHASE:Architecture and Design:NOTE:COMMISSION: This weakness refers to an incorrect design related to an architectural security tactic.::PHASE:Implementation::,,,,,,
605,"When multiple sockets are allowed to bind to the same port, other services on that port may be stolen or spoofed.",,::PHASE:Architecture and Design::PHASE:Implementation::PHASE:Operation::,,,,,,
606,"The product does not properly check inputs that are used for loop conditions, potentially leading to a denial of service or other consequences because of excessive looping.",,::PHASE:Implementation::,,,,,,
609,"The product uses double-checked locking to access a resource without the overhead of explicit synchronization, but the locking is insufficient.",,::PHASE:Implementation::,,,,,,
611,"The product processes an XML document that can contain XML entities with URIs that resolve to documents outside of the intended sphere of control, causing the product to embed incorrect documents into its output.",,::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::,,,,,::221::,
612,"The product creates a search index of private or sensitive documents, but it does not properly limit index access to actors who are authorized to see the original information.",,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,,
613,"According to WASC, Insufficient Session Expiration is when a web site permits an attacker to reuse old session credentials or session IDs for authorization.",,::PHASE:Architecture and Design::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::,,,,,,
617,"The product contains an assert() or similar statement that can be triggered by an attacker, which leads to an application exit or other behavior that is more severe than necessary.",,::PHASE:Implementation::,,,,,,
618,"An ActiveX control is intended for use in a web browser, but it exposes dangerous methods that perform actions that are outside of the browser's security model (e.g. the zone or domain).",,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,,
619,"If a database cursor is not closed properly, then it could become accessible to other users while retaining the same privileges that were originally assigned, leaving the cursor dangling.",::A cursor is a feature in Oracle PL/SQL and other languages that provides a handle for executing and accessing the results of SQL queries.::,"::PHASE:Implementation:NOTE:This issue is currently reported for unhandled exceptions, but it is theoretically possible any time the programmer does not close the cursor at the proper time.::",,,,,,
620,"When setting a new password for a user, the product does not require knowledge of the original password, or using another form of authentication.",,::PHASE:Architecture and Design::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::,,,,,,
621,"The product uses external input to determine the names of variables into which information is extracted, without verifying that the names of the specified variables are valid. This could cause the program to overwrite unintended variables.",,::PHASE:Implementation::,,,,,,
624,"The product uses a regular expression that either (1) contains an executable component with user-controlled inputs, or (2) allows a user to enable execution by inserting pattern modifiers.",,::PHASE:Implementation::,,,,,,
625,The product uses a regular expression that does not sufficiently restrict the set of allowed values.,,::PHASE:Implementation:NOTE:This problem is frequently found when the regular expression is used in input validation or security features such as authentication.::,,,,,,
627,"In a language where the user can influence the name of a variable at runtime, if the variable names are not controlled, an attacker can read or write to arbitrary variables, or access arbitrary functions.","::Many interpreted languages support the use of a $$varname construct to set a variable whose name is specified by the $varname variable. In PHP, these are referred to as variable variables. Functions might also be invoked using similar syntax, such as $$funcname(arg1, arg2).::",::PHASE:Implementation::,,,,,,
628,"The product calls a function, procedure, or routine with arguments that are not correctly specified, leading to always-incorrect behavior and resultant weaknesses.",,::PHASE:Implementation::,,"::METHOD:Other:DESCRIPTION:Since these bugs typically introduce incorrect behavior that is obvious to users, they are found quickly, unless they occur in rarely-tested code paths. Managing the correct number of arguments can be made more difficult in cases where format strings are used, or when variable numbers of arguments are supported.::",,,,
639,The system's authorization functionality does not prevent one user from gaining access to another user's data or record by modifying the key value identifying the data.,,::PHASE:Architecture and Design:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::,,,,,,
640,"The product contains a mechanism for users to recover or change their passwords without knowing the original password, but the mechanism is weak.",,::PHASE:Architecture and Design:NOTE:COMMISSION: This weakness refers to an incorrect design related to an architectural security tactic.::PHASE:Implementation::,,,,,::50::,
641,"The product constructs the name of a file or other resource using input from an upstream component, but it does not restrict or incorrectly restricts the resulting name.",,::PHASE:Architecture and Design::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::,,,,,,
643,"The product uses external input to dynamically construct an XPath expression used to retrieve data from an XML database, but it does not neutralize or incorrectly neutralizes that input. This allows an attacker to control the structure of the query.",,::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::,,,,,,
645,"The product contains an account lockout protection mechanism, but the mechanism is too restrictive and can be triggered too easily, which allows attackers to deny service to legitimate users by causing their accounts to be locked out.",,::PHASE:Architecture and Design:NOTE:COMMISSION: This weakness refers to an incorrect design related to an architectural security tactic.::,,,,,::2::,
648,The product does not conform to the API requirements for a function call that requires extra privileges. This could allow attackers to gain privileges by causing the function to be called incorrectly.,,::PHASE:Architecture and Design::PHASE:Implementation::PHASE:Operation::,,,,,::107::234::,
649,"The product uses obfuscation or encryption of inputs that should not be mutable by an external actor, but the product does not use integrity checks to detect if those inputs have been modified.",,::PHASE:Architecture and Design:NOTE:OMISSION: This weakness is caused by missing a security tactic during the architecture and design phase.::PHASE:Implementation::,,,,,::463::,
652,"The product uses external input to dynamically construct an XQuery expression used to retrieve data from an XML database, but it does not neutralize or incorrectly neutralizes that input. This allows an attacker to control the structure of the query.",,::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::,,,,,,
653,"The product does not properly compartmentalize or isolate functionality, processes, or resources that require different privilege levels, rights, or permissions.",,::PHASE:Architecture and Design:NOTE:COMMISSION: This weakness refers to an incorrect design related to an architectural security tactic.::PHASE:Implementation::,,"::METHOD:Automated Static Analysis - Binary or Bytecode:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Compare binary / bytecode to application permission manifest:EFFECTIVENESS:SOAR Partial::METHOD:Manual Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Manual Source Code Review (not inspections) Cost effective for partial coverage: Focused Manual Spotcheck - Focused manual analysis of source:EFFECTIVENESS:High::METHOD:Architecture or Design Review:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.) Formal Methods / Correct-By-Construction Cost effective for partial coverage: Attack Modeling:EFFECTIVENESS:High::",,,,
654,"A protection mechanism relies exclusively, or to a large extent, on the evaluation of a single condition or the integrity of a single object or entity in order to make a decision about granting access to restricted resources or functionality.",,::PHASE:Architecture and Design::PHASE:Implementation::PHASE:Operation::,,,,,::16::274::49::55::560::565::600::652::653::70::,
655,"The product has a protection mechanism that is too difficult or inconvenient to use, encouraging non-malicious users to disable or bypass the mechanism, whether by accident or on purpose.",,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,,
656,"The product uses a protection mechanism whose strength depends heavily on its obscurity, such that knowledge of its algorithms or key data is sufficient to defeat the mechanism.",,::PHASE:Architecture and Design::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::,,,,,,
663,The product calls a non-reentrant function in a concurrent context in which a competing code sequence (e.g. thread or signal handler) may have an opportunity to call the same function or otherwise influence its state.,,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,::29::,
676,"The product invokes a potentially dangerous function that could introduce a vulnerability if it is used incorrectly, but the function can also be used safely.",,::PHASE:Architecture and Design::PHASE:Implementation::,,"::METHOD:Automated Static Analysis - Binary or Bytecode:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Bytecode Weakness Analysis - including disassembler + source code weakness analysis Binary Weakness Analysis - including disassembler + source code weakness analysis Cost effective for partial coverage: Binary / Bytecode Quality Analysis Binary / Bytecode simple extractor - strings, ELF readers, etc.:EFFECTIVENESS:High::METHOD:Manual Static Analysis - Binary or Bytecode:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Binary / Bytecode disassembler - then use manual analysis for vulnerabilities & anomalies:EFFECTIVENESS:SOAR Partial::METHOD:Dynamic Analysis with Manual Results Interpretation:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Debugger Cost effective for partial coverage: Monitored Virtual Environment - run potentially malicious code in sandbox / wrapper / virtual machine, see if it does anything suspicious:EFFECTIVENESS:High::METHOD:Manual Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Manual Source Code Review (not inspections) Cost effective for partial coverage: Focused Manual Spotcheck - Focused manual analysis of source:EFFECTIVENESS:High::METHOD:Automated Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Source code Weakness Analyzer Context-configured Source Code Weakness Analyzer Cost effective for partial coverage: Warning Flags Source Code Quality Analyzer:EFFECTIVENESS:High::METHOD:Automated Static Analysis:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Origin Analysis:EFFECTIVENESS:SOAR Partial::METHOD:Architecture or Design Review:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Formal Methods / Correct-By-Construction Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.):EFFECTIVENESS:High::",,,,
681,"When converting from one data type to another, such as long to integer, data can be omitted or translated in a way that produces unexpected values. If the resulting values are used in a sensitive context, then dangerous behaviors may occur.",,::PHASE:Implementation::,,,,,,
694,"The product uses multiple resources that can have the same identifier, in a context in which unique identifiers are required.",,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,,
695,The product uses low-level functionality that is explicitly prohibited by the framework or specification under which the product is supposed to operate.,,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,::36::,
698,"The web application sends a redirect to another location, but instead of exiting, it executes additional code.",,::PHASE:Implementation::,,"::METHOD:Black Box:DESCRIPTION:This issue might not be detected if testing is performed using a web browser, because the browser might obey the redirect and move the user to a different page before the application has produced outputs that indicate something is amiss.::",,,,
708,"The product assigns an owner to a resource, but the owner is outside of the intended control sphere.",,::PHASE:Architecture and Design::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::PHASE:Operation::,,,,,,
733,"The developer builds a security-critical protection mechanism into the software, but the compiler optimizes the program such that the mechanism is removed or modified.",,,,"::METHOD:Black Box:DESCRIPTION:This specific weakness is impossible to detect using black box methods. While an analyst could examine memory to see that it has not been scrubbed, an analysis of the executable would not be successful. This is because the compiler has already removed the relevant code. Only the source code shows whether the programmer intended to clear the memory or not, so this weakness is indistinguishable from others.::METHOD:White Box:DESCRIPTION:This weakness is only detectable using white box methods (see black box detection factor). Careful analysis is required to determine if the code is likely to be removed by the compiler.::",,,::10::24::46::8::9::,
749,"The product provides an Applications Programming Interface (API) or similar interface for interaction with external actors, but the interface includes a dangerous method or function that is not properly restricted.",,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,::500::,
756,"The product does not return custom error pages to the user, possibly exposing sensitive information.",,,,,,,,
757,"A protocol or its implementation supports interaction between multiple actors and allows those actors to negotiate which algorithm should be used as a protection mechanism such as encryption or authentication, but it does not select the strongest algorithm that is available to both parties.",,::PHASE:Architecture and Design:NOTE:COMMISSION: This weakness refers to an incorrect design related to an architectural security tactic.::,,,,,::220::606::620::,
763,"The product attempts to return a memory resource to the system, but it calls the wrong release function or calls the appropriate release function incorrectly.",,::PHASE:Implementation::,,,,::Memory::,,
764,"The product locks a critical resource more times than intended, leading to an unexpected state in the system.",,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,,
765,"The product unlocks a critical resource more times than intended, leading to an unexpected state in the system.",,::PHASE:Implementation::,,,,,,
770,"The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",,::PHASE:Architecture and Design:NOTE:OMISSION: This weakness is caused by missing a security tactic during the architecture and design phase.::PHASE:Implementation::PHASE:Operation::PHASE:System Configuration::,,"::METHOD:Manual Static Analysis:DESCRIPTION:Manual static analysis can be useful for finding this weakness, but it might not achieve desired code coverage within limited time constraints. If denial-of-service is not considered a significant risk, or if there is strong emphasis on consequences such as code execution, then manual analysis may not focus on this weakness at all.::METHOD:Fuzzing:DESCRIPTION:While fuzzing is typically geared toward finding low-level implementation bugs, it can inadvertently find uncontrolled resource allocation problems. This can occur when the fuzzer generates a large number of test cases but does not restart the targeted product in between test cases. If an individual test case produces a crash, but it does not do so reliably, then an inability to limit resource allocation may be the cause. When the allocation is directly affected by numeric inputs, then fuzzing may produce indications of this weakness.:EFFECTIVENESS:Opportunistic::METHOD:Automated Dynamic Analysis:DESCRIPTION:Certain automated dynamic analysis techniques may be effective in producing side effects of uncontrolled resource allocation problems, especially with resources such as processes, memory, and connections. The technique may involve generating a large number of requests to the product within a short time frame. Manual analysis is likely required to interpret the results.::METHOD:Automated Static Analysis:DESCRIPTION:Specialized configuration or tuning may be required to train automated tools to recognize this weakness. Automated static analysis typically has limited utility in recognizing unlimited allocation problems, except for the missing release of program-independent system resources such as files, sockets, and processes, or unchecked arguments to memory. For system resources, automated static analysis may be able to detect circumstances in which resources are not released after they have expired, or if too much of a resource is requested at once, as can occur with memory. Automated analysis of configuration files may be able to detect settings that do not specify a maximum value. Automated static analysis tools will not be appropriate for detecting exhaustion of custom resources, such as an intended security policy in which a bulletin board user is only allowed to make a limited number of posts per day.::",,,::125::130::147::197::229::230::231::469::482::486::487::488::489::490::491::493::494::495::496::528::,
771,"The product does not properly maintain a reference to a resource that has been allocated, which prevents the resource from being reclaimed.",,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,,
772,"The product does not release a resource after its effective lifetime has ended, i.e., after the resource is no longer needed.",,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,::469::,
776,"The product uses XML documents and allows their structure to be defined with a Document Type Definition (DTD), but it does not properly control the number of recursive definitions of entities.",,::PHASE:Implementation::PHASE:Operation::,,,,,::197::,
778,"When a security-critical event occurs, the product either does not record the event or omits important details about the event when logging it.",,::PHASE:Operation:NOTE:COMMISSION: This weakness refers to an incorrect design related to an architectural security tactic.::,,,,,,
779,"The product logs too much information, making log files hard to process and possibly hindering recovery efforts or forensic analysis after an attack.",,::PHASE:Operation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::,,,,,,
783,The product uses an expression in which operator precedence causes incorrect logic to be used.,,"::PHASE:Implementation:NOTE:Logic errors related to operator precedence may cause problems even during normal operation, so they are probably discovered quickly during the testing phase. If testing is incomplete or there is a strong reliance on manual review of the code, then these errors may not be discovered before the software is deployed.::",,,,,,
786,The product reads or writes to a buffer using an index or pointer that references a memory location prior to the beginning of the buffer.,,,,,,,,
787,"The product writes data past the end, or before the beginning, of the intended buffer.",,::PHASE:Implementation::,,"::METHOD:Automated Static Analysis:DESCRIPTION:This weakness can often be detected using automated static analysis tools. Many modern tools use data flow analysis or constraint-based techniques to minimize the number of false positives. Automated static analysis generally does not account for environmental considerations when reporting out-of-bounds memory operations. This can make it difficult for users to determine which warnings should be investigated first. For example, an analysis tool might report buffer overflows that originate from command line arguments in a program that is not expected to run with setuid or other special privileges.:EFFECTIVENESS:High::METHOD:Automated Dynamic Analysis:DESCRIPTION:This weakness can be detected using dynamic tools and techniques that interact with the software using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The software's operation may slow down, but it should not become unstable, crash, or generate incorrect results.::",,,,
788,The product reads or writes to a buffer using an index or pointer that references a memory location after the end of the buffer.,,,,,,,,
791,"The product receives data from an upstream component, but does not completely filter special elements before sending it to a downstream component.",,::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::,,,,,,
795,"The product receives data from an upstream component, but only accounts for special elements at a specified location, thereby missing remaining special elements that may exist before sending it to a downstream component.",,::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::,,,,,,
798,"The product contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data.",,::PHASE:Architecture and Design:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::,,"::METHOD:Black Box:DESCRIPTION:Credential storage in configuration files is findable using black box methods, but the use of hard-coded credentials for an incoming authentication routine typically involves an account that is not visible outside of the code.:EFFECTIVENESS:Moderate::METHOD:Automated Static Analysis:DESCRIPTION:Automated white box techniques have been published for detecting hard-coded credentials for incoming authentication, but there is some expert disagreement regarding their effectiveness and applicability to a broad range of methods.::METHOD:Manual Static Analysis:DESCRIPTION:This weakness may be detectable using manual code analysis. Unless authentication is decentralized and applied throughout the product, there can be sufficient time for the analyst to find incoming authentication routines and examine the program logic looking for usage of hard-coded credentials. Configuration files could also be analyzed.::METHOD:Manual Dynamic Analysis:DESCRIPTION:For hard-coded credentials in incoming authentication: use monitoring tools that examine the product's process as it interacts with the operating system and the network. This technique is useful in cases when source code is unavailable, if the product was not developed by you, or if you want to verify that the build phase did not introduce any new weaknesses. Examples include debuggers that directly attach to the running process; system-call tracing utilities such as truss (Solaris) and strace (Linux); system activity monitors such as FileMon, RegMon, Process Monitor, and other Sysinternals utilities (Windows); and sniffers and protocol analyzers that monitor network traffic. Attach the monitor to the process and perform a login. Using call trees or similar artifacts from the output, examine the associated behaviors and see if any of them appear to be comparing the input to a fixed string or value.::METHOD:Automated Static Analysis - Binary or Bytecode:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Bytecode Weakness Analysis - including disassembler + source code weakness analysis Binary Weakness Analysis - including disassembler + source code weakness analysis:EFFECTIVENESS:SOAR Partial::METHOD:Manual Static Analysis - Binary or Bytecode:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Binary / Bytecode disassembler - then use manual analysis for vulnerabilities & anomalies:EFFECTIVENESS:High::METHOD:Dynamic Analysis with Manual Results Interpretation:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Network Sniffer Forced Path Execution:EFFECTIVENESS:SOAR Partial::METHOD:Manual Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Focused Manual Spotcheck - Focused manual analysis of source Manual Source Code Review (not inspections):EFFECTIVENESS:High::METHOD:Automated Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Source code Weakness Analyzer Context-configured Source Code Weakness Analyzer:EFFECTIVENESS:High::METHOD:Automated Static Analysis:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Configuration Checker:EFFECTIVENESS:SOAR Partial::METHOD:Architecture or Design Review:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.) Formal Methods / Correct-By-Construction:EFFECTIVENESS:High::",,,::191::70::,
804,"The product uses a CAPTCHA challenge, but the challenge can be guessed or automatically recognized by a non-human actor.",,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,,
805,"The product uses a sequential operation to read or write a buffer, but it uses an incorrect length value that causes it to access memory that is outside of the bounds of the buffer.",,::PHASE:Implementation::,,"::METHOD:Automated Static Analysis:DESCRIPTION:This weakness can often be detected using automated static analysis tools. Many modern tools use data flow analysis or constraint-based techniques to minimize the number of false positives. Automated static analysis generally does not account for environmental considerations when reporting out-of-bounds memory operations. This can make it difficult for users to determine which warnings should be investigated first. For example, an analysis tool might report buffer overflows that originate from command line arguments in a program that is not expected to run with setuid or other special privileges.:EFFECTIVENESS:High::METHOD:Automated Dynamic Analysis:DESCRIPTION:This weakness can be detected using dynamic tools and techniques that interact with the product using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The product's operation may slow down, but it should not become unstable, crash, or generate incorrect results.:EFFECTIVENESS:Moderate::METHOD:Manual Analysis:DESCRIPTION:Manual analysis can be useful for finding this weakness, but it might not achieve desired code coverage within limited time constraints. This becomes difficult for weaknesses that must be considered for all inputs, since the attack surface can be too large.::",,::Memory::,::100::256::,
807,"The product uses a protection mechanism that relies on the existence or values of an input, but the input can be modified by an untrusted actor in a way that bypasses the protection mechanism.",,::PHASE:Architecture and Design:NOTE:COMMISSION: This weakness refers to an incorrect design related to an architectural security tactic.::PHASE:Implementation::,,"::METHOD:Manual Static Analysis:DESCRIPTION:Since this weakness does not typically appear frequently within a single software package, manual white box techniques may be able to provide sufficient code coverage and reduction of false positives if all potentially-vulnerable operations can be assessed within limited time constraints.:EFFECTIVENESS:High::METHOD:Automated Static Analysis - Binary or Bytecode:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Bytecode Weakness Analysis - including disassembler + source code weakness analysis Binary Weakness Analysis - including disassembler + source code weakness analysis:EFFECTIVENESS:SOAR Partial::METHOD:Manual Static Analysis - Binary or Bytecode:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Binary / Bytecode disassembler - then use manual analysis for vulnerabilities & anomalies:EFFECTIVENESS:SOAR Partial::METHOD:Dynamic Analysis with Automated Results Interpretation:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Web Application Scanner Web Services Scanner Database Scanners:EFFECTIVENESS:SOAR Partial::METHOD:Dynamic Analysis with Manual Results Interpretation:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Fuzz Tester Framework-based Fuzzer Monitored Virtual Environment - run potentially malicious code in sandbox / wrapper / virtual machine, see if it does anything suspicious:EFFECTIVENESS:SOAR Partial::METHOD:Manual Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Manual Source Code Review (not inspections):EFFECTIVENESS:High::METHOD:Automated Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Source code Weakness Analyzer Context-configured Source Code Weakness Analyzer:EFFECTIVENESS:SOAR Partial::METHOD:Architecture or Design Review:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.) Formal Methods / Correct-By-Construction Cost effective for partial coverage: Attack Modeling:EFFECTIVENESS:High::",,,,
820,The product utilizes a shared resource in a concurrent manner but does not attempt to synchronize access to the resource.,,,,,,,,
821,"The product utilizes a shared resource in a concurrent manner, but it does not correctly synchronize access to the resource.",,,,,,,,
822,"The product obtains a value from an untrusted source, converts this value to a pointer, and dereferences the resulting pointer.",,,,,,,::129::,
823,"The product performs pointer arithmetic on a valid pointer, but it uses an offset that can point outside of the intended range of valid memory locations for the resulting pointer.",,,,,,,::129::,
824,The product accesses or uses a pointer that has not been initialized.,,,,,,,,
825,"The product dereferences a pointer that contains a location for memory that was previously valid, but is no longer valid.",,,,,,,,
826,The product releases a resource that is still intended to be used by itself or another actor.,,,,,,,,
828,"The product defines a signal handler that contains code sequences that are not asynchronous-safe, i.e., the functionality is not reentrant, or it can be interrupted.",,,,,,,,
829,"The product imports, requires, or includes executable functionality (such as a library) from a source that is outside of the intended control sphere.",,::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::,,"::METHOD:Automated Static Analysis - Binary or Bytecode:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Bytecode Weakness Analysis - including disassembler + source code weakness analysis:EFFECTIVENESS:SOAR Partial::METHOD:Manual Static Analysis - Binary or Bytecode:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Binary / Bytecode disassembler - then use manual analysis for vulnerabilities & anomalies:EFFECTIVENESS:SOAR Partial::METHOD:Dynamic Analysis with Manual Results Interpretation:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Forced Path Execution Monitored Virtual Environment - run potentially malicious code in sandbox / wrapper / virtual machine, see if it does anything suspicious:EFFECTIVENESS:SOAR Partial::METHOD:Manual Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Manual Source Code Review (not inspections) Cost effective for partial coverage: Focused Manual Spotcheck - Focused manual analysis of source:EFFECTIVENESS:High::METHOD:Automated Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Source code Weakness Analyzer Context-configured Source Code Weakness Analyzer:EFFECTIVENESS:SOAR Partial::METHOD:Architecture or Design Review:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.) Formal Methods / Correct-By-Construction Cost effective for partial coverage: Attack Modeling:EFFECTIVENESS:High::",,,::175::201::228::251::252::253::263::538::549::640::660::695::698::,
831,The product defines a function that is used as a handler for more than one signal.,,,,,,,,
832,The product attempts to unlock a resource that is not locked.,,,,,,,,
833,"The product contains multiple threads or executable segments that are waiting for each other to release a necessary lock, resulting in deadlock.",,,,,,,::25::,
835,"The product contains an iteration or loop with an exit condition that cannot be reached, i.e., an infinite loop.",,,,,,,,
836,"The product records password hashes in a data store, receives a hash of a password from a client, and compares the supplied hash to the hash obtained from the data store.",,::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::,,,,,::644::652::,
837,"The product requires that an actor should only be able to perform an action once, or to have only one unique action, but the product does not enforce or improperly enforces this restriction.",,,,,,,,
838,"The product uses or specifies an encoding when generating output to a downstream component, but the specified encoding is not the same as the encoding that is expected by the downstream component.",,,,,,,::468::,
839,"The product checks a value to ensure that it is less than or equal to a maximum, but it does not also verify that the value is greater than or equal to the minimum.",,,,,,,,
841,"The product supports a session in which more than one behavior must be performed by an actor, but it does not properly ensure that the actor performs the behaviors in the required sequence.",,::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::,,,,,,
842,The product or the administrator places a user into an incorrect group.,,::PHASE:Implementation::PHASE:Operation::,,,,,,
843,"The product allocates or initializes a resource such as a pointer, object, or variable using one type, but it later accesses that resource using a type that is incompatible with the original type.",,::PHASE:Implementation::,,,,,,
908,The product uses or accesses a resource that has not been initialized.,,::PHASE:Implementation::,,,,,,
909,The product does not initialize a critical resource.,,::PHASE:Implementation::,,,,,,
910,The product uses or accesses a file descriptor after it has been closed.,,::PHASE:Implementation::,,,,,,
911,"The product uses a reference count to manage a resource, but it does not update or incorrectly updates the reference count.",,::PHASE:Implementation::,,,,,,
914,The product does not properly restrict reading from or writing to dynamically-identified variables.,,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,,
915,"The product receives input from an upstream component that specifies multiple attributes, properties, or fields that are to be initialized or updated in an object, but it does not properly control which attributes can be modified.",,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,,
916,"The product generates a hash for a password, but it uses a scheme that does not provide a sufficient level of computational effort that would make password cracking attacks infeasible or expensive.",,::PHASE:Architecture and Design:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::,,"::METHOD:Automated Static Analysis - Binary or Bytecode:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Bytecode Weakness Analysis - including disassembler + source code weakness analysis Binary Weakness Analysis - including disassembler + source code weakness analysis:EFFECTIVENESS:SOAR Partial::METHOD:Manual Static Analysis - Binary or Bytecode:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Binary / Bytecode disassembler - then use manual analysis for vulnerabilities & anomalies:EFFECTIVENESS:SOAR Partial::METHOD:Manual Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Focused Manual Spotcheck - Focused manual analysis of source Manual Source Code Review (not inspections):EFFECTIVENESS:High::METHOD:Automated Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Source code Weakness Analyzer Context-configured Source Code Weakness Analyzer:EFFECTIVENESS:High::METHOD:Automated Static Analysis:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Configuration Checker:EFFECTIVENESS:SOAR Partial::METHOD:Architecture or Design Review:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Formal Methods / Correct-By-Construction Cost effective for partial coverage: Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.):EFFECTIVENESS:High::",,,::55::,
917,"The product constructs all or part of an expression language (EL) statement in a framework such as a Java Server Page (JSP) using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended EL statement before it is executed.",,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,,
918,"The web server receives a URL or similar request from an upstream component and retrieves the contents of this URL, but it does not sufficiently ensure that the request is being sent to the expected destination.",,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,::664::,
920,"The product operates in an environment in which power is a limited resource that cannot be automatically replenished, but the product does not properly restrict the amount of power that its operation consumes.",,::PHASE:Architecture and Design::,,,,,,
921,The product stores sensitive information in a file system or device that does not have built-in access control.,,::PHASE:Architecture and Design:NOTE:OMISSION: This weakness is caused by missing a security tactic during the architecture and design phase.::,,,,,,
924,"The product establishes a communication channel with an endpoint and receives a message from that endpoint, but it does not sufficiently ensure that the message was not modified during transmission.",,::PHASE:Architecture and Design:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::,,,,,,
939,"The product uses a handler for a custom URL scheme, but it does not properly restrict which actors can invoke the handler using the scheme.",,::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::,,,,,,
940,"The product establishes a communication channel to handle an incoming request that has been initiated by an actor, but it does not properly verify that the request is coming from the expected origin.",,::PHASE:Architecture and Design::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::,,,,,::500::594::595::596::,
941,"The product creates a communication channel to initiate an outgoing request to an actor, but it does not correctly specify the intended destination for that actor.",,::PHASE:Architecture and Design::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::,,,,,,
1007,"The product displays information or identifiers to a user, but the display mechanism does not make it easy for the user to distinguish between visually similar or identical glyphs (homoglyphs), which may cause the user to misinterpret a glyph and perform an unintended, insecure action.",,"::PHASE:Architecture and Design:NOTE:This weakness may occur when characters from various character sets are allowed to be interchanged within a URL, username, email address, etc. without any notification to the user or underlying system being used.::PHASE:Implementation::",,"::METHOD:Manual Dynamic Analysis:DESCRIPTION:If utilizing user accounts, attempt to submit a username that contains homoglyphs. Similarly, check to see if links containing homoglyphs can be sent via email, web browsers, or other mechanisms.:EFFECTIVENESS:Moderate::",,,::632::,
1021,"The web application does not restrict or incorrectly restricts frame objects or UI layers that belong to another application or domain, which can lead to user confusion about which interface the user is interacting with.",,::PHASE:Implementation::,,,,,::103::181::222::504::506::587::654::,
1024,"The product performs a comparison between two entities, but the entities are of different, incompatible types that cannot be guaranteed to provide correct results when they are directly compared.",,::PHASE:Implementation::,,,,,,
1025,"The code performs a comparison between two entities, but the comparison examines the wrong factors or characteristics of the entities, which can lead to incorrect results and resultant weaknesses.",,::PHASE:Implementation::,,,,,,
1037,"The developer builds a security-critical protection mechanism into the software, but the processor optimizes the execution of the program such that the mechanism is removed or modified.",,::PHASE:Architecture and Design:NOTE:Optimizations built into the design of the processor can have unintended consequences during the execution of an application.::,,::METHOD:White Box:DESCRIPTION:In theory this weakness can be detected through the use of white box testing techniques where specifically crafted test cases are used in conjunction with debuggers to verify the order of statements being executed.:EFFECTIVENESS:Opportunistic::,,,::663::,
1041,"The product has multiple functions, methods, procedures, macros, etc. that contain the same code.",,,,,,,,
1043,The product uses a data element that has an excessively large number of sub-elements with non-primitive data types such as structures or aggregated objects.,,,,,,,,
1044,The product's architecture contains too many - or too few - horizontal layers.,,::PHASE:Architecture and Design::,,,,,,
1046,The product creates an immutable text string using string concatenation operations.,,,,,,,,
1047,"The product contains modules in which one module has references that cycle back to itself, i.e., there are circular dependencies.",,,,,,,,
1048,"The code contains callable control elements that contain an excessively large number of references to other application objects external to the context of the callable, i.e. a Fan-Out value that is excessively large.",,,,,,,,
1049,The product performs a data query with a large number of joins and sub-queries on a large data table.,,,,,,,,
1050,"The product has a loop body or loop condition that contains a control element that directly or indirectly consumes platform resources, e.g. messaging, sessions, locks, or file descriptors.",,,,,,,,
1051,The product initializes data using hard-coded values that act as network resource identifiers.,,,,,,,,
1052,The product initializes a data element using a hard-coded literal that is not a simple integer or static constant element.,,,,,,,,
1053,The product does not have documentation that represents how it is designed.,,,,,,,,
1054,"The code at one architectural layer invokes code that resides at a deeper layer than the adjacent layer, i.e., the invocation skips at least one layer, and the invoked code is not part of a vertical utility layer that can be referenced from any horizontal layer.",,,,,,,,
1055,The product contains a class with inheritance from more than one concrete class.,,,,,,,,
1056,A named-callable or method control element has a signature that supports a variable (variadic) number of parameters or arguments.,,,,,,,,
1057,"The product uses a dedicated, central data manager component as required by design, but it contains code that performs data-access operations that do not use this data manager.",,,,,,,,
1058,The code contains a function or method that operates in a multi-threaded environment but owns an unsafe non-final static storable or member data element.,,,,,,,,
1060,The product performs too many data queries without using efficient data processing functionality such as stored procedures.,,,,,,,,
1062,"The code has a parent class that contains references to a child class, its methods, or its members.",,,,,,,,
1063,A static code block creates an instance of a class.,,,,,,,,
1064,"The product contains a function, subroutine, or method whose signature has an unnecessarily large number of parameters/arguments.",,,,,,,,
1065,"The product uses deployed components from application servers, but it also uses low-level functions/methods for management of resources, instead of the API provided by the application server.",,,,,,,,
1066,The product contains a serializable data element that does not have an associated serialization method.,,,,,,,,
1067,The product contains a data query against an SQL table or view that is configured in a way that does not utilize an index and may cause sequential searches to be performed.,,,,,,,,
1068,The implementation of the product is not consistent with the design as described within the relevant documentation.,,::PHASE:Implementation::PHASE:Architecture and Design::,,,,,,
1069,"An invokable code block contains an exception handling block that does not contain any code, i.e. is empty.",,,,,,,,
1070,"The product contains a serializable, storable data element such as a field or member, but the data element contains member elements that are not serializable.",,,,,,,,
1071,"The source code contains a block that does not contain any code, i.e., the block is empty.",,,,,,,,
1072,The product accesses a data resource through a database without using a connection pooling capability.,,,,,,,,
1073,"The product contains a client with a function or method that contains a large number of data accesses/queries that are sent through a data manager, i.e., does not use efficient database capabilities.",,,,,,,,
1074,"A class has an inheritance level that is too high, i.e., it has a large number of parent classes.",,,,,,,,
1075,The product performs unconditional control transfer (such as a goto) in code outside of a branching structure such as a switch block.,,,,,,,,
1079,"A parent class contains one or more child classes, but the parent class does not have a virtual destructor method.",,,,,,,,
1080,A source code file has too many lines of code.,,,,,,,,
1082,The code contains a class instance that calls the method or function to delete or destroy itself.,,,,,,,,
1083,"The product is intended to manage data access through a particular data manager component such as a relational or non-SQL database, but it contains code that performs data access operations without using that component.",,,,,,,,
1084,A function or method contains too many operations that utilize a data manager or file resource.,,,,,,,,
1085,"A function, method, procedure, etc. contains an excessive amount of code that has been commented out within its body.",,,,,,,,
1086,A class contains an unnecessarily large number of children.,,,,,,,,
1087,"A class contains a virtual method, but the method does not have an associated virtual destructor.",,,,,,,,
1088,"The code has a synchronous call to a remote resource, but there is no timeout for the call, or the timeout is set to infinite.",,,,,,,,
1089,The product uses a large data table that contains an excessively large number of indices.,,,,,,,,
1090,A method for a class performs an operation that directly accesses a member element from another class.,,,,,,,,
1091,The product contains a method that accesses an object but does not later invoke the element's associated finalize/destructor method.,,,,,,,,
1092,The product uses the same control element across multiple architectural layers.,,,,,,,,
1094,"The product contains an index range scan for a large data table, but the scan can cover a large number of rows.",,,,,,,,
1095,The product uses a loop with a control flow condition based on a value that is updated within the body of the loop.,,,,,,,,
1097,The product uses a storable data element that does not have all of the associated functions or methods that are necessary to support comparison.,,,,,,,,
1099,"The product's code, documentation, or other artifacts do not consistently use the same naming conventions for variables, callables, groups of related callables, I/O capabilities, data types, file names, or similar types of elements.",,,,,,,,
1100,The product or code does not isolate system-dependent functionality into separate standalone modules.,,,,,,,,
1101,The product uses automatically-generated code that cannot be executed without a specific runtime support component.,,,,,,,,
1102,"The code uses a data representation that relies on low-level data representation or constructs that may vary across different processors, physical machines, OSes, or other physical components.",,,,,,,,
1103,The product relies on third-party components that do not provide equivalent functionality across all desirable platforms.,,,,,,,,
1104,The product relies on third-party components that are not actively supported or maintained by the original developer or a trusted proxy for the original developer.,,,,,,,,
1105,"The product or code uses machine-dependent functionality, but it does not sufficiently encapsulate or isolate this functionality from the rest of the code.",,,,,,,,
1106,"The source code uses literal constants that may need to change or evolve over time, instead of using symbolic constants.",,,,,,,,
1107,"The source code uses symbolic constants, but it does not sufficiently place the definitions of these constants into a more centralized or isolated location.",,,,,,,,
1108,"The code is structured in a way that relies too much on using or setting global variables throughout various points in the code, instead of preserving the associated information in a narrower, more local context.",,,,,,,,
1109,"The code contains a callable, block, or other code element in which the same variable is used to control more than one unique task or store more than one instance of data.",,,,,,,,
1110,"The product's design documentation does not adequately describe control flow, data flow, system initialization, relationships between tasks, components, rationales, or other important aspects of the design.",,,,,,,,
1111,"The product's documentation does not adequately define inputs, outputs, or system/software interfaces.",,,,,,,,
1112,The document does not fully define all mechanisms that are used to control or influence how product-specific programs are executed.,,,,,,,,
1113,The source code uses comment styles or formats that are inconsistent or do not follow expected standards for the product.,,,,,,,,
1114,The source code contains whitespace that is inconsistent across the code or does not follow expected standards for the product.,,,,,,,,
1115,The source code contains elements such as source files that do not consistently provide a prologue or header that has been standardized for the project.,,,,,,,,
1116,The source code contains comments that do not accurately describe or explain aspects of the portion of the code with which the comment is associated.,,,,,,,,
1117,"The code contains a function or method whose signature and/or associated inline documentation does not sufficiently describe the callable's inputs, outputs, side effects, assumptions, or return codes.",,,,,,,,
1118,"The documentation does not sufficiently describe the techniques that are used for error handling, exception processing, or similar mechanisms.",,,,,,,,
1119,The code uses too many unconditional branches (such as goto).,,,,,,,,
1121,The code contains McCabe cyclomatic complexity that exceeds a desirable maximum.,,,,,,,,
1122,The code is structured in a way that a Halstead complexity measure exceeds a desirable maximum.,,,,,,,,
1123,The product uses too much self-modifying code.,,,,,,,,
1124,The code contains a callable or other code grouping in which the nesting / branching is too deep.,,,,,,,,
1125,The product has an attack surface whose quantitative measurement exceeds a desirable maximum.,,,,,,,,
1126,"The source code declares a variable in one scope, but the variable is only used within a narrower scope.",,,,,,,,
1127,"The code is compiled without sufficient warnings enabled, which may prevent the detection of subtle bugs or quality issues.",,::PHASE:Build and Compilation::,,,,,,
1173,"The product does not use, or incorrectly uses, an input validation framework that is provided by the source language or an independent library.",,::PHASE:Architecture and Design:NOTE:This weakness may occur when software designers choose to not leverage input validation frameworks provided by the source language.::PHASE:Implementation:NOTE:This weakness may occur when developers do not correctly use a provided input validation framework.::,,"::METHOD:Automated Static Analysis:DESCRIPTION:Some instances of improper input validation can be detected using automated static analysis. A static analysis tool might allow the user to specify which application-specific methods or functions perform input validation; the tool might also have built-in knowledge of validation frameworks such as Struts. The tool may then suppress or de-prioritize any associated warnings. This allows the analyst to focus on areas of the software in which input validation does not appear to be present. Except in the cases described in the previous paragraph, automated static analysis might not be able to recognize when proper input validation is being performed, leading to false positives - i.e., warnings that do not have any security consequences or require any code changes.::",,,,
1188,"The product initializes or sets a resource with a default that is intended to be changed by the administrator, but the default is not secure.",,,,,,,::665::,
1189,The System-On-a-Chip (SoC) does not properly isolate shared resources between trusted and untrusted agents.,,::PHASE:Architecture and Design::PHASE:Implementation::,,"::METHOD:Automated Dynamic Analysis:DESCRIPTION:Pre-silicon / post-silicon: Test access to shared systems resources (memory ranges, control registers, etc.) from untrusted software to verify that the assets are not incorrectly exposed to untrusted agents. Note that access to shared resources can be dynamically allowed or revoked based on system flows. Security testing should cover such dynamic shared resource allocation and access control modification flows.:EFFECTIVENESS:High::",,,::124::,
1190,"The product enables a Direct Memory Access (DMA) capable device before the security configuration settings are established, which allows an attacker to extract data from or gain privileges on the product.",,::PHASE:Architecture and Design::,,,,,::180::,
1191,The chip does not implement or does not correctly perform access control to check whether users are authorized to access internal registers and test modes through the physical debug/test interface.,,::PHASE:Architecture and Design::PHASE:Implementation::,,::METHOD:Dynamic Analysis with Manual Results Interpretation:DESCRIPTION:Authentication and authorization of debug and test interfaces should be part of the architecture and design review process. Withholding of private register documentation from the debug and test interface public specification (Security by obscurity) should not be considered as sufficient security.::METHOD:Dynamic Analysis with Manual Results Interpretation:DESCRIPTION:Dynamic tests should be done in the pre-silicon and post-silicon stages to verify that the debug and test interfaces are not open by default.::METHOD:Fuzzing:DESCRIPTION:Tests that fuzz Debug and Test Interfaces should ensure that no access without appropriate authentication and authorization is possible.:EFFECTIVENESS:Moderate::,,,::1::180::,
1192,"The System-on-Chip (SoC) does not have unique, immutable identifiers for each of its components.",,::PHASE:Architecture and Design::PHASE:Implementation::PHASE:Operation::,,,,,::113::,
1193,The product enables components that contain untrusted firmware before memory and fabric access controls have been enabled.,,,,,,,::1::180::,
1204,"The product uses a cryptographic primitive that uses an Initialization Vector (IV), but the product does not generate IVs that are sufficiently unpredictable or unique according to the expected cryptographic requirements for that primitive.",,::PHASE:Implementation::PHASE:Architecture and Design::,,,::Cryptography::,,::20::97::,
1209,"The reserved bits in a hardware design are not disabled prior to production. Typically, reserved bits are used for future capabilities and should not support any functional logic in the design. However, designers might covertly use these bits to debug or further develop new capabilities in production hardware. Adversaries with access to these bits will write to them in hopes of compromising hardware state.",,"::PHASE:Architecture and Design:NOTE:The Designer and Implementer have to make a conscious choice to do this::PHASE:Implementation:NOTE:The Designer and Implementer have to make a conscious choice to do this::PHASE:Documentation:NOTE:If documentation labels anything for future use, reserved, or the like, such labeling could indicate to an attacker a potential attack point::",,,,,::121::,
1220,"The product implements access controls via a policy or other feature with the intention to disable or restrict accesses (reads and/or writes) to assets in a system from untrusted agents. However, implemented access controls lack required granularity, which renders the control policy too broad because it allows accesses from unauthorized agents to the security-sensitive assets.",,::PHASE:Architecture and Design:NOTE:Such issues could be introduced during hardware architecture and design and identified later during Testing or System Configuration phases.::PHASE:Implementation:NOTE:Such issues could be introduced during hardware implementation and identified later during Testing or System Configuration phases.::,,,,,::1::180::,
1221,Hardware description language code incorrectly defines register defaults or hardware IP parameters to insecure values.,,"::PHASE:Implementation:NOTE:Such issues could be introduced during implementation of hardware design, since IP parameters and defaults are defined in HDL code and identified later during Testing or System Configuration phases.::",,,,,::166::,
1223,"A write-once register in hardware design is programmable by an untrusted software component earlier than the trusted software component, resulting in a race condition issue.",,::PHASE:Architecture and Design:NOTE:This weakness can appear in designs that use register write-once attributes with two or more software/firmware modules with varying levels of trust executing in parallel.::,,,,,::26::,
1224,"The hardware design control register sticky bits or write-once bit fields are improperly implemented, such that they can be reprogrammed by software.",,"::PHASE:Architecture and Design::PHASE:Implementation:NOTE:Such issues could be introduced during implementation of hardware design, since IP parameters and defaults are defined in HDL code and identified later during Testing or System Configuration phases.::",,,,,::680::,
1230,"The product prevents direct access to a resource containing sensitive information, but it does not sufficiently limit access to metadata that is derived from the original, sensitive information.",,,,,,,,
1231,"The product uses a trusted lock bit for restricting access to registers, address regions, or other resources, but the product does not prevent the value of the lock bit from being modified after it has been set.",,::PHASE:Architecture and Design:NOTE:Such issues could be introduced during hardware architecture and design and identified later during Testing or System Configuration phases.::PHASE:Implementation:NOTE:Such issues could be introduced during implementation and identified later during Testing or System Configuration phases.::,,"::METHOD:Manual Analysis:DESCRIPTION:Set the lock bit. Power cycle the device. Attempt to clear the lock bit. If the information is changed, implement a design fix. Retest. Also, attempt to indirectly clear the lock bit or bypass it.:EFFECTIVENESS:High::",,,::680::,
1232,"Register lock bit protection disables changes to system configuration once the bit is set. Some of the protected registers or lock bits become programmable after power state transitions (e.g., Entry and wake from low power sleep modes) causing the system configuration to be changeable.",,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,::166::,
1233,"The product uses a register lock bit protection mechanism, but it does not ensure that the lock bit prevents modification of system registers or controls that perform changes to important hardware system configuration.",,::PHASE:Architecture and Design:NOTE:Such issues could be introduced during hardware architecture and design and identified later during Testing or System Configuration phases.::PHASE:Implementation:NOTE:Such issues could be introduced during implementation and identified later during Testing or System Configuration phases.::,,"::METHOD:Manual Analysis:DESCRIPTION:Set the lock bit. Attempt to modify the information protected by the lock bit. If the information is changed, implement a design fix. Retest. Also, attempt to indirectly clear the lock bit or bypass it.:EFFECTIVENESS:High::",,,::176::680::,
1234,System configuration protection may be bypassed during debug mode.,,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,::176::,
1235,"The code uses boxed primitives, which may introduce inefficiencies into performance-critical operations.",,::PHASE:Implementation:NOTE:The programmer may use boxed primitives when not strictly necessary.::,,,,,,
1236,"The product saves user-provided information into a Comma-Separated Value (CSV) file, but it does not neutralize or incorrectly neutralizes special elements that could be interpreted as a command when the file is opened by a spreadsheet product.",,"::PHASE:Implementation:NOTE:The weakness is in the implementation of a software's CSV export feature, in particular how it formats formula entries as the output gets flattened into a text file.::",,,,,,
1240,"To fulfill the need for a cryptographic primitive, the product implements a cryptographic algorithm using a non-standard, unproven, or disallowed/non-compliant cryptographic implementation.",,"::PHASE:Architecture and Design:NOTE:This weakness is primarily introduced during the architecture and design phase as risky primitives are included.::PHASE:Implementation:NOTE:Even in cases where the Architectural phase properly specifies a cryptographically secure design, the design may be changed during implementation due to unforeseen constraints.::",,"::METHOD:Architecture or Design Review:DESCRIPTION:Review requirements, documentation, and product design to ensure that primitives are consistent with the strongest-available recommendations from trusted parties. If the product appears to be using custom or proprietary implementations that have not had sufficient public review and approval, then this is a significant concern.:EFFECTIVENESS:High::METHOD:Manual Analysis:DESCRIPTION:Analyze the product to ensure that implementations for each primitive do not contain any known vulnerabilities and are not using any known-weak algorithms, including MD4, MD5, SHA1, DES, etc.:EFFECTIVENESS:Moderate::METHOD:Dynamic Analysis with Manual Results Interpretation:DESCRIPTION:For hardware, during the implementation (pre-Silicon / post-Silicon) phase, dynamic tests should be done to ensure that outputs from cryptographic routines are indeed working properly, such as test vectors provided by NIST [REF-1236].:EFFECTIVENESS:Moderate::METHOD:Dynamic Analysis with Manual Results Interpretation:DESCRIPTION:It needs to be determined if the output of a cryptographic primitive is lacking entropy, which is one clear sign that something went wrong with the crypto implementation. There exist many methods of measuring the entropy of a bytestream, from sophisticated ones (like calculating Shannon's entropy of a sequence of characters) to crude ones (by compressing it and comparing the size of the original bytestream vs. the compressed - a truly random byte stream should not be compressible and hence the uncompressed and compressed bytestreams should be nearly identical in size).:EFFECTIVENESS:Moderate::",,,::97::,
1241,The device uses an algorithm that is predictable and generates a pseudo-random number.,,"::PHASE:Architecture and Design::PHASE:Implementation:NOTE:In many cases, the design originally defines a cryptographically secure random number generator, but is then changed during implementation due to unforeseen constraints.::",,,,,::97::,
1242,The device includes chicken bits or undocumented features that can create entry points for unauthorized actors.,,::PHASE:Architecture and Design::PHASE:Implementation::PHASE:Documentation::,,,,,::212::36::,
1243,Access to security-sensitive information stored in fuses is not limited during debug.,,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,::116::545::,
1244,"The product uses physical debug or test interfaces with support for multiple access levels, but it assigns the wrong debug access level to an internal asset, providing unintended access to the asset from untrusted debug agents.",,::PHASE:Architecture and Design::PHASE:Implementation::,,"::METHOD:Manual Analysis:DESCRIPTION:Check 2 devices for their passcode to authenticate access to JTAG/debugging ports. If the passcodes are missing or the same, update the design to fix and retest. Check communications over JTAG/debugging ports for encryption. If the communications are not encrypted, fix the design and retest.:EFFECTIVENESS:Moderate::",,,::114::,
1245,"Faulty finite state machines (FSMs) in the hardware logic allow an attacker to put the system in an undefined state, to cause a denial of service (DoS) or gain privileges on the victim's system.",,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,::74::,
1246,The product does not implement or incorrectly implements wear leveling operations in limited-write non-volatile memories.,,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,::212::,
1247,The device does not contain or contains incorrectly implemented circuitry or sensors to detect and mitigate voltage and clock glitches and protect sensitive information or software contained on the device.,,::PHASE:Operation::,,"::METHOD:Manual Analysis:DESCRIPTION:Put the processor in an infinite loop, which is then followed by instructions that should not ever be executed, since the loop is not expected to exit. After the loop, toggle an I/O bit (for oscilloscope monitoring purposes), print a console message, and reenter the loop. Note that to ensure that the loop exit is actually captured, many NOP instructions should be coded after the loop branch instruction and before the I/O bit toggle and the print statement. Margining the clock consists of varying the clock frequency until an anomaly occurs. This could be a continuous frequency change or it could be a single cycle. The single cycle method is described here. For every 1000th clock pulse, the clock cycle is shortened by 10 percent. If no effect is observed, the width is shortened by 20%. This process is continued in 10% increments up to and including 50%. Note that the cycle time may be increased as well, down to seconds per cycle. Separately, the voltage is margined. Note that the voltage could be increased or decreased. Increasing the voltage has limits, as the circuitry may not be able to withstand a drastically increased voltage. This process starts with a 5% reduction of the DC supply to the CPU chip for 5 millisecond repeated at 1KHz. If this has no effect, the process is repeated, but a 10% reduction is used. This process is repeated at 10% increments down to a 50% reduction. If no effects are observed at 5 millisecond, the whole process is repeated using a 10 millisecond pulse. If no effects are observed, the process is repeated in 10 millisecond increments out to 100 millisecond pulses. While these are suggested starting points for testing circuitry for weaknesses, the limits may need to be pushed further at the risk of device damage. See [REF-1217] for descriptions of Smart Card attacks against a clock (section 14.6.2) and using a voltage glitch (section 15.5.3).:EFFECTIVENESS:Moderate::METHOD:Dynamic Analysis with Manual Results Interpretation:DESCRIPTION:During the implementation phase where actual hardware is available, specialized hardware tools and apparatus such as ChipWhisperer may be used to check if the platform is indeed susceptible to voltage and clock glitching attacks.::METHOD:Architecture or Design Review:DESCRIPTION:Review if the protections against glitching merely transfer the attack target. For example, suppose a critical authentication routine that an attacker would want to bypass is given the protection of modifying certain artifacts from within that specific routine (so that if the routine is bypassed, one can examine the artifacts and figure out that an attack must have happened). However, if the attacker has the ability to bypass the critical authentication routine, they might also have the ability to bypass the other protection routine that checks the artifacts. Basically, depending on these kind of protections is akin to resorting to Security by Obscurity.::METHOD:Architecture or Design Review:DESCRIPTION:Many SoCs come equipped with a built-in Dynamic Voltage and Frequency Scaling (DVFS) that can control the voltage and clocks via software alone. However, there have been demonstrated attacks (like Plundervolt and CLKSCREW) that target this DVFS [REF-1081] [REF-1082]. During the design and implementation phases, one needs to check if the interface to this power management feature is available from unprivileged SW (CWE-1256), which would make the attack very easy.::",::Power::Clock::,,::624::625::,
1248,The security-sensitive hardware module contains semiconductor defects.,,"::PHASE:Manufacturing:NOTE:May be introduced due to issues in the manufacturing environment or improper handling of components, for example.::PHASE:Operation:NOTE:May be introduced by improper handling or usage outside of rated operating environments (temperature, humidity, etc.)::",,,,,::624::625::,
1249,"The product provides an application for administrators to manage parts of the underlying operating system, but the application does not accurately identify all of the relevant entities or resources that exist in the OS; that is, the application's model of the OS's state is inconsistent with the OS's actual state.",,::PHASE:Architecture and Design:NOTE:The design might assume that the underlying OS does not change.::PHASE:Implementation:NOTE:Assumptions about the underlying OS might be hard-coded into the application or otherwise in external data stores in a way that is not updated when the OS's state changes.::,,,,,,
1250,The product has or supports multiple distributed components or sub-systems that are each required to keep their own local copy of shared data - such as state or cache - but the product does not ensure that all local copies remain consistent with each other.,,,,,,,,
1251,The product's architecture mirrors regions without ensuring that their contents always stay in sync.,,,,,,,,
1252,The CPU is not configured to provide hardware support for exclusivity of write and execute operations on memory. This allows an attacker to execute data from all of memory.,,::PHASE:Architecture and Design::,,,,,::679::,
1253,The logic level used to set a system to a secure state relies on a fuse being unblown. An attacker can set the system to an insecure state merely by blowing the fuse.,,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,::74::,
1254,"The product's comparison logic is performed over a series of steps rather than across the entire string in one operation. If there is a comparison logic failure on one of these steps, the operation may be vulnerable to a timing attack that can result in the interception of the process for nefarious purposes.",,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,::26::,
1256,"The product provides software-controllable device functionality for capabilities such as power and clock management, but it does not properly limit functionality that can lead to modification of hardware memory or register bits, or the ability to observe physical side channels.",,::PHASE:Architecture and Design:NOTE:An architect may initiate introduction of this weakness via exacting requirements for software accessible power/clock management requirements::PHASE:Implementation:NOTE:An implementer may introduce this weakness by assuming there are no consequences to unbounded power and clock management for secure components from untrusted ones.::,,"::METHOD:Manual Analysis:DESCRIPTION:Perform a security evaluation of system-level architecture and design with software-aided physical attacks in scope.::METHOD:Automated Dynamic Analysis:DESCRIPTION:Use custom software to change registers that control clock settings or power settings to try to bypass security locks, or repeatedly write DRAM to try to change adjacent locations. This can be effective in extracting or changing data. The drawback is that it cannot be run before manufacturing, and it may require specialized software.:EFFECTIVENESS:Moderate::",::Power::Clock::,,::624::625::,
1257,Aliased or mirrored memory regions in hardware designs may have inconsistent read/write permissions enforced by the hardware. A possible result is that an untrusted agent is blocked from accessing a memory region but is not blocked from accessing the corresponding aliased memory region.,,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,::456::679::,
1258,"The hardware does not fully clear security-sensitive values, such as keys and intermediate values in cryptographic operations, when debug mode is entered.",,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,::150::204::37::545::,
1259,"The System-On-A-Chip (SoC) implements a Security Token mechanism to differentiate what actions are allowed or disallowed when a transaction originates from an entity. However, the Security Tokens are improperly protected.",,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,::121::681::,
1260,"The product allows address regions to overlap, which can result in the bypassing of intended memory protection.",,::PHASE:Architecture and Design:NOTE:Such issues could be introduced during hardware architecture and design or implementation and identified later during the Testing phase.::PHASE:Implementation::,,"::METHOD:Manual Analysis:DESCRIPTION:Create a high privilege memory block of any arbitrary size. Attempt to create a lower privilege memory block with an overlap of the high privilege memory block. If the creation attempt works, fix the hardware. Repeat the test.:EFFECTIVENESS:High::",,,::456::679::,
1261,The hardware logic does not effectively handle when single-event upsets (SEUs) occur.,,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,,
1262,"The product uses memory-mapped I/O registers that act as an interface to hardware functionality from software, but there is improper access control to those registers.",,::PHASE:Architecture and Design:NOTE:This weakness may be exploited if the register interface design does not adequately protect hardware assets from software.::PHASE:Implementation:NOTE:Mis-implementation of access control policies may inadvertently allow access to hardware assets through the register interface.::,,"::METHOD:Manual Analysis:DESCRIPTION:This is applicable in the Architecture phase before implementation started. Make sure access policy is specified for the entire memory map. Manual analysis may not ensure the implementation is correct.:EFFECTIVENESS:Moderate::METHOD:Manual Analysis:DESCRIPTION:Registers controlling hardware should have access control implemented. This access control may be checked manually for correct implementation. Items to check consist of how are trusted parties set, how are trusted parties verified, how are accesses verified, etc. Effectiveness of a manual analysis will vary depending upon how complicated the interface is constructed.:EFFECTIVENESS:Moderate::METHOD:Simulation / Emulation:DESCRIPTION:Functional simulation is applicable during the Implementation Phase. Testcases must be created and executed for memory mapped registers to verify adherence to the access control policy. This method can be effective, since functional verification needs to be performed on the design, and verification for this weakness will be included. There can be difficulty covering the entire memory space during the test.:EFFECTIVENESS:Moderate::METHOD:Formal Verification:DESCRIPTION:Formal verification is applicable during the Implementation phase. Assertions need to be created in order to capture illegal register access scenarios and prove that they cannot occur. Formal methods are exhaustive and can be very effective, but creating the cases for large designs may be complex and difficult.:EFFECTIVENESS:High::METHOD:Automated Analysis:DESCRIPTION:Information flow tracking can be applicable during the Implementation phase. Security sensitive data (assets) - for example, as stored in registers - is automatically tracked over time through the design to verify the data doesn't reach illegal destinations that violate the access policies for the memory map. This method can be very effective when used together with simulation and emulation, since detecting violations doesn't rely on specific scenarios or data values. This method does rely on simulation and emulation, so testcases must exist in order to use this method.:EFFECTIVENESS:High::METHOD:Architecture or Design Review:DESCRIPTION:Manual documentation review of the system memory map, register specification, and permissions associated with accessing security-relevant functionality exposed via memory-mapped registers.:EFFECTIVENESS:Moderate::METHOD:Fuzzing:DESCRIPTION:Perform penetration testing (either manual or semi-automated with fuzzing) to verify that access control mechanisms such as the memory protection units or on-chip bus firewall settings adequately protect critical hardware registers from software access.:EFFECTIVENESS:Moderate::",,,::680::,
1264,The hardware logic for error handling and security checks can incorrectly forward data before the security check is complete.,,::PHASE:Architecture and Design:NOTE:The weakness can be introduced in the data transfer or bus protocol itself or in the implementation.::PHASE:Implementation::,,,,,::233::663::,
1265,"During execution of non-reentrant code, the product performs a call that unintentionally produces a nested invocation of the non-reentrant code.",,,,,,,::74::,
1266,"The product does not properly provide a capability for the product administrator to remove sensitive data at the time the product is decommissioned. A scrubbing capability could be missing, insufficient, or incorrect.",,::PHASE:Architecture and Design::PHASE:Policy::PHASE:Implementation::,,,,,::150::37::545::546::675::,
1267,The product uses an obsolete encoding mechanism to implement access controls.,,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,::121::681::,
1268,The product's hardware-enforced access control for a particular resource improperly accounts for privilege discrepancies between control and write policies.,,::PHASE:Architecture and Design:NOTE:This weakness may be introduced during the design of a device when the architect does not comprehensively specify all of the policies required by an agent.::PHASE:Implementation:NOTE:This weakness may be introduced during implementation if device policy restrictions do not sufficiently constrain less-privileged clients.::,,,,,::180::,
1269,The product released to market is released in pre-production or manufacturing configuration.,,::PHASE:Implementation::PHASE:Integration::PHASE:Manufacturing::,,,,,::439::,
1270,"The product implements a Security Token mechanism to differentiate what actions are allowed or disallowed when a transaction originates from an entity. However, the Security Tokens generated in the system are incorrect.",,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,::121::633::681::,
1271,Security-critical logic is not set to a known value on reset.,,::PHASE:Implementation::,,,,,::74::,
1272,"The product performs a power or debug state transition, but it does not clear sensitive information that should no longer be accessible due to changes to information access restrictions.",,::PHASE:Architecture and Design::,,"::METHOD:Manual Analysis:DESCRIPTION:Write a known pattern into each sensitive location. Enter the power/debug state in question. Read data back from the sensitive locations. If the reads are successful, and the data is the same as the pattern that was originally written, the test fails and the device needs to be fixed. Note that this test can likely be automated.:EFFECTIVENESS:High::",::Power::,,::150::37::545::546::,
1273,The credentials necessary for unlocking a device are shared across multiple parties and may expose sensitive information.,,::PHASE:Integration::PHASE:Manufacturing::,,,,,::560::,
1274,"The product conducts a secure-boot process that transfers bootloader code from Non-Volatile Memory (NVM) into Volatile Memory (VM), but it does not have sufficient access control or other protections for the Volatile Memory.",,::PHASE:Architecture and Design:NOTE:This weakness can be introduced during hardware architecture or design but can be identified later during testing.::,,"::METHOD:Manual Analysis:DESCRIPTION:Ensure the volatile memory is lockable or has locks. Ensure the volatile memory is locked for writes from untrusted agents or adversaries. Try modifying the volatile memory from an untrusted agent, and ensure these writes are dropped.:EFFECTIVENESS:High::METHOD:Manual Analysis:DESCRIPTION:Analyze the device using the following steps: 1) Identify all fabric master agents that are active during system Boot Flow when initial code is loaded from Non-volatile storage to volatile memory. 2) Identify the volatile memory regions that are used for storing loaded system executable program. 3) During system boot, test programming the identified memory regions in step 2 from all the masters identified in step 1. Only trusted masters should be allowed to write to the memory regions. For example, pluggable device peripherals should not have write access to program load memory regions.:EFFECTIVENESS:Moderate::",,,::456::679::,
1276,Signals between a hardware IP and the parent system design are incorrectly connected causing security risks.,,::PHASE:Implementation:NOTE:This weakness is introduced when integrating IP into a parent design.::,,,,,,
1277,The product does not provide its users with the ability to update or patch its firmware to address any vulnerabilities or weaknesses that may be present.,,"::PHASE:Requirements:NOTE:Requirements development might not consider the importance of updates over the lifetime of the product, or might not choose the ability due to concerns such as expense or speed to market.::PHASE:Architecture and Design:NOTE:Lack of planning during architecture development and design, or external pressures such as speed to market, could ignore the capability to update.::PHASE:Implementation:NOTE:The weakness can appear through oversight during implementation.::",,"::METHOD:Manual Analysis:DESCRIPTION:Create a new installable boot image of the current build with a minor version number change. Use the standard installation method to update the boot image. Verify that the minor version number has changed. Create a fake image. Verify that the boot updater will not install the fake image and generates an invalid image error message or equivalent.:EFFECTIVENESS:High::METHOD:Architecture or Design Review:DESCRIPTION:Check the consumer or maintainer documentation, the architecture/design documentation, or the original requirements to ensure that the documentation includes details for how to update the firmware.:EFFECTIVENESS:Moderate::METHOD:Manual Dynamic Analysis:DESCRIPTION:Determine if there is a lack of a capability to update read-only memory (ROM) structure. This could manifest as a difference between the latest firmware version and the current version within the device.:EFFECTIVENESS:High::",,,::682::,
1278,Information stored in hardware may be recovered by an attacker with the capability to capture and analyze images of the integrated circuit using techniques such as scanning electron microscopy.,,::PHASE:Architecture and Design::,,,,,::188::37::545::,
1279,Performing cryptographic operations without ensuring that the supporting inputs are ready to supply valid data may compromise the cryptographic result.,,::PHASE:Architecture and Design::PHASE:Implementation:NOTE:The decision to continue using a cryptographic unit even though the input units to it are not producing valid data will compromise the encrypted result.::,,,,,::97::,
1280,A product's hardware-based access control check occurs after the asset has been accessed.,,::PHASE:Implementation::,,,,,::180::,
1281,Specific combinations of processor instructions lead to undesirable behavior such as locking the processor until a hard reset performed.,,"::PHASE:Architecture and Design:NOTE:Unexpected behavior from certain instruction combinations can arise from bugs in the ISA::PHASE:Implementation:NOTE:Unexpected behavior from certain instruction combinations can arise because of implementation details such as speculative execution, caching etc.::",,,,,::212::,
1282,"Immutable data, such as a first-stage bootloader, device identifiers, and write-once configuration settings are stored in writable memory that can be re-programmed or updated in the field.",,"::PHASE:Implementation:NOTE:Keys, code, configuration settings, and other data should be programmed in write-once or read-only memory instead of writable memory.::",,,,,::458::679::,
1283,The register contents used for attestation or measurement reporting data to verify boot flow are modifiable by an adversary.,,"::PHASE:Architecture and Design:NOTE:Such issues can be introduced during hardware architecture or design and can be identified later during Testing or System Configuration phases.::PHASE:Implementation:NOTE:If the access-controls which protecting the reporting registers are misconfigured during implementation, this weakness can arise.::",,,,,::680::,
1284,"The product receives input that is expected to specify a quantity (such as size or length), but it does not validate or incorrectly validates that the quantity has the required properties.",,::PHASE:Implementation::,,,,,,
1285,"The product receives input that is expected to specify an index, position, or offset into an indexable resource such as a buffer or file, but it does not validate or incorrectly validates that the specified index/position/offset has the required properties.",,::PHASE:Implementation::,,,,,,
1286,"The product receives input that is expected to be well-formed - i.e., to comply with a certain syntax - but it does not validate or incorrectly validates that the input complies with the syntax.",,::PHASE:Implementation::,,,,,::66::676::,
1287,"The product receives input that is expected to be of a certain type, but it does not validate or incorrectly validates that the input is actually of the expected type.",,::PHASE:Implementation::,,,,,,
1288,"The product receives a complex input with multiple elements or fields that must be consistent with each other, but it does not validate or incorrectly validates that the input is actually consistent.",,::PHASE:Implementation::,,,,,,
1289,"The product receives an input value that is used as a resource identifier or other type of reference, but it does not validate or incorrectly validates that the input is equivalent to a potentially-unsafe value.",,::PHASE:Implementation::,,,,,,
1290,"The product implements a decoding mechanism to decode certain bus-transaction signals to security identifiers. If the decoding is implemented incorrectly, then untrusted agents can now gain unauthorized access to the asset.",,::PHASE:Implementation::PHASE:Architecture and Design::,,,,,,
1291,The same public key is used for signing both debug and production code.,,::PHASE:Implementation::,,::METHOD:Architecture or Design Review:DESCRIPTION:Compare the debug key with the production key to make sure that they are not the same.:EFFECTIVENESS:High::METHOD:Dynamic Analysis with Manual Results Interpretation:DESCRIPTION:Compare the debug key with the production key to make sure that they are not the same.:EFFECTIVENESS:High::,,,,
1292,"The product implements a conversion mechanism to map certain bus-transaction signals to security identifiers. However, if the conversion is incorrectly implemented, untrusted agents can gain unauthorized access to the asset.",,"::PHASE:Architecture and Design:NOTE:Such issues could be introduced during hardware architecture and design, then identified later during Testing or System Configuration phases.::PHASE:Implementation:NOTE:Such issues could be introduced during hardware implementation, then identified later during Testing or System Configuration phases.::",,,,,,
1293,"The product relies on one source of data, preventing the ability to detect if an adversary has compromised a data source.",,"::PHASE:Architecture and Design:NOTE:This flaw could be introduced during the design of the application or misconfiguration at run time by only specifying a single point of validation.::PHASE:Implementation:NOTE:Such issues could be introduced during hardware implementation, then identified later during Testing or System Configuration phases.::PHASE:Operation:NOTE:This weakness could be introduced by intentionally failing all but one of the devices used to retrieve the data or by failing the devices that validate the data.::",,,,,,
1295,The product fails to adequately prevent the revealing of unnecessary and potentially sensitive system information within debugging messages.,,::PHASE:Implementation::,,,,,::121::,
1296,The product's debug components contain incorrect chaining or granularity of debug components.,,::PHASE:Implementation::,,::METHOD:Architecture or Design Review:DESCRIPTION:Appropriate Post-Si tests should be carried out at various authorization levels to ensure that debug components are properly chained and accessible only to users with appropriate credentials.:EFFECTIVENESS:High::METHOD:Dynamic Analysis with Manual Results Interpretation:DESCRIPTION:Appropriate Post-Si tests should be carried out at various authorization levels to ensure that debug components are properly chained and accessible only to users with appropriate credentials.:EFFECTIVENESS:High::,,,::121::702::,
1297,The product does not adequately protect confidential information on the device from being accessed by Outsourced Semiconductor Assembly and Test (OSAT) vendors.,,::PHASE:Implementation::,,::METHOD:Architecture or Design Review:DESCRIPTION:Appropriate Post-Si tests should be carried out to ensure that residual confidential information is not left on parts leaving one facility for another facility.:EFFECTIVENESS:High::METHOD:Dynamic Analysis with Manual Results Interpretation:DESCRIPTION:Appropriate Post-Si tests should be carried out to ensure that residual confidential information is not left on parts leaving one facility for another facility.:EFFECTIVENESS:Moderate::,,,::1::180::,
1298,A race condition in the hardware logic results in undermining security guarantees of the system.,,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,::26::,
1299,The lack of protections on alternate paths to access control-protected assets (such as unprotected shadow registers and other external facing unguarded interfaces) allows an attacker to bypass existing protections to the asset that are only performed against the primary path.,,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,::457::554::,
1300,"The device does not contain sufficient protection mechanisms to prevent physical side channels from exposing sensitive information due to patterns in physically observable phenomena such as variations in power consumption, electromagnetic emissions (EME), or acoustic emissions.",,::PHASE:Implementation::,,"::METHOD:Manual Analysis:DESCRIPTION:Perform a set of leakage detection tests such as the procedure outlined in the Test Vector Leakage Assessment (TVLA) test requirements for AES [REF-1230]. TVLA is the basis for the ISO standard 17825 [REF-1229]. A separate methodology is provided by [REF-1228]. Note that sole reliance on this method might not yield expected results [REF-1239] [REF-1240].:EFFECTIVENESS:Moderate::METHOD:Manual Analysis:DESCRIPTION:Post-silicon, perform full side-channel attacks (penetration testing) covering as many known leakage models as possible against test code.:EFFECTIVENESS:Moderate::METHOD:Manual Analysis:DESCRIPTION:Pre-silicon - while the aforementioned TVLA methods can be performed post-silicon, models of device power consumption or other physical emanations can be built from information present at various stages of the hardware design process before fabrication. TVLA or known side-channel attacks can be applied to these simulated traces and countermeasures applied before tape-out. Academic research in this field includes [REF-1231] [REF-1232] [REF-1233].:EFFECTIVENESS:Moderate::",::Power::,,::189::699::,
1301,The product's data removal process does not completely delete all data and potentially sensitive information within hardware components.,,::PHASE:Implementation::,,,,,::37::,
1302,The product implements a security identifier mechanism to differentiate what actions are allowed or disallowed when a transaction originates from an entity. A transaction is sent without a security identifier.,,::PHASE:Architecture and Design:NOTE:Such issues could be introduced during hardware architecture and design and identified later during Testing or System Configuration phases.::PHASE:Implementation:NOTE:Such issues could be introduced during implementation and identified later during Testing or System Configuration phases.::,,,,,::121::681::,
1303,"Hardware structures shared across execution contexts (e.g., caches and branch predictors) can violate the expected architecture isolation between contexts.",,::PHASE:Architecture and Design:NOTE:Such issues could be introduced during hardware architecture and design and identified later during Testing or System Configuration phases.::PHASE:Implementation:NOTE:Such issues could be introduced during implementation and identified later during Testing or System Configuration phases.::,,,,,::663::,
1304,"The product performs a power save/restore operation, but it does not ensure that the integrity of the configuration state is maintained and/or verified between the beginning and ending of the operation.",,::PHASE:Architecture and Design:NOTE:Weakness introduced via missing internal integrity guarantees during power save/restore::PHASE:Integration:NOTE:Weakness introduced via missing external integrity verification during power save/restore::,,,::Power::,,::176::,
1310,Missing an ability to patch ROM code may leave a System or System-on-Chip (SoC) in a vulnerable state.,,::PHASE:Architecture and Design:NOTE:This issue could be introduced during hardware architecture and design and can be identified later during Testing.::PHASE:Implementation:NOTE:This issue could be introduced during implementation and can be identified later during Testing.::PHASE:Integration:NOTE:This issue could be introduced during integration and can be identified later during Testing.::PHASE:Manufacturing:NOTE:This issue could be introduced during manufacturing and can be identified later during Testing.::,,,,,::682::,
1311,The bridge incorrectly translates security attributes from either trusted to untrusted or from untrusted to trusted when converting from one fabric protocol to another.,,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,::1::180::233::,
1312,"The firewall in an on-chip fabric protects the main addressed region, but it does not protect any mirrored memory or memory-mapped-IO (MMIO) regions.",,::PHASE:Architecture and Design::PHASE:Implementation::,,"::METHOD:Manual Dynamic Analysis:DESCRIPTION:Using an external debugger, send write transactions to mirrored regions to test if original, write-protected regions are modified. Similarly, send read transactions to mirrored regions to test if the original, read-protected signals can be read.:EFFECTIVENESS:High::",,,::456::679::,
1313,"During runtime, the hardware allows for test or debug logic (feature) to be activated, which allows for changing the state of the hardware. This feature can alter the intended behavior of the system and allow for alteration and leakage of sensitive data by an adversary.",,::PHASE:Architecture and Design:NOTE:Such issues could be introduced during hardware architecture and design and identified later during Testing or System Configuration phases.::PHASE:Implementation:NOTE:Such issues could be introduced during implementation and identified later during Testing or System Configuration phases.::PHASE:Integration:NOTE:Such issues could be introduced during integration and identified later during Testing or System configuration phases.::,,,,,::121::,
1314,"The device does not write-protect the parametric data values for sensors that scale the sensor value, allowing untrusted software to manipulate the apparent result and potentially damage hardware or cause operational failure.",,::PHASE:Architecture and Design:NOTE:The lack of a requirement to protect parametric values may contribute to this weakness.::PHASE:Implementation:NOTE:The lack of parametric value protection may be a cause of this weakness.::,,,,,::1::,
1315,The bus controller enables bits in the fabric end-point to allow responder devices to control transactions on the fabric.,,::PHASE:Architecture and Design::PHASE:Implementation::PHASE:System Configuration::,,,,,::1::180::,
1316,"The address map of the on-chip fabric has protected and unprotected regions overlapping, allowing an attacker to bypass access control to the overlapping portion of the protected region.",,::PHASE:Architecture and Design::PHASE:Implementation::,,::METHOD:Automated Dynamic Analysis:DESCRIPTION:Review address map in specification to see if there are any overlapping ranges.:EFFECTIVENESS:High::METHOD:Manual Static Analysis:DESCRIPTION:Negative testing of access control on overlapped ranges.:EFFECTIVENESS:High::,,,::456::679::,
1317,"The product uses a fabric bridge for transactions between two Intellectual Property (IP) blocks, but the bridge does not properly perform the expected privilege, identity, or other access control checks between those IP blocks.",,::PHASE:Architecture and Design::PHASE:Implementation::,,::METHOD:Simulation / Emulation:DESCRIPTION:RTL simulation to ensure that bridge-access controls are implemented properly.:EFFECTIVENESS:High::METHOD:Formal Verification:DESCRIPTION:Formal verification of bridge RTL to ensure that access control cannot be bypassed.:EFFECTIVENESS:High::,,,::122::,
1318,"On-chip fabrics or buses either do not support or are not configured to support privilege separation or other security features, such as access control.",,::PHASE:Architecture and Design::PHASE:Implementation::,,::METHOD:Architecture or Design Review:DESCRIPTION:Review the fabric specification and ensure that it contains signals to transfer security-sensitive signals.:EFFECTIVENESS:High::METHOD:Manual Static Analysis - Source Code:DESCRIPTION:Lack of security features can also be confirmed through manual RTL review of the fabric RTL.:EFFECTIVENESS:High::,,,::1::180::,
1319,"The device is susceptible to electromagnetic fault injection attacks, causing device internal information to be compromised or security mechanisms to be bypassed.",,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,::624::625::,
1320,Untrusted agents can disable alerts about signal conditions exceeding limits or the response mechanism that handles such alerts.,,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,::1::180::,
1322,"The product uses a non-blocking model that relies on a single threaded process for features such as scalability, but it contains code that can block when it is invoked.",,::PHASE:Implementation::,,,,,::25::,
1323,Trace data collected from several sources on the System-on-Chip (SoC) is stored in unprotected locations or transported to untrusted agents.,,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,::150::167::545::,
1325,"The product manages a group of objects or resources and performs a separate memory allocation for each object, but it does not properly limit the total amount of memory that is consumed by all of the combined objects.",,::PHASE:Implementation::,,,,,::130::,
1326,A missing immutable root of trust in the hardware results in the ability to bypass secure boot or execute untrusted or adversarial boot code.,,"::PHASE:Architecture and Design::PHASE:Implementation:NOTE:Such issues could be introduced during policy definition, hardware architecture, design, manufacturing, and/or provisioning. They can be identified later during testing or system configuration phases.::",,::METHOD:Automated Dynamic Analysis:DESCRIPTION:Automated testing can verify that RoT components are immutable.:EFFECTIVENESS:High::METHOD:Architecture or Design Review:DESCRIPTION:Root of trust elements and memory should be part of architecture and design reviews.:EFFECTIVENESS:High::,,,::679::68::,
1327,"The product assigns the address 0.0.0.0 for a database server, a cloud service/instance, or any computing resource that communicates remotely.",,::PHASE:System Configuration::,,,,,::1::,
1328,"Security-version number in hardware is mutable, resulting in the ability to downgrade (roll-back) the boot firmware to vulnerable code versions.",,"::PHASE:Architecture and Design::PHASE:Implementation:NOTE:Such issues could be introduced during hardware architecture and design, and can be identified later during testing or system configuration phases.::",,::METHOD:Automated Dynamic Analysis:DESCRIPTION:Mutability of stored security version numbers and programming with older firmware images should be part of automated testing.:EFFECTIVENESS:High::METHOD:Architecture or Design Review:DESCRIPTION:Anti-roll-back features should be reviewed as part of Architecture or Design review.:EFFECTIVENESS:High::,,,::176::,
1329,The product contains a component that cannot be updated or patched in order to remove vulnerabilities or significant bugs.,,"::PHASE:Requirements:NOTE:Requirements development might not consider the importance of updates over the lifetime of the product or might intentionally exclude this capability due to concerns such as expense or speed to market.::PHASE:Architecture and Design:NOTE:Lack of planning during architecture development and design, or external pressures such as speed to market, could ignore the capability to update.::PHASE:Architecture and Design:NOTE:Designers might omit capabilities for updating a component due to time pressures to release the product or assumptions about the stability of the component.::PHASE:Implementation:NOTE:The weakness can appear through oversight during implementation.::",,"::METHOD:Architecture or Design Review:DESCRIPTION:Check the consumer or maintainer documentation, the architecture/design documentation, or the original requirements to ensure that the documentation includes details for how to update the firmware.:EFFECTIVENESS:Moderate::",,,,
1331,"The Network On Chip (NoC) does not isolate or incorrectly isolates its on-chip-fabric and internal resources such that they are shared between trusted and untrusted agents, creating timing channels.","::Network-on-chip (NoC) is a commonly-used term used for hardware interconnect fabrics used by multicore Systems-on-Chip (SoC). Communication between modules on the chip uses packet-based methods, with improved efficiency and scalability compared to bus architectures [REF-1241].::",::PHASE:Architecture and Design::PHASE:Implementation::,,::METHOD:Manual Analysis:DESCRIPTION:Providing marker flags to send through the interfaces coupled with examination of which users are able to read or manipulate the flags will help verify that the proper isolation has been achieved and is effective.:EFFECTIVENESS:Moderate::,,,::124::,
1332,The device is missing or incorrectly implements circuitry or sensors that detect and mitigate the skipping of security-critical CPU instructions when they occur.,,::PHASE:Architecture and Design:NOTE:Failure to design appropriate countermeasures to common fault injection techniques can manifest this weakness.::PHASE:Implementation:NOTE:This weakness can arise if the hardware design incorrectly implements countermeasures to prevent fault injection.::,,"::METHOD:Automated Static Analysis:DESCRIPTION:This weakness can be found using automated static analysis once a developer has indicated which code paths are critical to protect.:EFFECTIVENESS:Moderate::METHOD:Simulation / Emulation:DESCRIPTION:This weakness can be found using automated dynamic analysis. Both emulation of a CPU with instruction skips, as well as RTL simulation of a CPU IP, can indicate parts of the code that are sensitive to faults due to instruction skips.:EFFECTIVENESS:Moderate::METHOD:Manual Analysis:DESCRIPTION:This weakness can be found using manual (static) analysis. The analyst has security objectives that are matched against the high-level code. This method is less precise than emulation, especially if the analysis is done at the higher level language rather than at assembly level.:EFFECTIVENESS:Moderate::",::Power::,,::624::625::,
1333,"The product uses a regular expression with an inefficient, possibly exponential worst-case computational complexity that consumes excessive CPU cycles.",,"::PHASE:Implementation:NOTE:A RegEx can be easy to create and read using unbounded matching characters, but the programmer might not consider the risk of excessive backtracking.::",,,,,::492::,
1334,An unauthorized agent can inject errors into a redundant block to deprive the system of redundancy or put the system in a degraded operating mode.,,::PHASE:Architecture and Design:NOTE:Such issues could be introduced during hardware architecture and design and identified later during Testing or System Configuration phases.::PHASE:Implementation:NOTE:Such issues could be introduced during implementation and identified later during Testing or System Configuration phases.::PHASE:Integration:NOTE:Such issues could be introduced during integration and identified later during Testing or System Configuration phases.::,,,,,::624::625::,
1335,An integer value is specified to be shifted by a negative amount or an amount greater than or equal to the number of bits contained in the value causing an unexpected or indeterminate result.,,::PHASE:Implementation:NOTE:Adding shifts without properly verifying the size and sign of the shift amount.::,,,,,,
1336,"The product uses a template engine to insert or process externally-influenced input, but it does not neutralize or incorrectly neutralizes special elements or syntax that can be interpreted as template expressions or other code directives when processed by the engine.",,::PHASE:Architecture and Design:NOTE:The developer might choose a template engine that makes it easier for programmers to write vulnerable code.::PHASE:Implementation:NOTE:The programmer might not use engine's built-in sandboxes or other capabilities to escape or otherwise prevent template injection from untrusted input.::,,,,,,
1338,A hardware device is missing or has inadequate protection features to prevent overheating.,,"::PHASE:Architecture and Design::PHASE:Implementation:NOTE:Such issues could be introduced during hardware architecture, design or implementation.::",,::METHOD:Dynamic Analysis with Manual Results Interpretation:DESCRIPTION:Dynamic tests should be performed to stress-test temperature controls.:EFFECTIVENESS:High::METHOD:Architecture or Design Review:DESCRIPTION:Power management controls should be part of Architecture and Design reviews.:EFFECTIVENESS:High::,,,::624::625::,
1339,"The product processes a real number with an implementation in which the number's representation does not preserve required accuracy and precision in its fractional part, causing an incorrect result.","::There are three major ways to store real numbers in computers. Each method is described along with the limitations of how they store their numbers. Fixed: Some implementations use a fixed number of binary bits to represent both the integer and the fraction. In the demonstrative example about Muller's Recurrence, the fraction 108.0 - ((815.0 - 1500.0 / z) / y) cannot be represented in 8 binary digits. The numeric accuracy within languages such as PL/1, COBOL and Ada is expressed in decimal digits rather than binary digits. In SQL and most databases, the length of the integer and the fraction are specified by the programmer in decimal. In the language C, fixed reals are implemented according to ISO/IEC TR18037 Floating: The number is stored in a version of scientific notation with a fixed length for the base and the significand. This allows flexibility for more accuracy when the integer portion is smaller. When dealing with large integers, the fractional accuracy is less. Languages such as PL/1, COBOL and Ada set the accuracy by decimal digit representation rather than using binary digits. Python also implements decimal floating-point numbers using the IEEE 754-2008 encoding method. Ratio: The number is stored as the ratio of two integers. These integers also have their limits. These integers can be stored in a fixed number of bits or in a vector of digits. While the vector of digits method provides for very large integers, they cannot truly represent a repeating or transcendental number as those numbers do not ever have a fixed length.::",::PHASE:Implementation:NOTE:This weakness is introduced when the developer picks a method to represent a real number. The weakness may only be visible with very specific numeric inputs.::,,,,,,
1341,"The product attempts to close or release a resource or handle more than once, without any successful open between the close operations.",,::PHASE:Implementation::,,"::METHOD:Automated Static Analysis:DESCRIPTION:For commonly-used APIs and resource types, automated tools often have signatures that can spot this issue.::METHOD:Automated Dynamic Analysis:DESCRIPTION:Some compiler instrumentation tools such as AddressSanitizer (ASan) can indirectly detect some instances of this weakness.::",,,,
1342,"The processor does not properly clear microarchitectural state after incorrect microcode assists or speculative execution, resulting in transient execution.",,::PHASE:Architecture and Design::PHASE:Requirements::,,,,,::696::,
1351,"A hardware device, or the firmware running on it, is missing or has incorrect protection features to maintain goals of security primitives when the device is cooled below standard operating temperatures.",,::PHASE:Architecture and Design::PHASE:Implementation::,,,,,::624::625::,
1386,"The product opens a file or directory, but it does not properly prevent the name from being associated with a junction or mount point to a destination that is outside of the intended control sphere.",,"::PHASE:Implementation:NOTE:The developer might not consider that when a program in Windows operates with different permissions than the executing user, the use of links, mount points, and junctions might cause the program to access files or directories that are outside of the intended storage location.::",,,,,,
1389,"The product parses numeric input assuming base 10 (decimal) values, but it does not account for inputs that use a different base number (radix).",,"::PHASE:Architecture and Design:NOTE:The application may rely on a service that supports different numerical bases.::PHASE:Implementation:NOTE:Input validation used may assume decimal bases during conditional checks, when it may not always be the case.::",,,,,,
1392,The product uses default credentials (such as passwords or cryptographic keys) for potentially critical functionality.,,::PHASE:Architecture and Design::,,,,,,
1393,The product uses default passwords for potentially critical functionality.,,::PHASE:Architecture and Design::,,,,,,
1394,The product uses a default cryptographic key for potentially critical functionality.,,::PHASE:Architecture and Design::,,,,,,