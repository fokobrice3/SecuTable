CWE-ID,Name,Weakness Abstraction,Status,Description,Extended Description,Related Weaknesses,Weakness Ordinalities,Applicable Platforms,Background Details,Alternate Terms,Modes Of Introduction,Exploitation Factors,Likelihood of Exploit,Common Consequences,Detection Methods,Potential Mitigations,Observed Examples,Functional Areas,Affected Resources,Taxonomy Mappings,Related Attack Patterns,Notes
90,"Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')",Base,Draft,"The product constructs all or part of an LDAP query using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended LDAP query when it is sent to a downstream component.","",::NATURE:ChildOf:CWE ID:943:VIEW ID:1000:ORDINAL:Primary::,"",::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::TECHNOLOGY NAME:Database Server:TECHNOLOGY PREVALENCE:Undetermined::,"","","::PHASE:Architecture and Design::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::","",,"::SCOPE:Confidentiality:SCOPE:Integrity:SCOPE:Availability:IMPACT:Execute Unauthorized Code or Commands:IMPACT:Read Application Data:IMPACT:Modify Application Data:NOTE:An attacker could include input that changes the LDAP query which allows unintended commands or code to be executed, allows sensitive data to be read or modified or causes other unintended behavior.::","","::PHASE:Implementation:STRATEGY:Input Validation:DESCRIPTION:Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.::","::REFERENCE:CVE-2021-41232:DESCRIPTION:Chain: authentication routine in Go-based agile development product does not escape user name (CWE-116), allowing LDAP injection (CWE-90):LINK:https://www.cve.org/CVERecord?id=CVE-2021-41232::REFERENCE:CVE-2005-2301:DESCRIPTION:Server does not properly escape LDAP queries, which allows remote attackers to cause a DoS and possibly conduct an LDAP injection attack.:LINK:https://www.cve.org/CVERecord?id=CVE-2005-2301::",,,"::TAXONOMY NAME:PLOVER:ENTRY NAME:LDAP injection::TAXONOMY NAME:OWASP Top Ten 2007:ENTRY ID:A2:ENTRY NAME:Injection Flaws:MAPPING FIT:CWE More Specific::TAXONOMY NAME:WASC:ENTRY ID:29:ENTRY NAME:LDAP Injection::TAXONOMY NAME:Software Fault Patterns:ENTRY ID:SFP24:ENTRY NAME:Tainted input to command::",::136::,"::TYPE:Relationship:NOTE:Factors: resultant to special character mismanagement, MAID, or denylist/allowlist problems. Can be primary to authentication and verification errors.::",
91,"XML Injection (aka Blind XPath Injection)",Base,Draft,"The product does not properly neutralize special elements that are used in XML, allowing attackers to modify the syntax, content, or commands of the XML before it is processed by an end system.","Within XML, special elements could include reserved words or characters such as <, >, , and &, which could then be used to add new data or modify XML syntax.",::NATURE:ChildOf:CWE ID:74:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:74:VIEW ID:1003:ORDINAL:Primary::,"",::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::,"","","::PHASE:Architecture and Design::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::","",,"::SCOPE:Confidentiality:SCOPE:Integrity:SCOPE:Availability:IMPACT:Execute Unauthorized Code or Commands:IMPACT:Read Application Data:IMPACT:Modify Application Data::","","::PHASE:Implementation:STRATEGY:Input Validation:DESCRIPTION:Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.::","",,,"::TAXONOMY NAME:PLOVER:ENTRY NAME:XML injection (aka Blind Xpath injection)::TAXONOMY NAME:OWASP Top Ten 2007:ENTRY ID:A2:ENTRY NAME:Injection Flaws:MAPPING FIT:CWE More Specific::TAXONOMY NAME:OWASP Top Ten 2004:ENTRY ID:A6:ENTRY NAME:Injection Flaws:MAPPING FIT:CWE More Specific::TAXONOMY NAME:WASC:ENTRY ID:23:ENTRY NAME:XML Injection::TAXONOMY NAME:Software Fault Patterns:ENTRY ID:SFP24:ENTRY NAME:Tainted input to command::",::250::83::,"::TYPE:Maintenance:NOTE:The description for this entry is generally applicable to XML, but the name includes blind XPath injection which is more closely associated with CWE-643. Therefore this entry might need to be deprecated or converted to a general category - although injection into raw XML is not covered by CWE-643 or CWE-652.::TYPE:Theoretical:NOTE:In vulnerability theory terms, this is a representation-specific case of a Data/Directive Boundary Error.::TYPE:Research Gap:NOTE:Under-reported. This is likely found regularly by third party code auditors, but there are very few publicly reported examples.::",
93,"Improper Neutralization of CRLF Sequences ('CRLF Injection')",Base,Draft,"The product uses CRLF (carriage return line feeds) as a special element, e.g. to separate lines or records, but it does not neutralize or incorrectly neutralizes CRLF sequences from inputs.","",::NATURE:ChildOf:CWE ID:74:VIEW ID:1000:ORDINAL:Primary::NATURE:CanPrecede:CWE ID:117:VIEW ID:1000::,"::ORDINALITY:Primary::",::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::,"","","::PHASE:Architecture and Design::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::","",,"::SCOPE:Integrity:IMPACT:Modify Application Data::","","::PHASE:Implementation:DESCRIPTION:Avoid using CRLF as a special sequence.::PHASE:Implementation:DESCRIPTION:Appropriately filter or quote CRLF sequences in user-controlled input.::","::REFERENCE:CVE-2002-1771:DESCRIPTION:CRLF injection enables spam proxy (add mail headers) using email address or name.:LINK:https://www.cve.org/CVERecord?id=CVE-2002-1771::REFERENCE:CVE-2002-1783:DESCRIPTION:CRLF injection in API function arguments modify headers for outgoing requests.:LINK:https://www.cve.org/CVERecord?id=CVE-2002-1783::REFERENCE:CVE-2004-1513:DESCRIPTION:Spoofed entries in web server log file via carriage returns:LINK:https://www.cve.org/CVERecord?id=CVE-2004-1513::REFERENCE:CVE-2006-4624:DESCRIPTION:Chain: inject fake log entries with fake timestamps using CRLF injection:LINK:https://www.cve.org/CVERecord?id=CVE-2006-4624::REFERENCE:CVE-2005-1951:DESCRIPTION:Chain: Application accepts CRLF in an object ID, allowing HTTP response splitting.:LINK:https://www.cve.org/CVERecord?id=CVE-2005-1951::REFERENCE:CVE-2004-1687:DESCRIPTION:Chain: HTTP response splitting via CRLF in parameter related to URL.:LINK:https://www.cve.org/CVERecord?id=CVE-2004-1687::",,,"::TAXONOMY NAME:PLOVER:ENTRY NAME:CRLF Injection::TAXONOMY NAME:OWASP Top Ten 2007:ENTRY ID:A2:ENTRY NAME:Injection Flaws:MAPPING FIT:CWE More Specific::TAXONOMY NAME:WASC:ENTRY ID:24:ENTRY NAME:HTTP Request Splitting::TAXONOMY NAME:Software Fault Patterns:ENTRY ID:SFP24:ENTRY NAME:Tainted input to command::",::15::81::,"",
94,"Improper Control of Generation of Code ('Code Injection')",Base,Draft,"The product constructs all or part of a code segment using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the syntax or behavior of the intended code segment.","When a product allows a user's input to contain code syntax, it might be possible for an attacker to craft the code in such a way that it will alter the intended control flow of the product. Such an alteration could lead to arbitrary code execution. Injection problems encompass a wide variety of issues -- all mitigated in very different ways. For this reason, the most effective way to discuss these weaknesses is to note the distinct features which classify them as injection weaknesses. The most important issue to note is that all injection problems share one thing in common -- i.e., they allow for the injection of control plane data into the user-controlled data plane. This means that the execution of the process may be altered by sending code in through legitimate data channels, using no other mechanism. While buffer overflows, and many other flaws, involve the use of some further issue to gain execution, injection problems need only for the data to be parsed. The most classic instantiations of this category of weakness are SQL injection and format string vulnerabilities.",::NATURE:ChildOf:CWE ID:74:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:74:VIEW ID:1003:ORDINAL:Primary::NATURE:ChildOf:CWE ID:913:VIEW ID:1000::,"",::LANGUAGE CLASS:Interpreted:LANGUAGE PREVALENCE:Sometimes::,"","","::PHASE:Architecture and Design::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::","",,"::SCOPE:Access Control:IMPACT:Bypass Protection Mechanism:NOTE:In some cases, injectable code controls authentication; this may lead to a remote vulnerability.::SCOPE:Access Control:IMPACT:Gain Privileges or Assume Identity:NOTE:Injected code can access resources that the attacker is directly prevented from accessing.::SCOPE:Integrity:SCOPE:Confidentiality:SCOPE:Availability:IMPACT:Execute Unauthorized Code or Commands:NOTE:Code injection attacks can lead to loss of data integrity in nearly all cases as the control-plane data injected is always incidental to data recall or writing. Additionally, code injection can often result in the execution of arbitrary code.::SCOPE:Non-Repudiation:IMPACT:Hide Activities:NOTE:Often the actions performed by injected control code are unlogged.::","","::PHASE:Architecture and Design:DESCRIPTION:Refactor your program so that you do not have to dynamically generate code.::PHASE:Architecture and Design:DESCRIPTION:Run your code in a jail or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which code can be executed by your product. Examples include the Unix chroot jail and AppArmor. In general, managed code may provide some protection. This may not be a feasible solution, and it only limits the impact to the operating system; the rest of your application may still be subject to compromise. Be careful to avoid CWE-243 and other weaknesses related to jails.::PHASE:Implementation:STRATEGY:Input Validation:DESCRIPTION:Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright. To reduce the likelihood of code injection, use stringent allowlists that limit which constructs are allowed. If you are dynamically constructing code that invokes a function, then verifying that the input is alphanumeric might be insufficient. An attacker might still be able to reference a dangerous function that you did not intend to allow, such as system(), exec(), or exit().::PHASE:Testing:DESCRIPTION:Use automated static analysis tools that target this type of weakness. Many modern techniques use data flow analysis to minimize the number of false positives. This is not a perfect solution, since 100% accuracy and coverage are not feasible.::PHASE:Testing:DESCRIPTION:Use dynamic tools and techniques that interact with the product using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The product's operation may slow down, but it should not become unstable, crash, or generate incorrect results.::PHASE:Operation:STRATEGY:Compilation or Build Hardening:DESCRIPTION:Run the code in an environment that performs automatic taint propagation and prevents any command execution that uses tainted variables, such as Perl's -T switch. This will force the program to perform validation steps that remove the taint, although you must be careful to correctly validate your inputs so that you do not accidentally mark dangerous inputs as untainted (see CWE-183 and CWE-184).::PHASE:Operation:STRATEGY:Environment Hardening:DESCRIPTION:Run the code in an environment that performs automatic taint propagation and prevents any command execution that uses tainted variables, such as Perl's -T switch. This will force the program to perform validation steps that remove the taint, although you must be careful to correctly validate your inputs so that you do not accidentally mark dangerous inputs as untainted (see CWE-183 and CWE-184).::","::REFERENCE:CVE-2022-2054:DESCRIPTION:Python compiler uses eval() to execute malicious strings as Python code.:LINK:https://www.cve.org/CVERecord?id=CVE-2022-2054::REFERENCE:CVE-2021-22204:DESCRIPTION:Chain: regex in EXIF processor code does not correctly determine where a string ends (CWE-625), enabling eval injection (CWE-95), as exploited in the wild per CISA KEV.:LINK:https://www.cve.org/CVERecord?id=CVE-2021-22204::REFERENCE:CVE-2020-8218:DESCRIPTION:Code injection in VPN product, as exploited in the wild per CISA KEV.:LINK:https://www.cve.org/CVERecord?id=CVE-2020-8218::REFERENCE:CVE-2008-5071:DESCRIPTION:Eval injection in PHP program.:LINK:https://www.cve.org/CVERecord?id=CVE-2008-5071::REFERENCE:CVE-2002-1750:DESCRIPTION:Eval injection in Perl program.:LINK:https://www.cve.org/CVERecord?id=CVE-2002-1750::REFERENCE:CVE-2008-5305:DESCRIPTION:Eval injection in Perl program using an ID that should only contain hyphens and numbers.:LINK:https://www.cve.org/CVERecord?id=CVE-2008-5305::REFERENCE:CVE-2002-1752:DESCRIPTION:Direct code injection into Perl eval function.:LINK:https://www.cve.org/CVERecord?id=CVE-2002-1752::REFERENCE:CVE-2002-1753:DESCRIPTION:Eval injection in Perl program.:LINK:https://www.cve.org/CVERecord?id=CVE-2002-1753::REFERENCE:CVE-2005-1527:DESCRIPTION:Direct code injection into Perl eval function.:LINK:https://www.cve.org/CVERecord?id=CVE-2005-1527::REFERENCE:CVE-2005-2837:DESCRIPTION:Direct code injection into Perl eval function.:LINK:https://www.cve.org/CVERecord?id=CVE-2005-2837::REFERENCE:CVE-2005-1921:DESCRIPTION:MFV. code injection into PHP eval statement using nested constructs that should not be nested.:LINK:https://www.cve.org/CVERecord?id=CVE-2005-1921::REFERENCE:CVE-2005-2498:DESCRIPTION:MFV. code injection into PHP eval statement using nested constructs that should not be nested.:LINK:https://www.cve.org/CVERecord?id=CVE-2005-2498::REFERENCE:CVE-2005-3302:DESCRIPTION:Code injection into Python eval statement from a field in a formatted file.:LINK:https://www.cve.org/CVERecord?id=CVE-2005-3302::REFERENCE:CVE-2007-1253:DESCRIPTION:Eval injection in Python program.:LINK:https://www.cve.org/CVERecord?id=CVE-2007-1253::REFERENCE:CVE-2001-1471:DESCRIPTION:chain: Resultant eval injection. An invalid value prevents initialization of variables, which can be modified by attacker and later injected into PHP eval statement.:LINK:https://www.cve.org/CVERecord?id=CVE-2001-1471::REFERENCE:CVE-2002-0495:DESCRIPTION:Perl code directly injected into CGI library file from parameters to another CGI program.:LINK:https://www.cve.org/CVERecord?id=CVE-2002-0495::REFERENCE:CVE-2005-1876:DESCRIPTION:Direct PHP code injection into supporting template file.:LINK:https://www.cve.org/CVERecord?id=CVE-2005-1876::REFERENCE:CVE-2005-1894:DESCRIPTION:Direct code injection into PHP script that can be accessed by attacker.:LINK:https://www.cve.org/CVERecord?id=CVE-2005-1894::REFERENCE:CVE-2003-0395:DESCRIPTION:PHP code from User-Agent HTTP header directly inserted into log file implemented as PHP script.:LINK:https://www.cve.org/CVERecord?id=CVE-2003-0395::",,,"::TAXONOMY NAME:PLOVER:ENTRY ID:CODE:ENTRY NAME:Code Evaluation and Injection::",::242::35::77::,"",
95,"Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')",Variant,Incomplete,"The product receives input from an upstream component, but it does not neutralize or incorrectly neutralizes code syntax before using the input in a dynamic evaluation call (e.g. eval).","This may allow an attacker to execute arbitrary code, or at least modify what code can be executed.",::NATURE:ChildOf:CWE ID:94:VIEW ID:1000:ORDINAL:Primary::,"::ORDINALITY:Primary::",::LANGUAGE NAME:Java:LANGUAGE PREVALENCE:Undetermined::LANGUAGE NAME:JavaScript:LANGUAGE PREVALENCE:Undetermined::LANGUAGE NAME:Python:LANGUAGE PREVALENCE:Undetermined::LANGUAGE NAME:Perl:LANGUAGE PREVALENCE:Undetermined::LANGUAGE NAME:PHP:LANGUAGE PREVALENCE:Undetermined::LANGUAGE NAME:Ruby:LANGUAGE PREVALENCE:Undetermined::LANGUAGE CLASS:Interpreted:LANGUAGE PREVALENCE:Undetermined::,"","","::PHASE:Architecture and Design:NOTE:This weakness is prevalent in handler/dispatch procedures that might want to invoke a large number of functions, or set a large number of variables.::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::","",,"::SCOPE:Confidentiality:IMPACT:Read Files or Directories:IMPACT:Read Application Data:NOTE:The injected code could access restricted data / files.::SCOPE:Access Control:IMPACT:Bypass Protection Mechanism:NOTE:In some cases, injectable code controls authentication; this may lead to a remote vulnerability.::SCOPE:Access Control:IMPACT:Gain Privileges or Assume Identity:NOTE:Injected code can access resources that the attacker is directly prevented from accessing.::SCOPE:Integrity:SCOPE:Confidentiality:SCOPE:Availability:SCOPE:Other:IMPACT:Execute Unauthorized Code or Commands:NOTE:Code injection attacks can lead to loss of data integrity in nearly all cases as the control-plane data injected is always incidental to data recall or writing. Additionally, code injection can often result in the execution of arbitrary code.::SCOPE:Non-Repudiation:IMPACT:Hide Activities:NOTE:Often the actions performed by injected control code are unlogged.::","","::PHASE:Architecture and Design Implementation:DESCRIPTION:If possible, refactor your code so that it does not need to use eval() at all.::PHASE:Implementation:STRATEGY:Input Validation:DESCRIPTION:Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.::PHASE:Implementation:DESCRIPTION:Inputs should be decoded and canonicalized to the application's current internal representation before being validated (CWE-180, CWE-181). Make sure that your application does not inadvertently decode the same input twice (CWE-174). Such errors could be used to bypass allowlist schemes by introducing dangerous inputs after they have been checked. Use libraries such as the OWASP ESAPI Canonicalization control. Consider performing repeated canonicalization until your input does not change any more. This will avoid double-decoding and similar scenarios, but it might inadvertently modify inputs that are allowed to contain properly-encoded dangerous content.::","::REFERENCE:CVE-2022-2054:DESCRIPTION:Python compiler uses eval() to execute malicious strings as Python code.:LINK:https://www.cve.org/CVERecord?id=CVE-2022-2054::REFERENCE:CVE-2021-22204:DESCRIPTION:Chain: regex in EXIF processor code does not correctly determine where a string ends (CWE-625), enabling eval injection (CWE-95), as exploited in the wild per CISA KEV.:LINK:https://www.cve.org/CVERecord?id=CVE-2021-22204::REFERENCE:CVE-2021-22205:DESCRIPTION:Chain: backslash followed by a newline can bypass a validation step (CWE-20), leading to eval injection (CWE-95), as exploited in the wild per CISA KEV.:LINK:https://www.cve.org/CVERecord?id=CVE-2021-22205::REFERENCE:CVE-2008-5071:DESCRIPTION:Eval injection in PHP program.:LINK:https://www.cve.org/CVERecord?id=CVE-2008-5071::REFERENCE:CVE-2002-1750:DESCRIPTION:Eval injection in Perl program.:LINK:https://www.cve.org/CVERecord?id=CVE-2002-1750::REFERENCE:CVE-2008-5305:DESCRIPTION:Eval injection in Perl program using an ID that should only contain hyphens and numbers.:LINK:https://www.cve.org/CVERecord?id=CVE-2008-5305::REFERENCE:CVE-2002-1752:DESCRIPTION:Direct code injection into Perl eval function.:LINK:https://www.cve.org/CVERecord?id=CVE-2002-1752::REFERENCE:CVE-2002-1753:DESCRIPTION:Eval injection in Perl program.:LINK:https://www.cve.org/CVERecord?id=CVE-2002-1753::REFERENCE:CVE-2005-1527:DESCRIPTION:Direct code injection into Perl eval function.:LINK:https://www.cve.org/CVERecord?id=CVE-2005-1527::REFERENCE:CVE-2005-2837:DESCRIPTION:Direct code injection into Perl eval function.:LINK:https://www.cve.org/CVERecord?id=CVE-2005-2837::REFERENCE:CVE-2005-1921:DESCRIPTION:MFV. code injection into PHP eval statement using nested constructs that should not be nested.:LINK:https://www.cve.org/CVERecord?id=CVE-2005-1921::REFERENCE:CVE-2005-2498:DESCRIPTION:MFV. code injection into PHP eval statement using nested constructs that should not be nested.:LINK:https://www.cve.org/CVERecord?id=CVE-2005-2498::REFERENCE:CVE-2005-3302:DESCRIPTION:Code injection into Python eval statement from a field in a formatted file.:LINK:https://www.cve.org/CVERecord?id=CVE-2005-3302::REFERENCE:CVE-2007-1253:DESCRIPTION:Eval injection in Python program.:LINK:https://www.cve.org/CVERecord?id=CVE-2007-1253::REFERENCE:CVE-2001-1471:DESCRIPTION:chain: Resultant eval injection. An invalid value prevents initialization of variables, which can be modified by attacker and later injected into PHP eval statement.:LINK:https://www.cve.org/CVERecord?id=CVE-2001-1471::REFERENCE:CVE-2007-2713:DESCRIPTION:Chain: Execution after redirect triggers eval injection.:LINK:https://www.cve.org/CVERecord?id=CVE-2007-2713::",,,"::TAXONOMY NAME:PLOVER:ENTRY NAME:Direct Dynamic Code Evaluation ('Eval Injection')::TAXONOMY NAME:OWASP Top Ten 2007:ENTRY ID:A3:ENTRY NAME:Malicious File Execution:MAPPING FIT:CWE More Specific::TAXONOMY NAME:OWASP Top Ten 2004:ENTRY ID:A6:ENTRY NAME:Injection Flaws:MAPPING FIT:CWE More Specific::TAXONOMY NAME:Software Fault Patterns:ENTRY ID:SFP24:ENTRY NAME:Tainted input to command::TAXONOMY NAME:SEI CERT Perl Coding Standard:ENTRY ID:IDS35-PL:ENTRY NAME:Do not invoke the eval form with a string argument:MAPPING FIT:Exact::",::35::,"::TYPE:Other:NOTE:Factors: special character errors can play a role in increasing the variety of code that can be injected, although some vulnerabilities do not require special characters at all, e.g. when a single function without arguments can be referenced and a terminator character is not necessary.::",
96,"Improper Neutralization of Directives in Statically Saved Code ('Static Code Injection')",Base,Draft,"The product receives input from an upstream component, but it does not neutralize or incorrectly neutralizes code syntax before inserting the input into an executable resource, such as a library, configuration file, or template.","",::NATURE:ChildOf:CWE ID:94:VIEW ID:1000:ORDINAL:Primary::,"::ORDINALITY:Primary::",::LANGUAGE NAME:PHP:LANGUAGE PREVALENCE:Undetermined::LANGUAGE NAME:Perl:LANGUAGE PREVALENCE:Undetermined::LANGUAGE CLASS:Interpreted:LANGUAGE PREVALENCE:Undetermined::,"","","::PHASE:Architecture and Design:NOTE:This issue is most frequently found in PHP applications that allow users to set configuration variables that are stored within executable PHP files. Technically, this could also be performed in some compiled code (e.g. by byte-patching an executable), although it is highly unlikely.::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::","",,"::SCOPE:Confidentiality:IMPACT:Read Files or Directories:IMPACT:Read Application Data:NOTE:The injected code could access restricted data / files.::SCOPE:Access Control:IMPACT:Bypass Protection Mechanism:NOTE:In some cases, injectable code controls authentication; this may lead to a remote vulnerability.::SCOPE:Access Control:IMPACT:Gain Privileges or Assume Identity:NOTE:Injected code can access resources that the attacker is directly prevented from accessing.::SCOPE:Integrity:SCOPE:Confidentiality:SCOPE:Availability:SCOPE:Other:IMPACT:Execute Unauthorized Code or Commands:NOTE:Code injection attacks can lead to loss of data integrity in nearly all cases as the control-plane data injected is always incidental to data recall or writing. Additionally, code injection can often result in the execution of arbitrary code.::SCOPE:Non-Repudiation:IMPACT:Hide Activities:NOTE:Often the actions performed by injected control code are unlogged.::","","::PHASE:Implementation:STRATEGY:Input Validation:DESCRIPTION:Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.::PHASE:Implementation:STRATEGY:Output Encoding:DESCRIPTION:Perform proper output validation and escaping to neutralize all code syntax from data written to code files.::","::REFERENCE:CVE-2002-0495:DESCRIPTION:Perl code directly injected into CGI library file from parameters to another CGI program.:LINK:https://www.cve.org/CVERecord?id=CVE-2002-0495::REFERENCE:CVE-2005-1876:DESCRIPTION:Direct PHP code injection into supporting template file.:LINK:https://www.cve.org/CVERecord?id=CVE-2005-1876::REFERENCE:CVE-2005-1894:DESCRIPTION:Direct code injection into PHP script that can be accessed by attacker.:LINK:https://www.cve.org/CVERecord?id=CVE-2005-1894::REFERENCE:CVE-2003-0395:DESCRIPTION:PHP code from User-Agent HTTP header directly inserted into log file implemented as PHP script.:LINK:https://www.cve.org/CVERecord?id=CVE-2003-0395::REFERENCE:CVE-2007-6652:DESCRIPTION:chain: execution after redirect allows non-administrator to perform static code injection.:LINK:https://www.cve.org/CVERecord?id=CVE-2007-6652::",,::File or Directory::,"::TAXONOMY NAME:PLOVER:ENTRY NAME:Direct Static Code Injection::TAXONOMY NAME:Software Fault Patterns:ENTRY ID:SFP24:ENTRY NAME:Tainted Input to Command::",::35::73::77::81::85::,"::TYPE:Relationship:NOTE:HTML injection (see CWE-79: XSS) could be thought of as an example of this, but the code is injected and executed on the client side, not the server side. Server-Side Includes (SSI) are an example of direct static code injection.::",
97,"Improper Neutralization of Server-Side Includes (SSI) Within a Web Page",Variant,Draft,"The product generates a web page, but does not neutralize or incorrectly neutralizes user-controllable input that could be interpreted as a server-side include (SSI) directive.","",::NATURE:ChildOf:CWE ID:96:VIEW ID:1000:ORDINAL:Primary::,"",::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::,"","","::PHASE:Architecture and Design::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::","",,"::SCOPE:Confidentiality:SCOPE:Integrity:SCOPE:Availability:IMPACT:Execute Unauthorized Code or Commands::","","","",,,"::TAXONOMY NAME:PLOVER:ENTRY NAME:Server-Side Includes (SSI) Injection::TAXONOMY NAME:WASC:ENTRY ID:36:ENTRY NAME:SSI Injection::",::101::35::,"::TYPE:Relationship:NOTE:This can be resultant from XSS/HTML injection because the same special characters can be involved. However, this is server-side code execution, not client-side.::",
98,"Improper Control of Filename for Include/Require Statement in PHP Program ('PHP Remote File Inclusion')",Variant,Draft,"The PHP application receives input from an upstream component, but it does not restrict or incorrectly restricts the input before its usage in require, include, or similar functions.","In certain versions and configurations of PHP, this can allow an attacker to specify a URL to a remote location from which the product will obtain the code to execute. In other cases in association with path traversal, the attacker can specify a local file that may contain executable statements that can be parsed by PHP.",::NATURE:ChildOf:CWE ID:706:VIEW ID:1000::NATURE:ChildOf:CWE ID:829:VIEW ID:1000:ORDINAL:Primary::NATURE:CanPrecede:CWE ID:94:VIEW ID:1000::NATURE:CanAlsoBe:CWE ID:426:VIEW ID:1000::,"",::LANGUAGE NAME:PHP:LANGUAGE PREVALENCE:Often::,"","::TERM:Remote file include::TERM:RFI:DESCRIPTION:The Remote File Inclusion (RFI) acronym is often used by vulnerability researchers.::TERM:Local file inclusion:DESCRIPTION:This term is frequently used in cases in which remote download is disabled, or when the first part of the filename is not under the attacker's control, which forces use of relative path traversal (CWE-23) attack techniques to access files that may contain previously-injected PHP code, such as web access logs.::","::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::PHASE:Architecture and Design::","",,"::SCOPE:Integrity:SCOPE:Confidentiality:SCOPE:Availability:IMPACT:Execute Unauthorized Code or Commands:NOTE:The attacker may be able to specify arbitrary code to be executed from a remote location. Alternatively, it may be possible to use normal program behavior to insert php code into files on the local machine which can then be included and force the code to execute since php ignores everything in the file except for the content between php specifiers.::","::METHOD:Manual Analysis:DESCRIPTION:Manual white-box analysis can be very effective for finding this issue, since there is typically a relatively small number of include or require statements in each program.:EFFECTIVENESS:High::METHOD:Automated Static Analysis:DESCRIPTION:The external control or influence of filenames can often be detected using automated static analysis that models data flow within the product. Automated static analysis might not be able to recognize when proper input validation is being performed, leading to false positives - i.e., warnings that do not have any security consequences or require any code changes. If the program uses a customized input validation library, then some tools may allow the analyst to create custom signatures to detect usage of those routines.::","::PHASE:Architecture and Design:STRATEGY:Libraries or Frameworks:DESCRIPTION:Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.::PHASE:Architecture and Design:STRATEGY:Enforcement by Conversion:DESCRIPTION:When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs. For example, ID 1 could map to inbox.txt and ID 2 could map to profile.txt. Features such as the ESAPI AccessReferenceMap [REF-185] provide this capability.::PHASE:Architecture and Design:DESCRIPTION:For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.::PHASE:Architecture and Design Operation:STRATEGY:Sandbox or Jail:DESCRIPTION:Run the code in a jail or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software. OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations. This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise. Be careful to avoid CWE-243 and other weaknesses related to jails.:EFFECTIVENESS:Limited::PHASE:Architecture and Design Operation:STRATEGY:Environment Hardening:DESCRIPTION:Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.::PHASE:Implementation:STRATEGY:Input Validation:DESCRIPTION:Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright. When validating filenames, use stringent lists that limit the character set to be used. If feasible, only allow a single . character in the filename to avoid weaknesses such as CWE-23, and exclude directory separators such as / to avoid CWE-36. Use a list of allowable file extensions, which will help to avoid CWE-434. Do not rely exclusively on a filtering mechanism that removes potentially dangerous characters. This is equivalent to a denylist, which may be incomplete (CWE-184). For example, filtering / is insufficient protection if the filesystem also supports the use of as a directory separator. Another possible error could occur when the filtering is applied in a way that still produces dangerous data (CWE-182). For example, if ../ sequences are removed from the .../...// string in a sequential fashion, two instances of ../ would be removed from the original string, but the remaining characters would still form the ../ string.:EFFECTIVENESS:High::PHASE:Architecture and Design Operation:STRATEGY:Attack Surface Reduction:DESCRIPTION:Store library, include, and utility files outside of the web document root, if possible. Otherwise, store them in a separate directory and use the web server's access control capabilities to prevent attackers from directly requesting them. One common practice is to define a fixed constant in each calling program, then check for the existence of the constant in the library/include file; if the constant does not exist, then the file was directly requested, and it can exit immediately. This significantly reduces the chance of an attacker being able to bypass any protection mechanisms that are in the base program but not in the include files. It will also reduce the attack surface.::PHASE:Architecture and Design Implementation:STRATEGY:Attack Surface Reduction:DESCRIPTION:Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, filenames, databases, and any external systems that provide data to the application. Remember that such inputs may be obtained indirectly through API calls. Many file inclusion problems occur because the programmer assumed that certain inputs could not be modified, especially for cookies and URL components.::PHASE:Operation:STRATEGY:Firewall:DESCRIPTION:Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.:EFFECTIVENESS:Moderate::PHASE:Operation Implementation:STRATEGY:Environment Hardening:DESCRIPTION:Develop and run your code in the most recent versions of PHP available, preferably PHP 6 or later. Many of the highly risky features in earlier PHP interpreters have been removed, restricted, or disabled by default.::PHASE:Operation Implementation:STRATEGY:Environment Hardening:DESCRIPTION:When using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE-95, CWE-621, and similar issues. Often, programmers do not protect direct access to files intended only to be included by core programs. These include files may assume that critical variables have already been initialized by the calling program. As a result, the use of register_globals combined with the ability to directly access the include file may allow attackers to conduct file inclusion attacks. This remains an extremely common pattern as of 2009.::PHASE:Operation:STRATEGY:Environment Hardening:DESCRIPTION:Set allow_url_fopen to false, which limits the ability to include files from remote locations.:EFFECTIVENESS:High::","::REFERENCE:CVE-2004-0285:DESCRIPTION:Modification of assumed-immutable configuration variable in include file allows file inclusion via direct request.:LINK:https://www.cve.org/CVERecord?id=CVE-2004-0285::REFERENCE:CVE-2004-0030:DESCRIPTION:Modification of assumed-immutable configuration variable in include file allows file inclusion via direct request.:LINK:https://www.cve.org/CVERecord?id=CVE-2004-0030::REFERENCE:CVE-2004-0068:DESCRIPTION:Modification of assumed-immutable configuration variable in include file allows file inclusion via direct request.:LINK:https://www.cve.org/CVERecord?id=CVE-2004-0068::REFERENCE:CVE-2005-2157:DESCRIPTION:Modification of assumed-immutable configuration variable in include file allows file inclusion via direct request.:LINK:https://www.cve.org/CVERecord?id=CVE-2005-2157::REFERENCE:CVE-2005-2162:DESCRIPTION:Modification of assumed-immutable configuration variable in include file allows file inclusion via direct request.:LINK:https://www.cve.org/CVERecord?id=CVE-2005-2162::REFERENCE:CVE-2005-2198:DESCRIPTION:Modification of assumed-immutable configuration variable in include file allows file inclusion via direct request.:LINK:https://www.cve.org/CVERecord?id=CVE-2005-2198::REFERENCE:CVE-2004-0128:DESCRIPTION:Modification of assumed-immutable variable in configuration script leads to file inclusion.:LINK:https://www.cve.org/CVERecord?id=CVE-2004-0128::REFERENCE:CVE-2005-1864:DESCRIPTION:PHP file inclusion.:LINK:https://www.cve.org/CVERecord?id=CVE-2005-1864::REFERENCE:CVE-2005-1869:DESCRIPTION:PHP file inclusion.:LINK:https://www.cve.org/CVERecord?id=CVE-2005-1869::REFERENCE:CVE-2005-1870:DESCRIPTION:PHP file inclusion.:LINK:https://www.cve.org/CVERecord?id=CVE-2005-1870::REFERENCE:CVE-2005-2154:DESCRIPTION:PHP local file inclusion.:LINK:https://www.cve.org/CVERecord?id=CVE-2005-2154::REFERENCE:CVE-2002-1704:DESCRIPTION:PHP remote file include.:LINK:https://www.cve.org/CVERecord?id=CVE-2002-1704::REFERENCE:CVE-2002-1707:DESCRIPTION:PHP remote file include.:LINK:https://www.cve.org/CVERecord?id=CVE-2002-1707::REFERENCE:CVE-2005-1964:DESCRIPTION:PHP remote file include.:LINK:https://www.cve.org/CVERecord?id=CVE-2005-1964::REFERENCE:CVE-2005-1681:DESCRIPTION:PHP remote file include.:LINK:https://www.cve.org/CVERecord?id=CVE-2005-1681::REFERENCE:CVE-2005-2086:DESCRIPTION:PHP remote file include.:LINK:https://www.cve.org/CVERecord?id=CVE-2005-2086::REFERENCE:CVE-2004-0127:DESCRIPTION:Directory traversal vulnerability in PHP include statement.:LINK:https://www.cve.org/CVERecord?id=CVE-2004-0127::REFERENCE:CVE-2005-1971:DESCRIPTION:Directory traversal vulnerability in PHP include statement.:LINK:https://www.cve.org/CVERecord?id=CVE-2005-1971::REFERENCE:CVE-2005-3335:DESCRIPTION:PHP file inclusion issue, both remote and local; local include uses .. and %00 characters as a manipulation, but many remote file inclusion issues probably have this vector.:LINK:https://www.cve.org/CVERecord?id=CVE-2005-3335::REFERENCE:CVE-2009-1936:DESCRIPTION:chain: library file sends a redirect if it is directly requested but continues to execute, allowing remote file inclusion and path traversal.:LINK:https://www.cve.org/CVERecord?id=CVE-2009-1936::",,::File or Directory::,"::TAXONOMY NAME:PLOVER:ENTRY NAME:PHP File Include::TAXONOMY NAME:OWASP Top Ten 2007:ENTRY ID:A3:ENTRY NAME:Malicious File Execution:MAPPING FIT:CWE More Specific::TAXONOMY NAME:WASC:ENTRY ID:5:ENTRY NAME:Remote File Inclusion::",::193::,"::TYPE:Relationship:NOTE:This is frequently a functional consequence of other weaknesses. It is usually multi-factor with other factors (e.g. MAID), although not all inclusion bugs involve assumed-immutable data. Direct request weaknesses frequently play a role. Can overlap directory traversal in local inclusion problems.::",
99,"Improper Control of Resource Identifiers ('Resource Injection')",Class,Draft,"The product receives input from an upstream component, but it does not restrict or incorrectly restricts the input before it is used as an identifier for a resource that may be outside the intended sphere of control.","A resource injection issue occurs when the following two conditions are met: An attacker can specify the identifier used to access a system resource. For example, an attacker might be able to specify part of the name of a file to be opened or a port number to be used. By specifying the resource, the attacker gains a capability that would not otherwise be permitted. For example, the program may give the attacker the ability to overwrite the specified file, run with a configuration controlled by the attacker, or transmit sensitive information to a third-party server. This may enable an attacker to access or modify otherwise protected system resources.",::NATURE:ChildOf:CWE ID:74:VIEW ID:1000:ORDINAL:Primary::NATURE:PeerOf:CWE ID:706:VIEW ID:1000::NATURE:CanAlsoBe:CWE ID:73:VIEW ID:1000::,"::ORDINALITY:Primary::",::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::,"","::TERM:Insecure Direct Object Reference:DESCRIPTION:OWASP uses this term, although it is effectively the same as resource injection.::","::PHASE:Architecture and Design::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::","",,"::SCOPE:Confidentiality:SCOPE:Integrity:IMPACT:Read Application Data:IMPACT:Modify Application Data:IMPACT:Read Files or Directories:IMPACT:Modify Files or Directories:NOTE:An attacker could gain access to or modify sensitive data or system resources. This could allow access to protected files or directories including configuration files and files containing sensitive information.::","","::PHASE:Implementation:STRATEGY:Input Validation:DESCRIPTION:Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, it can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.::","",,,"::TAXONOMY NAME:7 Pernicious Kingdoms:ENTRY NAME:Resource Injection::TAXONOMY NAME:Software Fault Patterns:ENTRY ID:SFP24:ENTRY NAME:Tainted input to command::TAXONOMY NAME:OMG ASCSM:ENTRY ID:ASCSM-CWE-99::",::10::240::75::,"::TYPE:Relationship:NOTE:Resource injection that involves resources stored on the filesystem goes by the name path manipulation (CWE-73).::TYPE:Maintenance:NOTE:The relationship between CWE-99 and CWE-610 needs further investigation and clarification. They might be duplicates. CWE-99 Resource Injection, as originally defined in Seven Pernicious Kingdoms taxonomy, emphasizes the identifier used to access a system resource such as a file name or port number, yet it explicitly states that the resource injection term does not apply to path manipulation, which effectively identifies the path at which a resource can be found and could be considered to be one aspect of a resource identifier. Also, CWE-610 effectively covers any type of resource, whether that resource is at the system layer, the application layer, or the code layer.::",
102,"Struts: Duplicate Validation Forms",Variant,Incomplete,"The product uses multiple validation forms with the same name, which might cause the Struts Validator to validate a form that the programmer does not expect.","If two validation forms have the same name, the Struts Validator arbitrarily chooses one of the forms to use for input validation and discards the other. This decision might not correspond to the programmer's expectations, possibly leading to resultant weaknesses. Moreover, it indicates that the validation logic is not up-to-date, and can indicate that other, more subtle validation errors are present.",::NATURE:ChildOf:CWE ID:694:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:1173:VIEW ID:1000::NATURE:ChildOf:CWE ID:20:VIEW ID:700:ORDINAL:Primary::,"::ORDINALITY:Primary::",::LANGUAGE NAME:Java:LANGUAGE PREVALENCE:Undetermined::,"","","::PHASE:Implementation::","",,"::SCOPE:Integrity:IMPACT:Unexpected State::","","::PHASE:Implementation:DESCRIPTION:The DTD or schema validation will not catch the duplicate occurrence of the same form name. To find the issue in the implementation, manual checks or automated static analysis could be applied to the xml configuration files.::","",,,"::TAXONOMY NAME:7 Pernicious Kingdoms:ENTRY NAME:Struts: Duplicate Validation Forms::TAXONOMY NAME:Software Fault Patterns:ENTRY ID:SFP24:ENTRY NAME:Tainted input to command::",,"",
103,"Struts: Incomplete validate() Method Definition",Variant,Draft,"The product has a validator form that either does not define a validate() method, or defines a validate() method but does not call super.validate().","If the code does not call super.validate(), the Validation Framework cannot check the contents of the form against a validation form. In other words, the validation framework will be disabled for the given form.",::NATURE:ChildOf:CWE ID:573:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:20:VIEW ID:700:ORDINAL:Primary::,"::ORDINALITY:Primary::",::LANGUAGE NAME:Java:LANGUAGE PREVALENCE:Undetermined::,"::The Struts Validator uses a form's validate() method to check the contents of the form properties against the constraints specified in the associated validation form. That means the following classes have a validate() method that is part of the validation framework: ValidatorForm, ValidatorActionForm, DynaValidatorForm, and DynaValidatorActionForm. If the code creates a class that extends one of these classes, and if that class implements custom validation logic by overriding the validate() method, the code must call super.validate() in the validate() implementation.::","","::PHASE:Implementation::","",,"::SCOPE:Other:IMPACT:Other:NOTE:Disabling the validation framework for a form exposes the product to numerous types of attacks. Unchecked input is the root cause of vulnerabilities like cross-site scripting, process control, and SQL injection.::SCOPE:Confidentiality:SCOPE:Integrity:SCOPE:Availability:SCOPE:Other:IMPACT:Other:NOTE:Although J2EE applications are not generally susceptible to memory corruption attacks, if a J2EE application interfaces with native code that does not perform array bounds checking, an attacker may be able to use an input validation mistake in the J2EE application to launch a buffer overflow attack.::","","::PHASE:Implementation:DESCRIPTION:Implement the validate() method and call super.validate() within that method.::","",,,"::TAXONOMY NAME:7 Pernicious Kingdoms:ENTRY NAME:Struts: Erroneous validate() Method::TAXONOMY NAME:Software Fault Patterns:ENTRY ID:SFP24:ENTRY NAME:Tainted input to command::",,"::TYPE:Relationship:NOTE:This could introduce other weaknesses related to missing input validation.::TYPE:Maintenance:NOTE:The current description implies a loose composite of two separate weaknesses, so this node might need to be split or converted into a low-level category.::",
104,"Struts: Form Bean Does Not Extend Validation Class",Variant,Draft,"If a form bean does not extend an ActionForm subclass of the Validator framework, it can expose the application to other weaknesses related to insufficient input validation.","",::NATURE:ChildOf:CWE ID:573:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:20:VIEW ID:700:ORDINAL:Primary::,"::ORDINALITY:Primary::",::LANGUAGE NAME:Java:LANGUAGE PREVALENCE:Undetermined::,"::In order to use the Struts Validator, a form must extend one of the following: ValidatorForm, ValidatorActionForm, DynaValidatorActionForm, and DynaValidatorForm. One of these classes must be extended because the Struts Validator ties in to the application by implementing the validate() method in these classes. Forms derived from the ActionForm and DynaActionForm classes cannot use the Struts Validator.::","","::PHASE:Implementation::","",,"::SCOPE:Other:IMPACT:Other:NOTE:Bypassing the validation framework for a form exposes the application to numerous types of attacks. Unchecked input is an important component of vulnerabilities like cross-site scripting, process control, and SQL injection.::SCOPE:Confidentiality:SCOPE:Integrity:SCOPE:Availability:SCOPE:Other:IMPACT:Other:NOTE:Although J2EE applications are not generally susceptible to memory corruption attacks, if a J2EE application interfaces with native code that does not perform array bounds checking, an attacker may be able to use an input validation mistake in the J2EE application to launch a buffer overflow attack.::","","::PHASE:Implementation:DESCRIPTION:Ensure that all forms extend one of the Validation Classes.::","",,,"::TAXONOMY NAME:7 Pernicious Kingdoms:ENTRY NAME:Struts: Form Bean Does Not Extend Validation Class::TAXONOMY NAME:Software Fault Patterns:ENTRY ID:SFP24:ENTRY NAME:Tainted input to command::",,"",
105,"Struts: Form Field Without Validator",Variant,Draft,"The product has a form field that is not validated by a corresponding validation form, which can introduce other weaknesses related to insufficient input validation.","Omitting validation for even a single input field may give attackers the leeway they need to compromise the product. Although J2EE applications are not generally susceptible to memory corruption attacks, if a J2EE application interfaces with native code that does not perform array bounds checking, an attacker may be able to use an input validation mistake in the J2EE application to launch a buffer overflow attack.",::NATURE:ChildOf:CWE ID:1173:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:20:VIEW ID:700:ORDINAL:Primary::,"::ORDINALITY:Primary::",::LANGUAGE NAME:Java:LANGUAGE PREVALENCE:Undetermined::,"","","::PHASE:Implementation:NOTE:Some products use the same ActionForm for more than one purpose. In situations like this, some fields may go unused under some action mappings.::","",,"::SCOPE:Integrity:IMPACT:Unexpected State::SCOPE:Integrity:IMPACT:Bypass Protection Mechanism:NOTE:If unused fields are not validated, shared business logic in an action may allow attackers to bypass the validation checks that are performed for other uses of the form.::","","::PHASE:Implementation:DESCRIPTION:Validate all form fields. If a field is unused, it is still important to constrain it so that it is empty or undefined.::","",,,"::TAXONOMY NAME:7 Pernicious Kingdoms:ENTRY NAME:Struts: Form Field Without Validator::TAXONOMY NAME:Software Fault Patterns:ENTRY ID:SFP24:ENTRY NAME:Tainted input to command::",,"",
106,"Struts: Plug-in Framework not in Use",Variant,Draft,"When an application does not use an input validation framework such as the Struts Validator, there is a greater risk of introducing weaknesses related to insufficient input validation.","Unchecked input is the leading cause of vulnerabilities in J2EE applications. Unchecked input leads to cross-site scripting, process control, and SQL injection vulnerabilities, among others. Although J2EE applications are not generally susceptible to memory corruption attacks, if a J2EE application interfaces with native code that does not perform array bounds checking, an attacker may be able to use an input validation mistake in the J2EE application to launch a buffer overflow attack.",::NATURE:ChildOf:CWE ID:1173:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:20:VIEW ID:700:ORDINAL:Primary::,"::ORDINALITY:Primary::",::LANGUAGE NAME:Java:LANGUAGE PREVALENCE:Undetermined::,"","","::PHASE:Implementation::","",,"::SCOPE:Integrity:IMPACT:Unexpected State::","","::PHASE:Architecture and Design:STRATEGY:Input Validation:DESCRIPTION:Use an input validation framework such as Struts.::PHASE:Architecture and Design:STRATEGY:Libraries or Frameworks:DESCRIPTION:Use an input validation framework such as Struts.::PHASE:Implementation:STRATEGY:Input Validation:DESCRIPTION:Use the Struts Validator to validate all program input before it is processed by the application. Ensure that there are no holes in the configuration of the Struts Validator. Example uses of the validator include checking to ensure that: Phone number fields contain only valid characters in phone numbers Boolean values are only T or F Free-form strings are of a reasonable length and composition::PHASE:Implementation:STRATEGY:Libraries or Frameworks:DESCRIPTION:Use the Struts Validator to validate all program input before it is processed by the application. Ensure that there are no holes in the configuration of the Struts Validator. Example uses of the validator include checking to ensure that: Phone number fields contain only valid characters in phone numbers Boolean values are only T or F Free-form strings are of a reasonable length and composition::","",,,"::TAXONOMY NAME:7 Pernicious Kingdoms:ENTRY NAME:Struts: Plug-in Framework Not In Use::",,"",
107,"Struts: Unused Validation Form",Variant,Draft,"An unused validation form indicates that validation logic is not up-to-date.","It is easy for developers to forget to update validation logic when they remove or rename action form mappings. One indication that validation logic is not being properly maintained is the presence of an unused validation form.",::NATURE:ChildOf:CWE ID:1164:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:20:VIEW ID:700:ORDINAL:Primary::,"::ORDINALITY:Resultant::",::LANGUAGE NAME:Java:LANGUAGE PREVALENCE:Undetermined::,"","","::PHASE:Implementation::PHASE:Operation::","",,"::SCOPE:Other:IMPACT:Quality Degradation::","","::PHASE:Implementation:DESCRIPTION:Remove the unused Validation Form from the validation.xml file.::","",,,"::TAXONOMY NAME:7 Pernicious Kingdoms:ENTRY NAME:Struts: Unused Validation Form::",,"",
108,"Struts: Unvalidated Action Form",Variant,Incomplete,"Every Action Form must have a corresponding validation form.","If a Struts Action Form Mapping specifies a form, it must have a validation form defined under the Struts Validator.",::NATURE:ChildOf:CWE ID:1173:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:20:VIEW ID:700:ORDINAL:Primary::,"::ORDINALITY:Primary::",::LANGUAGE NAME:Java:LANGUAGE PREVALENCE:Undetermined::,"","","::PHASE:Implementation::","",,"::SCOPE:Other:IMPACT:Other:NOTE:If an action form mapping does not have a validation form defined, it may be vulnerable to a number of attacks that rely on unchecked input. Unchecked input is the root cause of some of today's worst and most common software security problems. Cross-site scripting, SQL injection, and process control vulnerabilities all stem from incomplete or absent input validation.::SCOPE:Confidentiality:SCOPE:Integrity:SCOPE:Availability:SCOPE:Other:IMPACT:Other:NOTE:Although J2EE applications are not generally susceptible to memory corruption attacks, if a J2EE application interfaces with native code that does not perform array bounds checking, an attacker may be able to use an input validation mistake in the J2EE application to launch a buffer overflow attack.::","","::PHASE:Implementation:STRATEGY:Input Validation:DESCRIPTION:Map every Action Form to a corresponding validation form. An action or a form may perform validation in other ways, but the Struts Validator provides an excellent way to verify that all input receives at least a basic level of validation. Without this approach, it is difficult, and often impossible, to establish with a high level of confidence that all input is validated.::","",,,"::TAXONOMY NAME:7 Pernicious Kingdoms:ENTRY NAME:Struts: Unvalidated Action Form::TAXONOMY NAME:Software Fault Patterns:ENTRY ID:SFP24:ENTRY NAME:Tainted input to command::",,"",
109,"Struts: Validator Turned Off",Variant,Draft,"Automatic filtering via a Struts bean has been turned off, which disables the Struts Validator and custom validation logic. This exposes the application to other weaknesses related to insufficient input validation.","",::NATURE:ChildOf:CWE ID:1173:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:20:VIEW ID:700:ORDINAL:Primary::,"::ORDINALITY:Primary::",::LANGUAGE NAME:Java:LANGUAGE PREVALENCE:Undetermined::,"","","::PHASE:Implementation::","",,"::SCOPE:Access Control:IMPACT:Bypass Protection Mechanism::","","::PHASE:Implementation:DESCRIPTION:Ensure that an action form mapping enables validation. Set the validate field to true.::","",,,"::TAXONOMY NAME:7 Pernicious Kingdoms:ENTRY NAME:Struts: Validator Turned Off::TAXONOMY NAME:Software Fault Patterns:ENTRY ID:SFP24:ENTRY NAME:Tainted input to command::",,"::TYPE:Other:NOTE:The Action Form mapping in the demonstrative example disables the form's validate() method. The Struts bean: write tag automatically encodes special HTML characters, replacing a < with &lt; and a > with &gt;. This action can be disabled by specifying filter=false as an attribute of the tag to disable specified JSP pages. However, being disabled makes these pages susceptible to cross-site scripting attacks. An attacker may be able to insert malicious scripts as user input to write to these JSP pages.::",
110,"Struts: Validator Without Form Field",Variant,Draft,"Validation fields that do not appear in forms they are associated with indicate that the validation logic is out of date.","It is easy for developers to forget to update validation logic when they make changes to an ActionForm class. One indication that validation logic is not being properly maintained is inconsistencies between the action form and the validation form. Although J2EE applications are not generally susceptible to memory corruption attacks, if a J2EE application interfaces with native code that does not perform array bounds checking, an attacker may be able to use an input validation mistake in the J2EE application to launch a buffer overflow attack.",::NATURE:ChildOf:CWE ID:1164:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:20:VIEW ID:700:ORDINAL:Primary::,"::ORDINALITY:Primary::",::LANGUAGE NAME:Java:LANGUAGE PREVALENCE:Undetermined::,"","","::PHASE:Implementation::PHASE:Operation::","",,"::SCOPE:Other:IMPACT:Other:NOTE:It is critically important that validation logic be maintained and kept in sync with the rest of the application. Unchecked input is the root cause of some of today's worst and most common software security problems. Cross-site scripting, SQL injection, and process control vulnerabilities all stem from incomplete or absent input validation.::","::METHOD:Automated Static Analysis:DESCRIPTION:To find the issue in the implementation, manual checks or automated static analysis could be applied to the XML configuration files.:EFFECTIVENESS:Moderate::METHOD:Manual Static Analysis:DESCRIPTION:To find the issue in the implementation, manual checks or automated static analysis could be applied to the XML configuration files.:EFFECTIVENESS:Moderate::","","",,,"::TAXONOMY NAME:7 Pernicious Kingdoms:ENTRY NAME:Struts: Validator Without Form Field::TAXONOMY NAME:Software Fault Patterns:ENTRY ID:SFP24:ENTRY NAME:Tainted input to command::",,"",
111,"Direct Use of Unsafe JNI",Variant,Draft,"When a Java application uses the Java Native Interface (JNI) to call code written in another programming language, it can expose the application to weaknesses in that code, even if those weaknesses cannot occur in Java.","Many safety features that programmers may take for granted do not apply for native code, so you must carefully review all such code for potential problems. The languages used to implement native code may be more susceptible to buffer overflows and other attacks. Native code is unprotected by the security features enforced by the runtime environment, such as strong typing and array bounds checking.",::NATURE:ChildOf:CWE ID:695:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:20:VIEW ID:700:ORDINAL:Primary::,"::ORDINALITY:Primary::",::LANGUAGE NAME:Java:LANGUAGE PREVALENCE:Undetermined::,"","","::PHASE:Implementation::","",,"::SCOPE:Access Control:IMPACT:Bypass Protection Mechanism::","","::PHASE:Implementation:DESCRIPTION:Implement error handling around the JNI call.::PHASE:Implementation:STRATEGY:Refactoring:DESCRIPTION:Do not use JNI calls if you don't trust the native library.::PHASE:Implementation:STRATEGY:Refactoring:DESCRIPTION:Be reluctant to use JNI calls. A Java API equivalent may exist.::","",,,"::TAXONOMY NAME:7 Pernicious Kingdoms:ENTRY NAME:Unsafe JNI::TAXONOMY NAME:The CERT Oracle Secure Coding Standard for Java (2011):ENTRY ID:SEC08-J:ENTRY NAME:Define wrappers around native methods::TAXONOMY NAME:SEI CERT Oracle Coding Standard for Java:ENTRY ID:JNI01-J:ENTRY NAME:Safely invoke standard APIs that perform tasks using the immediate caller's class loader instance (loadLibrary)::TAXONOMY NAME:SEI CERT Oracle Coding Standard for Java:ENTRY ID:JNI00-J:ENTRY NAME:Define wrappers around native methods:MAPPING FIT:Imprecise::TAXONOMY NAME:Software Fault Patterns:ENTRY ID:SFP3:ENTRY NAME:Use of an improper API::",,"",
112,"Missing XML Validation",Base,Draft,"The product accepts XML from an untrusted source but does not validate the XML against the proper schema.","Most successful attacks begin with a violation of the programmer's assumptions. By accepting an XML document without validating it against a DTD or XML schema, the programmer leaves a door open for attackers to provide unexpected, unreasonable, or malicious input.",::NATURE:ChildOf:CWE ID:1286:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:20:VIEW ID:700:ORDINAL:Primary::,"::ORDINALITY:Primary::",::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::,"","","::PHASE:Implementation::","",,"::SCOPE:Integrity:IMPACT:Unexpected State::","","::PHASE:Architecture and Design:STRATEGY:Input Validation:DESCRIPTION:Always validate XML input against a known XML Schema or DTD. It is not possible for an XML parser to validate all aspects of a document's content because a parser cannot understand the complete semantics of the data. However, a parser can do a complete and thorough job of checking the document's structure and therefore guarantee to the code that processes the document that the content is well-formed.::","",,,"::TAXONOMY NAME:7 Pernicious Kingdoms:ENTRY NAME:Missing XML Validation::TAXONOMY NAME:Software Fault Patterns:ENTRY ID:SFP24:ENTRY NAME:Tainted input to command::",::230::231::,"",
113,"Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Request/Response Splitting')",Variant,Incomplete,"The product receives data from an HTTP agent/component (e.g., web server, proxy, browser, etc.), but it does not neutralize or incorrectly neutralizes CR and LF characters before the data is included in outgoing HTTP headers.","HTTP agents or components may include a web server, load balancer, reverse proxy, web caching proxy, application firewall, web browser, etc. Regardless of the role, they are expected to maintain coherent, consistent HTTP communication state across all components. However, including unexpected data in an HTTP header allows an attacker to specify the entirety of the HTTP message that is rendered by the client HTTP agent (e.g., web browser) or back-end HTTP agent (e.g., web server), whether the message is part of a request or a response. When an HTTP request contains unexpected CR and LF characters, the server may respond with an output stream that is interpreted as splitting the stream into two different HTTP messages instead of one. CR is carriage return, also given by %0d or r, and LF is line feed, also given by %0a or n. In addition to CR and LF characters, other valid/RFC compliant special characters and unique character encodings can be utilized, such as HT (horizontal tab, also given by %09 or t) and SP (space, also given as + sign or %20). These types of unvalidated and unexpected data in HTTP message headers allow an attacker to control the second split message to mount attacks such as server-side request forgery, cross-site scripting, and cache poisoning attacks. HTTP response splitting weaknesses may be present when: Data enters a web application through an untrusted source, most frequently an HTTP request. The data is included in an HTTP response header sent to a web user without neutralizing malicious characters that can be interpreted as separator characters for headers.",::NATURE:ChildOf:CWE ID:93:VIEW ID:1000:ORDINAL:Primary::NATURE:CanPrecede:CWE ID:79:VIEW ID:1000::NATURE:ChildOf:CWE ID:20:VIEW ID:700:ORDINAL:Primary::NATURE:ChildOf:CWE ID:436:VIEW ID:1000::,"",::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::TECHNOLOGY CLASS:Web Based:TECHNOLOGY PREVALENCE:Undetermined::,"","::TERM:HTTP Request Splitting::TERM:HTTP Response Splitting::","::PHASE:Implementation::","",,"::SCOPE:Integrity:SCOPE:Access Control:IMPACT:Modify Application Data:IMPACT:Gain Privileges or Assume Identity:NOTE:CR and LF characters in an HTTP header may give attackers control of the remaining headers and body of the message that the application intends to send/receive, as well as allowing them to create additional messages entirely under their control.::","","::PHASE:Implementation:STRATEGY:Input Validation:DESCRIPTION:Construct HTTP headers very carefully, avoiding the use of non-validated input data.::PHASE:Implementation:STRATEGY:Input Validation:DESCRIPTION:Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. If an input does not strictly conform to specifications, reject it or transform it into something that conforms. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.::PHASE:Implementation:STRATEGY:Output Encoding:DESCRIPTION:Use and specify an output encoding that can be handled by the downstream component that is reading the output. Common encodings include ISO-8859-1, UTF-7, and UTF-8. When an encoding is not specified, a downstream component may choose a different encoding, either by assuming a default encoding or automatically inferring which encoding is being used, which can be erroneous. When the encodings are inconsistent, the downstream component might treat some character or byte sequences as special, even if they are not special in the original encoding. Attackers might then be able to exploit this discrepancy and conduct injection attacks; they even might be able to bypass protection mechanisms that assume the original encoding is also being used by the downstream component.::PHASE:Implementation:STRATEGY:Input Validation:DESCRIPTION:Inputs should be decoded and canonicalized to the application's current internal representation before being validated (CWE-180). Make sure that the application does not decode the same input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by introducing dangerous inputs after they have been checked.::","::REFERENCE:CVE-2020-15811:DESCRIPTION:Chain: Proxy uses a substring search instead of parsing the Transfer-Encoding header (CWE-697), allowing request splitting (CWE-113) and cache poisoning:LINK:https://www.cve.org/CVERecord?id=CVE-2020-15811::REFERENCE:CVE-2021-41084:DESCRIPTION:Scala-based HTTP interface allows request splitting and response splitting through header names, header values, status reasons, and URIs:LINK:https://www.cve.org/CVERecord?id=CVE-2021-41084::REFERENCE:CVE-2018-12116:DESCRIPTION:Javascript-based framework allows request splitting through a path option of an HTTP request:LINK:https://www.cve.org/CVERecord?id=CVE-2018-12116::REFERENCE:CVE-2004-2146:DESCRIPTION:Application accepts CRLF in an object ID, allowing HTTP response splitting.:LINK:https://www.cve.org/CVERecord?id=CVE-2004-2146::REFERENCE:CVE-2004-1656:DESCRIPTION:Shopping cart allows HTTP response splitting to perform HTML injection via CRLF in a parameter for a url:LINK:https://www.cve.org/CVERecord?id=CVE-2004-1656::REFERENCE:CVE-2005-2060:DESCRIPTION:Bulletin board allows response splitting via CRLF in parameter.:LINK:https://www.cve.org/CVERecord?id=CVE-2005-2060::REFERENCE:CVE-2004-2512:DESCRIPTION:Response splitting via CRLF in PHPSESSID.:LINK:https://www.cve.org/CVERecord?id=CVE-2004-2512::REFERENCE:CVE-2005-1951:DESCRIPTION:e-commerce app allows HTTP response splitting using CRLF in object id parameters:LINK:https://www.cve.org/CVERecord?id=CVE-2005-1951::",,,"::TAXONOMY NAME:PLOVER:ENTRY NAME:HTTP response splitting::TAXONOMY NAME:7 Pernicious Kingdoms:ENTRY NAME:HTTP Response Splitting::TAXONOMY NAME:WASC:ENTRY ID:25:ENTRY NAME:HTTP Response Splitting::TAXONOMY NAME:Software Fault Patterns:ENTRY ID:SFP24:ENTRY NAME:Tainted input to command::",::105::31::34::85::,"",
114,"Process Control",Class,Incomplete,"Executing commands or loading libraries from an untrusted source or in an untrusted environment can cause an application to execute malicious commands (and payloads) on behalf of an attacker.","Process control vulnerabilities take two forms: An attacker can change the command that the program executes: the attacker explicitly controls what the command is. An attacker can change the environment in which the command executes: the attacker implicitly controls what the command means. Process control vulnerabilities of the first type occur when either data enters the application from an untrusted source and the data is used as part of a string representing a command that is executed by the application. By executing the command, the application gives an attacker a privilege or capability that the attacker would not otherwise have.",::NATURE:ChildOf:CWE ID:73:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:20:VIEW ID:700:ORDINAL:Primary::,"",::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::,"","","::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::","",,"::SCOPE:Confidentiality:SCOPE:Integrity:SCOPE:Availability:IMPACT:Execute Unauthorized Code or Commands::","","::PHASE:Architecture and Design:STRATEGY:Libraries or Frameworks:DESCRIPTION:Libraries that are loaded should be well understood and come from a trusted source. The application can execute code contained in the native libraries, which often contain calls that are susceptible to other security problems, such as buffer overflows or command injection. All native libraries should be validated to determine if the application requires the use of the library. It is very difficult to determine what these native libraries actually do, and the potential for malicious code is high. In addition, the potential for an inadvertent mistake in these native libraries is also high, as many are written in C or C++ and may be susceptible to buffer overflow or race condition problems. To help prevent buffer overflow attacks, validate all input to native calls for content and length. If the native library does not come from a trusted source, review the source code of the library. The library should be built from the reviewed source before using it.::","",,::System Process::,"::TAXONOMY NAME:7 Pernicious Kingdoms:ENTRY NAME:Process Control::",::108::640::,"::TYPE:Maintenance:NOTE:CWE-114 is a Class, but it is listed a child of CWE-73 in view 1000. This suggests some abstraction problems that should be resolved in future versions.::TYPE:Maintenance:NOTE:This entry seems to have close relationships with CWE-426/CWE-427. It seems more attack-oriented.::",
115,"Misinterpretation of Input",Base,Incomplete,"The product misinterprets an input, whether from an attacker or another product, in a security-relevant fashion.","",::NATURE:ChildOf:CWE ID:436:VIEW ID:1000:ORDINAL:Primary::,"",::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::,"","","::PHASE:Architecture and Design::PHASE:Implementation::","",,"::SCOPE:Integrity:IMPACT:Unexpected State::","","","::REFERENCE:CVE-2005-2225:DESCRIPTION:Product sees dangerous file extension in free text of a group discussion, disconnects all users.:LINK:https://www.cve.org/CVERecord?id=CVE-2005-2225::REFERENCE:CVE-2001-0003:DESCRIPTION:Product does not correctly import and process security settings from another product.:LINK:https://www.cve.org/CVERecord?id=CVE-2001-0003::",,,"::TAXONOMY NAME:PLOVER:ENTRY NAME:Misinterpretation Error::",,"::TYPE:Research Gap:NOTE:This concept needs further study. It is likely a factor in several weaknesses, possibly resultant as well. Overlaps Multiple Interpretation Errors (MIE).::",
116,"Improper Encoding or Escaping of Output",Class,Draft,"The product prepares a structured message for communication with another component, but encoding or escaping of the data is either missing or done incorrectly. As a result, the intended structure of the message is not preserved.","Improper encoding or escaping can allow attackers to change the commands that are sent to another component, inserting malicious commands instead. Most products follow a certain protocol that uses structured messages for communication between components, such as queries or commands. These structured messages can contain raw data interspersed with metadata or control information. For example, GET /index.html HTTP/1.1 is a structured message containing a command (GET) with a single argument (/index.html) and metadata about which protocol version is being used (HTTP/1.1). If an application uses attacker-supplied inputs to construct a structured message without properly encoding or escaping, then the attacker could insert special characters that will cause the data to be interpreted as control information or metadata. Consequently, the component that receives the output will perform the wrong operations, or otherwise interpret the data incorrectly.",::NATURE:ChildOf:CWE ID:707:VIEW ID:1000:ORDINAL:Primary::NATURE:CanPrecede:CWE ID:74:VIEW ID:1000::,"",::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Often::TECHNOLOGY NAME:Database Server:TECHNOLOGY PREVALENCE:Often::TECHNOLOGY NAME:Web Server:TECHNOLOGY PREVALENCE:Often::,"","::TERM:Output Sanitization::TERM:Output Validation::TERM:Output Encoding::","::PHASE:Architecture and Design::PHASE:Implementation::PHASE:Operation::","",,"::SCOPE:Integrity:IMPACT:Modify Application Data:NOTE:The communications between components can be modified in unexpected ways. Unexpected commands can be executed, bypassing other security mechanisms. Incoming data can be misinterpreted.::SCOPE:Integrity:SCOPE:Confidentiality:SCOPE:Availability:SCOPE:Access Control:IMPACT:Execute Unauthorized Code or Commands:NOTE:The communications between components can be modified in unexpected ways. Unexpected commands can be executed, bypassing other security mechanisms. Incoming data can be misinterpreted.::SCOPE:Confidentiality:IMPACT:Bypass Protection Mechanism:NOTE:The communications between components can be modified in unexpected ways. Unexpected commands can be executed, bypassing other security mechanisms. Incoming data can be misinterpreted.::","::METHOD:Automated Static Analysis:DESCRIPTION:This weakness can often be detected using automated static analysis tools. Many modern tools use data flow analysis or constraint-based techniques to minimize the number of false positives.:EFFECTIVENESS:Moderate::METHOD:Automated Dynamic Analysis:DESCRIPTION:This weakness can be detected using dynamic tools and techniques that interact with the software using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The software's operation may slow down, but it should not become unstable, crash, or generate incorrect results.::","::PHASE:Architecture and Design:STRATEGY:Libraries or Frameworks:DESCRIPTION:Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. For example, consider using the ESAPI Encoding control [REF-45] or a similar tool, library, or framework. These will help the programmer encode outputs in a manner less prone to error. Alternately, use built-in functions, but consider using wrappers in case those functions are discovered to have a vulnerability.::PHASE:Architecture and Design:STRATEGY:Parameterization:DESCRIPTION:If available, use structured mechanisms that automatically enforce the separation between data and code. These mechanisms may be able to provide the relevant quoting, encoding, and validation automatically, instead of relying on the developer to provide this capability at every point where output is generated. For example, stored procedures can enforce database query structure and reduce the likelihood of SQL injection.::PHASE:Architecture and Design Implementation:DESCRIPTION:Understand the context in which your data will be used and the encoding that will be expected. This is especially important when transmitting data between different components, or when generating outputs that can contain multiple encodings at the same time, such as web pages or multi-part mail messages. Study all expected communication protocols and data representations to determine the required encoding strategies.::PHASE:Architecture and Design:DESCRIPTION:In some cases, input validation may be an important strategy when output encoding is not a complete solution. For example, you may be providing the same output that will be processed by multiple consumers that use different encodings or representations. In other cases, you may be required to allow user-supplied input to contain control information, such as limited HTML tags that support formatting in a wiki or bulletin board. When this type of requirement must be met, use an extremely strict allowlist to limit which control sequences can be used. Verify that the resulting syntactic structure is what you expect. Use your normal encoding methods for the remainder of the input.::PHASE:Architecture and Design:DESCRIPTION:Use input validation as a defense-in-depth measure to reduce the likelihood of output encoding errors (see CWE-20).::PHASE:Requirements:DESCRIPTION:Fully specify which encodings are required by components that will be communicating with each other.::PHASE:Implementation:DESCRIPTION:When exchanging data between components, ensure that both components are using the same character encoding. Ensure that the proper encoding is applied at each interface. Explicitly set the encoding you are using whenever the protocol allows you to do so.::","::REFERENCE:CVE-2021-41232:DESCRIPTION:Chain: authentication routine in Go-based agile development product does not escape user name (CWE-116), allowing LDAP injection (CWE-90):LINK:https://www.cve.org/CVERecord?id=CVE-2021-41232::REFERENCE:CVE-2008-4636:DESCRIPTION:OS command injection in backup software using shell metacharacters in a filename; correct behavior would require that this filename could not be changed.:LINK:https://www.cve.org/CVERecord?id=CVE-2008-4636::REFERENCE:CVE-2008-0769:DESCRIPTION:Web application does not set the charset when sending a page to a browser, allowing for XSS exploitation when a browser chooses an unexpected encoding.:LINK:https://www.cve.org/CVERecord?id=CVE-2008-0769::REFERENCE:CVE-2008-0005:DESCRIPTION:Program does not set the charset when sending a page to a browser, allowing for XSS exploitation when a browser chooses an unexpected encoding.:LINK:https://www.cve.org/CVERecord?id=CVE-2008-0005::REFERENCE:CVE-2008-5573:DESCRIPTION:SQL injection via password parameter; a strong password might contain &:LINK:https://www.cve.org/CVERecord?id=CVE-2008-5573::REFERENCE:CVE-2008-3773:DESCRIPTION:Cross-site scripting in chat application via a message subject, which normally might contain & and other XSS-related characters.:LINK:https://www.cve.org/CVERecord?id=CVE-2008-3773::REFERENCE:CVE-2008-0757:DESCRIPTION:Cross-site scripting in chat application via a message, which normally might be allowed to contain arbitrary content.:LINK:https://www.cve.org/CVERecord?id=CVE-2008-0757::",,,"::TAXONOMY NAME:WASC:ENTRY ID:22:ENTRY NAME:Improper Output Handling::TAXONOMY NAME:The CERT Oracle Secure Coding Standard for Java (2011):ENTRY ID:IDS00-J:ENTRY NAME:Sanitize untrusted data passed across a trust boundary:MAPPING FIT:Exact::TAXONOMY NAME:The CERT Oracle Secure Coding Standard for Java (2011):ENTRY ID:IDS05-J:ENTRY NAME:Use a subset of ASCII for file and path names::TAXONOMY NAME:SEI CERT Oracle Coding Standard for Java:ENTRY ID:IDS00-J:ENTRY NAME:Prevent SQL injection:MAPPING FIT:Imprecise::TAXONOMY NAME:SEI CERT Perl Coding Standard:ENTRY ID:IDS33-PL:ENTRY NAME:Sanitize untrusted data passed across a trust boundary:MAPPING FIT:Exact::",::104::73::81::85::,"::TYPE:Relationship:NOTE:This weakness is primary to all weaknesses related to injection (CWE-74) since the inherent nature of injection involves the violation of structured messages.::TYPE:Relationship:NOTE:CWE-116 and CWE-20 have a close association because, depending on the nature of the structured message, proper input validation can indirectly prevent special characters from changing the meaning of a structured message. For example, by validating that a numeric ID field should only contain the 0-9 characters, the programmer effectively prevents injection attacks. However, input validation is not always sufficient, especially when less stringent data types must be supported, such as free-form text. Consider a SQL injection scenario in which a last name is inserted into a query. The name O'Reilly would likely pass the validation step since it is a common last name in the English language. However, it cannot be directly inserted into the database because it contains the ' apostrophe character, which would need to be escaped or otherwise neutralized. In this case, stripping the apostrophe might reduce the risk of SQL injection, but it would produce incorrect behavior because the wrong name would be recorded.::TYPE:Terminology:NOTE:The usage of the encoding and escaping terms varies widely. For example, in some programming languages, the terms are used interchangeably, while other languages provide APIs that use both terms for different tasks. This overlapping usage extends to the Web, such as the escape JavaScript function whose purpose is stated to be encoding. The concepts of encoding and escaping predate the Web by decades. Given such a context, it is difficult for CWE to adopt a consistent vocabulary that will not be misinterpreted by some constituency.::TYPE:Theoretical:NOTE:This is a data/directive boundary error in which data boundaries are not sufficiently enforced before it is sent to a different control sphere.::TYPE:Research Gap:NOTE:While many published vulnerabilities are related to insufficient output encoding, there is such an emphasis on input validation as a protection mechanism that the underlying causes are rarely described. Within CVE, the focus is primarily on well-understood issues like cross-site scripting and SQL injection. It is likely that this weakness frequently occurs in custom protocols that support multiple encodings, which are not necessarily detectable with automated techniques.::",
117,"Improper Output Neutralization for Logs",Base,Draft,"The product does not neutralize or incorrectly neutralizes output that is written to logs.","This can allow an attacker to forge log entries or inject malicious content into logs. Log forging vulnerabilities occur when: Data enters an application from an untrusted source. The data is written to an application or system log file.",::NATURE:ChildOf:CWE ID:116:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:20:VIEW ID:700:ORDINAL:Primary::,"::ORDINALITY:Primary::",::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::,"::Applications typically use log files to store a history of events or transactions for later review, statistics gathering, or debugging. Depending on the nature of the application, the task of reviewing log files may be performed manually on an as-needed basis or automated with a tool that automatically culls logs for important events or trending information.::","","::PHASE:Implementation:NOTE:REALIZATION: This weakness is caused during implementation of an architectural security tactic.::","",,"::SCOPE:Integrity:SCOPE:Confidentiality:SCOPE:Availability:SCOPE:Non-Repudiation:IMPACT:Modify Application Data:IMPACT:Hide Activities:IMPACT:Execute Unauthorized Code or Commands:NOTE:Interpretation of the log files may be hindered or misdirected if an attacker can supply data to the application that is subsequently logged verbatim. In the most benign case, an attacker may be able to insert false entries into the log file by providing the application with input that includes appropriate characters. Forged or otherwise corrupted log files can be used to cover an attacker's tracks, possibly by skewing statistics, or even to implicate another party in the commission of a malicious act. If the log file is processed automatically, the attacker can render the file unusable by corrupting the format of the file or injecting unexpected characters. An attacker may inject code or other commands into the log file and take advantage of a vulnerability in the log processing utility.::","","::PHASE:Implementation:STRATEGY:Input Validation:DESCRIPTION:Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.::PHASE:Implementation:STRATEGY:Output Encoding:DESCRIPTION:Use and specify an output encoding that can be handled by the downstream component that is reading the output. Common encodings include ISO-8859-1, UTF-7, and UTF-8. When an encoding is not specified, a downstream component may choose a different encoding, either by assuming a default encoding or automatically inferring which encoding is being used, which can be erroneous. When the encodings are inconsistent, the downstream component might treat some character or byte sequences as special, even if they are not special in the original encoding. Attackers might then be able to exploit this discrepancy and conduct injection attacks; they even might be able to bypass protection mechanisms that assume the original encoding is also being used by the downstream component.::PHASE:Implementation:STRATEGY:Input Validation:DESCRIPTION:Inputs should be decoded and canonicalized to the application's current internal representation before being validated (CWE-180). Make sure that the application does not decode the same input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by introducing dangerous inputs after they have been checked.::","::REFERENCE:CVE-2006-4624:DESCRIPTION:Chain: inject fake log entries with fake timestamps using CRLF injection:LINK:https://www.cve.org/CVERecord?id=CVE-2006-4624::",,,"::TAXONOMY NAME:7 Pernicious Kingdoms:ENTRY NAME:Log Forging::TAXONOMY NAME:Software Fault Patterns:ENTRY ID:SFP23:ENTRY NAME:Exposed Data::TAXONOMY NAME:The CERT Oracle Secure Coding Standard for Java (2011):ENTRY ID:IDS03-J:ENTRY NAME:Do not log unsanitized user input:MAPPING FIT:Exact::TAXONOMY NAME:SEI CERT Oracle Coding Standard for Java:ENTRY ID:IDS03-J:ENTRY NAME:Do not log unsanitized user input:MAPPING FIT:Exact::",::268::81::93::,"",
118,"Incorrect Access of Indexable Resource ('Range Error')",Class,Incomplete,"The product does not restrict or incorrectly restricts operations within the boundaries of a resource that is accessed using an index or pointer, such as memory or files.","",::NATURE:ChildOf:CWE ID:664:VIEW ID:1000:ORDINAL:Primary::,"",::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::TECHNOLOGY CLASS:Not Technology-Specific:TECHNOLOGY PREVALENCE:Undetermined::,"","","::PHASE:Architecture and Design::PHASE:Implementation::","",,"::SCOPE:Other:IMPACT:Varies by Context::","","","",,,"::TAXONOMY NAME:Software Fault Patterns:ENTRY ID:SFP8:ENTRY NAME:Faulty Buffer Access::",::10::14::24::45::46::47::8::9::,"",
119,"Improper Restriction of Operations within the Bounds of a Memory Buffer",Class,Stable,"The product performs operations on a memory buffer, but it can read from or write to a memory location that is outside of the intended boundary of the buffer.","Certain languages allow direct addressing of memory locations and do not automatically ensure that these locations are valid for the memory buffer that is being referenced. This can cause read or write operations to be performed on memory locations that may be associated with other variables, data structures, or internal program data. As a result, an attacker may be able to execute arbitrary code, alter the intended control flow, read sensitive information, or cause the system to crash.",::NATURE:ChildOf:CWE ID:118:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:20:VIEW ID:700:ORDINAL:Primary::,"",::LANGUAGE NAME:C:LANGUAGE PREVALENCE:Often::LANGUAGE NAME:C++:LANGUAGE PREVALENCE:Often::LANGUAGE CLASS:Assembly:LANGUAGE PREVALENCE:Undetermined::,"","::TERM:Buffer Overflow:DESCRIPTION:This term has many different meanings to different audiences. From a CWE mapping perspective, this term should be avoided where possible. Some researchers, developers, and tools intend for it to mean write past the end of a buffer, whereas others use the same term to mean any read or write outside the boundaries of a buffer, whether before the beginning of the buffer or after the end of the buffer. Still others using the same term could mean any action after the end of a buffer, whether it is a read or write. Since the term is commonly used for exploitation and for vulnerabilities, it further confuses things.::TERM:buffer overrun:DESCRIPTION:Some prominent vendors and researchers use the term buffer overrun, but most people use buffer overflow. See the alternate term for buffer overflow for context.::TERM:memory safety:DESCRIPTION:Generally used for techniques that avoid weaknesses related to memory access, such as those identified by CWE-119 and its descendants. However, the term is not formal, and there is likely disagreement between practitioners as to which weaknesses are implicitly covered by the memory safety term.::","::PHASE:Architecture and Design::PHASE:Implementation::","",,"::SCOPE:Integrity:SCOPE:Confidentiality:SCOPE:Availability:IMPACT:Execute Unauthorized Code or Commands:IMPACT:Modify Memory:NOTE:If the memory accessible by the attacker can be effectively controlled, it may be possible to execute arbitrary code, as with a standard buffer overflow. If the attacker can overwrite a pointer's worth of memory (usually 32 or 64 bits), they can redirect a function pointer to their own malicious code. Even when the attacker can only modify a single byte arbitrary code execution can be possible. Sometimes this is because the same problem can be exploited repeatedly to the same effect. Other times it is because the attacker can overwrite security-critical application-specific data -- such as a flag indicating whether the user is an administrator.::SCOPE:Availability:SCOPE:Confidentiality:IMPACT:Read Memory:IMPACT:DoS: Crash, Exit, or Restart:IMPACT:DoS: Resource Consumption (CPU):IMPACT:DoS: Resource Consumption (Memory):NOTE:Out of bounds memory access will very likely result in the corruption of relevant memory, and perhaps instructions, possibly leading to a crash. Other attacks leading to lack of availability are possible, including putting the program into an infinite loop.::SCOPE:Confidentiality:IMPACT:Read Memory:NOTE:In the case of an out-of-bounds read, the attacker may have access to sensitive information. If the sensitive information contains system details, such as the current buffers position in memory, this knowledge can be used to craft further attacks, possibly with more severe consequences.::","::METHOD:Automated Static Analysis:DESCRIPTION:This weakness can often be detected using automated static analysis tools. Many modern tools use data flow analysis or constraint-based techniques to minimize the number of false positives. Automated static analysis generally does not account for environmental considerations when reporting out-of-bounds memory operations. This can make it difficult for users to determine which warnings should be investigated first. For example, an analysis tool might report buffer overflows that originate from command line arguments in a program that is not expected to run with setuid or other special privileges.:EFFECTIVENESS:High::METHOD:Automated Dynamic Analysis:DESCRIPTION:This weakness can be detected using dynamic tools and techniques that interact with the software using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The software's operation may slow down, but it should not become unstable, crash, or generate incorrect results.::METHOD:Automated Static Analysis - Binary or Bytecode:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Binary / Bytecode Quality Analysis Bytecode Weakness Analysis - including disassembler + source code weakness analysis Binary Weakness Analysis - including disassembler + source code weakness analysis:EFFECTIVENESS:SOAR Partial::METHOD:Manual Static Analysis - Binary or Bytecode:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Binary / Bytecode disassembler - then use manual analysis for vulnerabilities & anomalies:EFFECTIVENESS:SOAR Partial::METHOD:Dynamic Analysis with Automated Results Interpretation:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Web Application Scanner Web Services Scanner Database Scanners:EFFECTIVENESS:SOAR Partial::METHOD:Dynamic Analysis with Manual Results Interpretation:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Fuzz Tester Framework-based Fuzzer:EFFECTIVENESS:SOAR Partial::METHOD:Manual Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Focused Manual Spotcheck - Focused manual analysis of source Manual Source Code Review (not inspections):EFFECTIVENESS:SOAR Partial::METHOD:Automated Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Source code Weakness Analyzer Context-configured Source Code Weakness Analyzer Cost effective for partial coverage: Source Code Quality Analyzer:EFFECTIVENESS:High::METHOD:Architecture or Design Review:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Formal Methods / Correct-By-Construction Cost effective for partial coverage: Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.):EFFECTIVENESS:High::","::PHASE:Requirements:STRATEGY:Language Selection:DESCRIPTION:Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. For example, many languages that perform their own memory management, such as Java and Perl, are not subject to buffer overflows. Other languages, such as Ada and C#, typically provide overflow protection, but the protection can be disabled by the programmer. Be wary that a language's interface to native code may still be subject to overflows, even if the language itself is theoretically safe.::PHASE:Architecture and Design:STRATEGY:Libraries or Frameworks:DESCRIPTION:Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. Examples include the Safe C String Library (SafeStr) by Messier and Viega [REF-57], and the Strsafe.h library from Microsoft [REF-56]. These libraries provide safer versions of overflow-prone string-handling functions.::PHASE:Build and Compilation:STRATEGY:Compilation or Build Hardening:DESCRIPTION:Run or compile the software using features or extensions that automatically provide a protection mechanism that mitigates or eliminates buffer overflows. For example, certain compilers and extensions provide automatic buffer overflow detection mechanisms that are built into the compiled code. Examples include the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice.:EFFECTIVENESS:Defense in Depth::PHASE:Implementation:DESCRIPTION:Consider adhering to the following rules when allocating and managing an application's memory: Double check that the buffer is as large as specified. When using functions that accept a number of bytes to copy, such as strncpy(), be aware that if the destination buffer size is equal to the source buffer size, it may not NULL-terminate the string. Check buffer boundaries if accessing the buffer in a loop and make sure there is no danger of writing past the allocated space. If necessary, truncate all input strings to a reasonable length before passing them to the copy and concatenation functions.::PHASE:Operation:STRATEGY:Environment Hardening:DESCRIPTION:Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code. Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64].:EFFECTIVENESS:Defense in Depth::PHASE:Operation:STRATEGY:Environment Hardening:DESCRIPTION:Use a CPU and operating system that offers Data Execution Protection (NX) or its equivalent [REF-60] [REF-61].:EFFECTIVENESS:Defense in Depth::PHASE:Implementation:DESCRIPTION:Replace unbounded copy functions with analogous functions that support length arguments, such as strcpy with strncpy. Create these if they are not available.:EFFECTIVENESS:Moderate::","::REFERENCE:CVE-2021-22991:DESCRIPTION:Incorrect URI normalization in application traffic product leads to buffer overflow, as exploited in the wild per CISA KEV.:LINK:https://www.cve.org/CVERecord?id=CVE-2021-22991::REFERENCE:CVE-2020-29557:DESCRIPTION:Buffer overflow in Wi-Fi router web interface, as exploited in the wild per CISA KEV.:LINK:https://www.cve.org/CVERecord?id=CVE-2020-29557::REFERENCE:CVE-2009-2550:DESCRIPTION:Classic stack-based buffer overflow in media player using a long entry in a playlist:LINK:https://www.cve.org/CVERecord?id=CVE-2009-2550::REFERENCE:CVE-2009-2403:DESCRIPTION:Heap-based buffer overflow in media player using a long entry in a playlist:LINK:https://www.cve.org/CVERecord?id=CVE-2009-2403::REFERENCE:CVE-2009-0689:DESCRIPTION:large precision value in a format string triggers overflow:LINK:https://www.cve.org/CVERecord?id=CVE-2009-0689::REFERENCE:CVE-2009-0690:DESCRIPTION:negative offset value leads to out-of-bounds read:LINK:https://www.cve.org/CVERecord?id=CVE-2009-0690::REFERENCE:CVE-2009-1532:DESCRIPTION:malformed inputs cause accesses of uninitialized or previously-deleted objects, leading to memory corruption:LINK:https://www.cve.org/CVERecord?id=CVE-2009-1532::REFERENCE:CVE-2009-1528:DESCRIPTION:chain: lack of synchronization leads to memory corruption:LINK:https://www.cve.org/CVERecord?id=CVE-2009-1528::REFERENCE:CVE-2021-29529:DESCRIPTION:Chain: machine-learning product can have a heap-based buffer overflow (CWE-122) when some integer-oriented bounds are calculated by using ceiling() and floor() on floating point values (CWE-1339):LINK:https://www.cve.org/CVERecord?id=CVE-2021-29529::REFERENCE:CVE-2009-0558:DESCRIPTION:attacker-controlled array index leads to code execution:LINK:https://www.cve.org/CVERecord?id=CVE-2009-0558::REFERENCE:CVE-2009-0269:DESCRIPTION:chain: -1 value from a function call was intended to indicate an error, but is used as an array index instead.:LINK:https://www.cve.org/CVERecord?id=CVE-2009-0269::REFERENCE:CVE-2009-0566:DESCRIPTION:chain: incorrect calculations lead to incorrect pointer dereference and memory corruption:LINK:https://www.cve.org/CVERecord?id=CVE-2009-0566::REFERENCE:CVE-2009-1350:DESCRIPTION:product accepts crafted messages that lead to a dereference of an arbitrary pointer:LINK:https://www.cve.org/CVERecord?id=CVE-2009-1350::REFERENCE:CVE-2009-0191:DESCRIPTION:chain: malformed input causes dereference of uninitialized memory:LINK:https://www.cve.org/CVERecord?id=CVE-2009-0191::REFERENCE:CVE-2008-4113:DESCRIPTION:OS kernel trusts userland-supplied length value, allowing reading of sensitive information:LINK:https://www.cve.org/CVERecord?id=CVE-2008-4113::REFERENCE:CVE-2005-1513:DESCRIPTION:Chain: integer overflow in securely-coded mail program leads to buffer overflow. In 2005, this was regarded as unrealistic to exploit, but in 2020, it was rediscovered to be easier to exploit due to evolutions of the technology.:LINK:https://www.cve.org/CVERecord?id=CVE-2005-1513::REFERENCE:CVE-2003-0542:DESCRIPTION:buffer overflow involving a regular expression with a large number of captures:LINK:https://www.cve.org/CVERecord?id=CVE-2003-0542::REFERENCE:CVE-2017-1000121:DESCRIPTION:chain: unchecked message size metadata allows integer overflow (CWE-190) leading to buffer overflow (CWE-119).:LINK:https://www.cve.org/CVERecord?id=CVE-2017-1000121::",,::Memory::,"::TAXONOMY NAME:OWASP Top Ten 2004:ENTRY ID:A5:ENTRY NAME:Buffer Overflows:MAPPING FIT:Exact::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:ARR00-C:ENTRY NAME:Understand how arrays work::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:ARR30-C:ENTRY NAME:Do not form or use out-of-bounds pointers or array subscripts:MAPPING FIT:CWE More Abstract::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:ARR38-C:ENTRY NAME:Guarantee that library functions do not form invalid pointers:MAPPING FIT:CWE More Abstract::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:ENV01-C:ENTRY NAME:Do not make assumptions about the size of an environment variable::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:EXP39-C:ENTRY NAME:Do not access a variable through a pointer of an incompatible type:MAPPING FIT:Imprecise::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:FIO37-C:ENTRY NAME:Do not assume character data has been read::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:STR31-C:ENTRY NAME:Guarantee that storage for strings has sufficient space for character data and the null terminator:MAPPING FIT:CWE More Abstract::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:STR32-C:ENTRY NAME:Do not pass a non-null-terminated character sequence to a library function that expects a string:MAPPING FIT:CWE More Abstract::TAXONOMY NAME:WASC:ENTRY ID:7:ENTRY NAME:Buffer Overflow::TAXONOMY NAME:Software Fault Patterns:ENTRY ID:SFP8:ENTRY NAME:Faulty Buffer Access::",::10::100::123::14::24::42::44::45::46::47::8::9::,"::TYPE:Applicable Platform:NOTE:It is possible in any programming languages without memory management support to attempt an operation outside of the bounds of a memory buffer, but the consequences will vary widely depending on the language, platform, and chip architecture.::",
120,"Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')",Base,Incomplete,"The product copies an input buffer to an output buffer without verifying that the size of the input buffer is less than the size of the output buffer, leading to a buffer overflow.","A buffer overflow condition exists when a product attempts to put more data in a buffer than it can hold, or when it attempts to put data in a memory area outside of the boundaries of a buffer. The simplest type of error, and the most common cause of buffer overflows, is the classic case in which the product copies the buffer without restricting how much is copied. Other variants exist, but the existence of a classic overflow strongly suggests that the programmer is not considering even the most basic of security protections.",::NATURE:ChildOf:CWE ID:119:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:119:VIEW ID:1003:ORDINAL:Primary::NATURE:ChildOf:CWE ID:119:VIEW ID:1305:ORDINAL:Primary::NATURE:ChildOf:CWE ID:119:VIEW ID:1340:ORDINAL:Primary::NATURE:CanPrecede:CWE ID:123:VIEW ID:1000::NATURE:ChildOf:CWE ID:20:VIEW ID:700:ORDINAL:Primary::,"::ORDINALITY:Resultant::ORDINALITY:Primary::",::LANGUAGE NAME:C:LANGUAGE PREVALENCE:Undetermined::LANGUAGE NAME:C++:LANGUAGE PREVALENCE:Undetermined::LANGUAGE CLASS:Assembly:LANGUAGE PREVALENCE:Undetermined::,"","::TERM:Classic Buffer Overflow:DESCRIPTION:This term was frequently used by vulnerability researchers during approximately 1995 to 2005 to differentiate buffer copies without length checks (which had been known about for decades) from other emerging weaknesses that still involved invalid accesses of buffers, as vulnerability researchers began to develop advanced exploitation techniques.::TERM:Unbounded Transfer::","::PHASE:Implementation::","",,"::SCOPE:Integrity:SCOPE:Confidentiality:SCOPE:Availability:IMPACT:Modify Memory:IMPACT:Execute Unauthorized Code or Commands:NOTE:Buffer overflows often can be used to execute arbitrary code, which is usually outside the scope of the product's implicit security policy. This can often be used to subvert any other security service.::SCOPE:Availability:IMPACT:Modify Memory:IMPACT:DoS: Crash, Exit, or Restart:IMPACT:DoS: Resource Consumption (CPU):NOTE:Buffer overflows generally lead to crashes. Other attacks leading to lack of availability are possible, including putting the product into an infinite loop.::","::METHOD:Automated Static Analysis:DESCRIPTION:This weakness can often be detected using automated static analysis tools. Many modern tools use data flow analysis or constraint-based techniques to minimize the number of false positives. Automated static analysis generally does not account for environmental considerations when reporting out-of-bounds memory operations. This can make it difficult for users to determine which warnings should be investigated first. For example, an analysis tool might report buffer overflows that originate from command line arguments in a program that is not expected to run with setuid or other special privileges.:EFFECTIVENESS:High::METHOD:Automated Dynamic Analysis:DESCRIPTION:This weakness can be detected using dynamic tools and techniques that interact with the software using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The software's operation may slow down, but it should not become unstable, crash, or generate incorrect results.::METHOD:Manual Analysis:DESCRIPTION:Manual analysis can be useful for finding this weakness, but it might not achieve desired code coverage within limited time constraints. This becomes difficult for weaknesses that must be considered for all inputs, since the attack surface can be too large.::METHOD:Automated Static Analysis - Binary or Bytecode:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Bytecode Weakness Analysis - including disassembler + source code weakness analysis Binary Weakness Analysis - including disassembler + source code weakness analysis:EFFECTIVENESS:High::METHOD:Manual Static Analysis - Binary or Bytecode:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Binary / Bytecode disassembler - then use manual analysis for vulnerabilities & anomalies:EFFECTIVENESS:SOAR Partial::METHOD:Dynamic Analysis with Automated Results Interpretation:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Web Application Scanner Web Services Scanner Database Scanners:EFFECTIVENESS:SOAR Partial::METHOD:Dynamic Analysis with Manual Results Interpretation:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Fuzz Tester Framework-based Fuzzer:EFFECTIVENESS:SOAR Partial::METHOD:Manual Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Focused Manual Spotcheck - Focused manual analysis of source Manual Source Code Review (not inspections):EFFECTIVENESS:SOAR Partial::METHOD:Automated Static Analysis - Source Code:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Source code Weakness Analyzer Context-configured Source Code Weakness Analyzer:EFFECTIVENESS:High::METHOD:Architecture or Design Review:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Formal Methods / Correct-By-Construction Cost effective for partial coverage: Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.):EFFECTIVENESS:High::","::PHASE:Requirements:STRATEGY:Language Selection:DESCRIPTION:Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. For example, many languages that perform their own memory management, such as Java and Perl, are not subject to buffer overflows. Other languages, such as Ada and C#, typically provide overflow protection, but the protection can be disabled by the programmer. Be wary that a language's interface to native code may still be subject to overflows, even if the language itself is theoretically safe.::PHASE:Architecture and Design:STRATEGY:Libraries or Frameworks:DESCRIPTION:Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. Examples include the Safe C String Library (SafeStr) by Messier and Viega [REF-57], and the Strsafe.h library from Microsoft [REF-56]. These libraries provide safer versions of overflow-prone string-handling functions.::PHASE:Build and Compilation:STRATEGY:Compilation or Build Hardening:DESCRIPTION:Run or compile the software using features or extensions that automatically provide a protection mechanism that mitigates or eliminates buffer overflows. For example, certain compilers and extensions provide automatic buffer overflow detection mechanisms that are built into the compiled code. Examples include the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice.:EFFECTIVENESS:Defense in Depth::PHASE:Implementation:DESCRIPTION:Consider adhering to the following rules when allocating and managing an application's memory: Double check that your buffer is as large as you specify. When using functions that accept a number of bytes to copy, such as strncpy(), be aware that if the destination buffer size is equal to the source buffer size, it may not NULL-terminate the string. Check buffer boundaries if accessing the buffer in a loop and make sure there is no danger of writing past the allocated space. If necessary, truncate all input strings to a reasonable length before passing them to the copy and concatenation functions.::PHASE:Implementation:STRATEGY:Input Validation:DESCRIPTION:Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.::PHASE:Architecture and Design:DESCRIPTION:For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.::PHASE:Operation:STRATEGY:Environment Hardening:DESCRIPTION:Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code. Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64].:EFFECTIVENESS:Defense in Depth::PHASE:Operation:STRATEGY:Environment Hardening:DESCRIPTION:Use a CPU and operating system that offers Data Execution Protection (NX) or its equivalent [REF-60] [REF-61].:EFFECTIVENESS:Defense in Depth::PHASE:Build and Compilation Operation:DESCRIPTION:Most mitigating technologies at the compiler or OS level to date address only a subset of buffer overflow problems and rarely provide complete protection against even that subset. It is good practice to implement strategies to increase the workload of an attacker, such as leaving the attacker to guess an unknown value that changes every program execution.::PHASE:Implementation:DESCRIPTION:Replace unbounded copy functions with analogous functions that support length arguments, such as strcpy with strncpy. Create these if they are not available.:EFFECTIVENESS:Moderate::PHASE:Architecture and Design:STRATEGY:Enforcement by Conversion:DESCRIPTION:When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.::PHASE:Architecture and Design Operation:STRATEGY:Environment Hardening:DESCRIPTION:Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.::PHASE:Architecture and Design Operation:STRATEGY:Sandbox or Jail:DESCRIPTION:Run the code in a jail or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software. OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations. This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise. Be careful to avoid CWE-243 and other weaknesses related to jails.:EFFECTIVENESS:Limited::","::REFERENCE:CVE-2000-1094:DESCRIPTION:buffer overflow using command with long argument:LINK:https://www.cve.org/CVERecord?id=CVE-2000-1094::REFERENCE:CVE-1999-0046:DESCRIPTION:buffer overflow in local program using long environment variable:LINK:https://www.cve.org/CVERecord?id=CVE-1999-0046::REFERENCE:CVE-2002-1337:DESCRIPTION:buffer overflow in comment characters, when product increments a counter for a > but does not decrement for <:LINK:https://www.cve.org/CVERecord?id=CVE-2002-1337::REFERENCE:CVE-2003-0595:DESCRIPTION:By replacing a valid cookie value with an extremely long string of characters, an attacker may overflow the application's buffers.:LINK:https://www.cve.org/CVERecord?id=CVE-2003-0595::REFERENCE:CVE-2001-0191:DESCRIPTION:By replacing a valid cookie value with an extremely long string of characters, an attacker may overflow the application's buffers.:LINK:https://www.cve.org/CVERecord?id=CVE-2001-0191::",::Memory Management::,::Memory::,"::TAXONOMY NAME:PLOVER:ENTRY NAME:Unbounded Transfer ('classic overflow')::TAXONOMY NAME:7 Pernicious Kingdoms:ENTRY NAME:Buffer Overflow::TAXONOMY NAME:CLASP:ENTRY NAME:Buffer overflow::TAXONOMY NAME:OWASP Top Ten 2004:ENTRY ID:A1:ENTRY NAME:Unvalidated Input:MAPPING FIT:CWE More Specific::TAXONOMY NAME:OWASP Top Ten 2004:ENTRY ID:A5:ENTRY NAME:Buffer Overflows:MAPPING FIT:CWE More Specific::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:STR31-C:ENTRY NAME:Guarantee that storage for strings has sufficient space for character data and the null terminator:MAPPING FIT:Exact::TAXONOMY NAME:WASC:ENTRY ID:7:ENTRY NAME:Buffer Overflow::TAXONOMY NAME:Software Fault Patterns:ENTRY ID:SFP8:ENTRY NAME:Faulty Buffer Access::TAXONOMY NAME:OMG ASCSM:ENTRY ID:ASCSM-CWE-120::TAXONOMY NAME:OMG ASCRM:ENTRY ID:ASCRM-CWE-120::",::10::100::14::24::42::44::45::46::47::67::8::9::92::,"::TYPE:Relationship:NOTE:At the code level, stack-based and heap-based overflows do not differ significantly, so there usually is not a need to distinguish them. From the attacker perspective, they can be quite different, since different techniques are required to exploit them.::TYPE:Terminology:NOTE:Many issues that are now called buffer overflows are substantively different than the classic overflow, including entirely different bug types that rely on overflow exploit techniques, such as integer signedness errors, integer overflows, and format string bugs. This imprecise terminology can make it difficult to determine which variant is being reported.::",
121,"Stack-based Buffer Overflow",Variant,Draft,"A stack-based buffer overflow condition is a condition where the buffer being overwritten is allocated on the stack (i.e., is a local variable or, rarely, a parameter to a function).","",::NATURE:ChildOf:CWE ID:788:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:787:VIEW ID:1000::,"::ORDINALITY:Primary::",::LANGUAGE NAME:C:LANGUAGE PREVALENCE:Undetermined::LANGUAGE NAME:C++:LANGUAGE PREVALENCE:Undetermined::,"::There are generally several security-critical data on an execution stack that can lead to arbitrary code execution. The most prominent is the stored return address, the memory address at which execution should continue once the current function is finished executing. The attacker can overwrite this value with some memory address to which the attacker also has write access, into which they place arbitrary code to be run with the full privileges of the vulnerable program. Alternately, the attacker can supply the address of an important call, for instance the POSIX system() call, leaving arguments to the call on the stack. This is often called a return into libc exploit, since the attacker generally forces the program to jump at return time into an interesting routine in the C standard library (libc). Other important data commonly on the stack include the stack pointer and frame pointer, two values that indicate offsets for computing memory addresses. Modifying those values can often be leveraged into a write-what-where condition.::","::TERM:Stack Overflow:DESCRIPTION:Stack Overflow is often used to mean the same thing as stack-based buffer overflow, however it is also used on occasion to mean stack exhaustion, usually a result from an excessively recursive function call. Due to the ambiguity of the term, use of stack overflow to describe either circumstance is discouraged.::","::PHASE:Architecture and Design::PHASE:Implementation::","",,"::SCOPE:Availability:IMPACT:Modify Memory:IMPACT:DoS: Crash, Exit, or Restart:IMPACT:DoS: Resource Consumption (CPU):IMPACT:DoS: Resource Consumption (Memory):NOTE:Buffer overflows generally lead to crashes. Other attacks leading to lack of availability are possible, including putting the program into an infinite loop.::SCOPE:Integrity:SCOPE:Confidentiality:SCOPE:Availability:SCOPE:Access Control:IMPACT:Modify Memory:IMPACT:Execute Unauthorized Code or Commands:IMPACT:Bypass Protection Mechanism:NOTE:Buffer overflows often can be used to execute arbitrary code, which is usually outside the scope of a program's implicit security policy.::SCOPE:Integrity:SCOPE:Confidentiality:SCOPE:Availability:SCOPE:Access Control:SCOPE:Other:IMPACT:Modify Memory:IMPACT:Execute Unauthorized Code or Commands:IMPACT:Bypass Protection Mechanism:IMPACT:Other:NOTE:When the consequence is arbitrary code execution, this can often be used to subvert any other security service.::","","::PHASE:Build and Compilation:STRATEGY:Compilation or Build Hardening:DESCRIPTION:Run or compile the software using features or extensions that automatically provide a protection mechanism that mitigates or eliminates buffer overflows. For example, certain compilers and extensions provide automatic buffer overflow detection mechanisms that are built into the compiled code. Examples include the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice.:EFFECTIVENESS:Defense in Depth::PHASE:Architecture and Design:DESCRIPTION:Use an abstraction library to abstract away risky APIs. Not a complete solution.::PHASE:Build and Compilation:DESCRIPTION:Compiler-based canary mechanisms such as StackGuard, ProPolice and the Microsoft Visual Studio /GS flag. Unless this provides automatic bounds checking, it is not a complete solution.::PHASE:Implementation:DESCRIPTION:Implement and perform bounds checking on input.::PHASE:Implementation:DESCRIPTION:Do not use dangerous functions such as gets. Use safer, equivalent functions which check for boundary errors.::PHASE:Operation:DESCRIPTION:Use OS-level preventative functionality, such as ASLR. This is not a complete solution.::","::REFERENCE:CVE-2021-35395:DESCRIPTION:Stack-based buffer overflows in SFK for wifi chipset used for IoT/embedded devices, as exploited in the wild per CISA KEV.:LINK:https://www.cve.org/CVERecord?id=CVE-2021-35395::",,,"::TAXONOMY NAME:CLASP:ENTRY NAME:Stack overflow::TAXONOMY NAME:Software Fault Patterns:ENTRY ID:SFP8:ENTRY NAME:Faulty Buffer Access::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:ARR38-C:ENTRY NAME:Guarantee that library functions do not form invalid pointers:MAPPING FIT:Imprecise::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:STR31-C:ENTRY NAME:Guarantee that storage for strings has sufficient space for character data and the null terminator:MAPPING FIT:CWE More Specific::",,"::TYPE:Other:NOTE:Stack-based buffer overflows can instantiate in return address overwrites, stack pointer overwrites or frame pointer overwrites. They can also be considered function pointer overwrites, array indexer overwrites or write-what-where condition, etc.::",
122,"Heap-based Buffer Overflow",Variant,Draft,"A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().","",::NATURE:ChildOf:CWE ID:788:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:787:VIEW ID:1000::,"::ORDINALITY:Primary::",::LANGUAGE NAME:C:LANGUAGE PREVALENCE:Undetermined::LANGUAGE NAME:C++:LANGUAGE PREVALENCE:Undetermined::,"","","::PHASE:Architecture and Design::PHASE:Implementation::","",,"::SCOPE:Availability:IMPACT:DoS: Crash, Exit, or Restart:IMPACT:DoS: Resource Consumption (CPU):IMPACT:DoS: Resource Consumption (Memory):NOTE:Buffer overflows generally lead to crashes. Other attacks leading to lack of availability are possible, including putting the program into an infinite loop.::SCOPE:Integrity:SCOPE:Confidentiality:SCOPE:Availability:SCOPE:Access Control:IMPACT:Execute Unauthorized Code or Commands:IMPACT:Bypass Protection Mechanism:IMPACT:Modify Memory:NOTE:Buffer overflows often can be used to execute arbitrary code, which is usually outside the scope of a program's implicit security policy. Besides important user data, heap-based overflows can be used to overwrite function pointers that may be living in memory, pointing it to the attacker's code. Even in applications that do not explicitly use function pointers, the run-time will usually leave many in memory. For example, object methods in C++ are generally implemented using function pointers. Even in C programs, there is often a global offset table used by the underlying runtime.::SCOPE:Integrity:SCOPE:Confidentiality:SCOPE:Availability:SCOPE:Access Control:SCOPE:Other:IMPACT:Execute Unauthorized Code or Commands:IMPACT:Bypass Protection Mechanism:IMPACT:Other:NOTE:When the consequence is arbitrary code execution, this can often be used to subvert any other security service.::","","::PHASE::DESCRIPTION:Pre-design: Use a language or compiler that performs automatic bounds checking.::PHASE:Architecture and Design:DESCRIPTION:Use an abstraction library to abstract away risky APIs. Not a complete solution.::PHASE:Build and Compilation:DESCRIPTION:Pre-design through Build: Canary style bounds checking, library changes which ensure the validity of chunk data, and other such fixes are possible, but should not be relied upon.::PHASE:Implementation:DESCRIPTION:Implement and perform bounds checking on input.::PHASE:Implementation:STRATEGY:Libraries or Frameworks:DESCRIPTION:Do not use dangerous functions such as gets. Look for their safe equivalent, which checks for the boundary.::PHASE:Operation:DESCRIPTION:Use OS-level preventative functionality. This is not a complete solution, but it provides some defense in depth.::","::REFERENCE:CVE-2007-4268:DESCRIPTION:Chain: integer signedness error (CWE-195) passes signed comparison, leading to heap overflow (CWE-122):LINK:https://www.cve.org/CVERecord?id=CVE-2007-4268::REFERENCE:CVE-2009-2523:DESCRIPTION:Chain: product does not handle when an input string is not NULL terminated (CWE-170), leading to buffer over-read (CWE-125) or heap-based buffer overflow (CWE-122).:LINK:https://www.cve.org/CVERecord?id=CVE-2009-2523::REFERENCE:CVE-2021-29529:DESCRIPTION:Chain: machine-learning product can have a heap-based buffer overflow (CWE-122) when some integer-oriented bounds are calculated by using ceiling() and floor() on floating point values (CWE-1339):LINK:https://www.cve.org/CVERecord?id=CVE-2021-29529::",,::Memory::,"::TAXONOMY NAME:CLASP:ENTRY NAME:Heap overflow::TAXONOMY NAME:Software Fault Patterns:ENTRY ID:SFP8:ENTRY NAME:Faulty Buffer Access::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:STR31-C:ENTRY NAME:Guarantee that storage for strings has sufficient space for character data and the null terminator:MAPPING FIT:CWE More Specific::",::92::,"::TYPE:Relationship:NOTE:Heap-based buffer overflows are usually just as dangerous as stack-based buffer overflows.::",
123,"Write-what-where Condition",Base,Draft,"Any condition where the attacker has the ability to write an arbitrary value to an arbitrary location, often as the result of a buffer overflow.","",::NATURE:ChildOf:CWE ID:787:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:119:VIEW ID:1305:ORDINAL:Primary::NATURE:ChildOf:CWE ID:119:VIEW ID:1340:ORDINAL:Primary::,"::ORDINALITY:Resultant::",::LANGUAGE NAME:C:LANGUAGE PREVALENCE:Undetermined::LANGUAGE NAME:C++:LANGUAGE PREVALENCE:Undetermined::,"","","::PHASE:Implementation::","",,"::SCOPE:Integrity:SCOPE:Confidentiality:SCOPE:Availability:SCOPE:Access Control:IMPACT:Modify Memory:IMPACT:Execute Unauthorized Code or Commands:IMPACT:Gain Privileges or Assume Identity:IMPACT:DoS: Crash, Exit, or Restart:IMPACT:Bypass Protection Mechanism:NOTE:Clearly, write-what-where conditions can be used to write data to areas of memory outside the scope of a policy. Also, they almost invariably can be used to execute arbitrary code, which is usually outside the scope of a program's implicit security policy. If the attacker can overwrite a pointer's worth of memory (usually 32 or 64 bits), they can redirect a function pointer to their own malicious code. Even when the attacker can only modify a single byte arbitrary code execution can be possible. Sometimes this is because the same problem can be exploited repeatedly to the same effect. Other times it is because the attacker can overwrite security-critical application-specific data -- such as a flag indicating whether the user is an administrator.::SCOPE:Integrity:SCOPE:Availability:IMPACT:DoS: Crash, Exit, or Restart:IMPACT:Modify Memory:NOTE:Many memory accesses can lead to program termination, such as when writing to addresses that are invalid for the current process.::SCOPE:Access Control:SCOPE:Other:IMPACT:Bypass Protection Mechanism:IMPACT:Other:NOTE:When the consequence is arbitrary code execution, this can often be used to subvert any other security service.::","","::PHASE:Architecture and Design:STRATEGY:Language Selection:DESCRIPTION:Use a language that provides appropriate memory abstractions.::PHASE:Operation:DESCRIPTION:Use OS-level preventative functionality integrated after the fact. Not a complete solution.::","",,,"::TAXONOMY NAME:CLASP:ENTRY NAME:Write-what-where condition::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:ARR30-C:ENTRY NAME:Do not form or use out-of-bounds pointers or array subscripts:MAPPING FIT:Imprecise::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:ARR38-C:ENTRY NAME:Guarantee that library functions do not form invalid pointers:MAPPING FIT:Imprecise::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:STR31-C:ENTRY NAME:Guarantee that storage for strings has sufficient space for character data and the null terminator:MAPPING FIT:Imprecise::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:STR32-C:ENTRY NAME:Do not pass a non-null-terminated character sequence to a library function that expects a string:MAPPING FIT:Imprecise::TAXONOMY NAME:Software Fault Patterns:ENTRY ID:SFP8:ENTRY NAME:Faulty Buffer Access::",,"",
124,"Buffer Underwrite ('Buffer Underflow')",Base,Incomplete,"The product writes to a buffer using an index or pointer that references a memory location prior to the beginning of the buffer.","This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.",::NATURE:ChildOf:CWE ID:786:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:787:VIEW ID:1000::,"::ORDINALITY:Primary::",::LANGUAGE NAME:C:LANGUAGE PREVALENCE:Undetermined::LANGUAGE NAME:C++:LANGUAGE PREVALENCE:Undetermined::,"","::TERM:buffer underrun:DESCRIPTION:Some prominent vendors and researchers use the term buffer underrun. Buffer underflow is more commonly used, although both terms are also sometimes used to describe a buffer under-read (CWE-127).::","::PHASE:Architecture and Design::PHASE:Implementation::","",,"::SCOPE:Integrity:SCOPE:Availability:IMPACT:Modify Memory:IMPACT:DoS: Crash, Exit, or Restart:NOTE:Out of bounds memory access will very likely result in the corruption of relevant memory, and perhaps instructions, possibly leading to a crash.::SCOPE:Integrity:SCOPE:Confidentiality:SCOPE:Availability:SCOPE:Access Control:SCOPE:Other:IMPACT:Execute Unauthorized Code or Commands:IMPACT:Modify Memory:IMPACT:Bypass Protection Mechanism:IMPACT:Other:NOTE:If the corrupted memory can be effectively controlled, it may be possible to execute arbitrary code. If the corrupted memory is data rather than instructions, the system will continue to function with improper changes, possibly in violation of an implicit or explicit policy. The consequences would only be limited by how the affected data is used, such as an adjacent memory location that is used to specify whether the user has special privileges.::SCOPE:Access Control:SCOPE:Other:IMPACT:Bypass Protection Mechanism:IMPACT:Other:NOTE:When the consequence is arbitrary code execution, this can often be used to subvert any other security service.::","","::PHASE:Requirements:DESCRIPTION:Choose a language that is not susceptible to these issues.::PHASE:Implementation:DESCRIPTION:All calculated values that are used as index or for pointer arithmetic should be validated to ensure that they are within an expected range.::","::REFERENCE:CVE-2021-24018:DESCRIPTION:buffer underwrite in firmware verification routine allows code execution via a crafted firmware image:LINK:https://www.cve.org/CVERecord?id=CVE-2021-24018::REFERENCE:CVE-2002-2227:DESCRIPTION:Unchecked length of SSLv2 challenge value leads to buffer underflow.:LINK:https://www.cve.org/CVERecord?id=CVE-2002-2227::REFERENCE:CVE-2007-4580:DESCRIPTION:Buffer underflow from a small size value with a large buffer (length parameter inconsistency, CWE-130):LINK:https://www.cve.org/CVERecord?id=CVE-2007-4580::REFERENCE:CVE-2007-1584:DESCRIPTION:Buffer underflow from an all-whitespace string, which causes a counter to be decremented before the buffer while looking for a non-whitespace character.:LINK:https://www.cve.org/CVERecord?id=CVE-2007-1584::REFERENCE:CVE-2007-0886:DESCRIPTION:Buffer underflow resultant from encoded data that triggers an integer overflow.:LINK:https://www.cve.org/CVERecord?id=CVE-2007-0886::REFERENCE:CVE-2006-6171:DESCRIPTION:Product sets an incorrect buffer size limit, leading to off-by-two buffer underflow.:LINK:https://www.cve.org/CVERecord?id=CVE-2006-6171::REFERENCE:CVE-2006-4024:DESCRIPTION:Negative value is used in a memcpy() operation, leading to buffer underflow.:LINK:https://www.cve.org/CVERecord?id=CVE-2006-4024::REFERENCE:CVE-2004-2620:DESCRIPTION:Buffer underflow due to mishandled special characters:LINK:https://www.cve.org/CVERecord?id=CVE-2004-2620::",,,"::TAXONOMY NAME:PLOVER:ENTRY NAME:UNDER - Boundary beginning violation ('buffer underflow'?)::TAXONOMY NAME:CLASP:ENTRY NAME:Buffer underwrite::TAXONOMY NAME:Software Fault Patterns:ENTRY ID:SFP8:ENTRY NAME:Faulty Buffer Access::",,"::TYPE:Relationship:NOTE:This could be resultant from several errors, including a bad offset or an array index that decrements before the beginning of the buffer (see CWE-129).::",
125,"Out-of-bounds Read",Base,Draft,"The product reads data past the end, or before the beginning, of the intended buffer.","Typically, this can allow attackers to read sensitive information from other memory locations or cause a crash. A crash can occur when the code reads a variable amount of data and assumes that a sentinel exists to stop the read operation, such as a NUL in a string. The expected sentinel might not be located in the out-of-bounds memory, causing excessive data to be read, leading to a segmentation fault or a buffer overflow. The product may modify an index or perform pointer arithmetic that references a memory location that is outside of the boundaries of the buffer. A subsequent read operation then produces undefined or unexpected results.",::NATURE:ChildOf:CWE ID:119:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:119:VIEW ID:1003:ORDINAL:Primary::NATURE:ChildOf:CWE ID:119:VIEW ID:1305:ORDINAL:Primary::NATURE:ChildOf:CWE ID:119:VIEW ID:1340:ORDINAL:Primary::,"::ORDINALITY:Primary::",::LANGUAGE NAME:C:LANGUAGE PREVALENCE:Undetermined::LANGUAGE NAME:C++:LANGUAGE PREVALENCE:Undetermined::TECHNOLOGY CLASS:ICS/OT:TECHNOLOGY PREVALENCE:Often::,"","","::PHASE:Implementation::","",,"::SCOPE:Confidentiality:IMPACT:Read Memory::SCOPE:Confidentiality:IMPACT:Bypass Protection Mechanism:NOTE:By reading out-of-bounds memory, an attacker might be able to get secret values, such as memory addresses, which can be bypass protection mechanisms such as ASLR in order to improve the reliability and likelihood of exploiting a separate weakness to achieve code execution instead of just denial of service.::","","::PHASE:Implementation:STRATEGY:Input Validation:DESCRIPTION:Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright. To reduce the likelihood of introducing an out-of-bounds read, ensure that you validate and ensure correct calculations for any length argument, buffer size calculation, or offset. Be especially careful of relying on a sentinel (i.e. special character such as NUL) in untrusted inputs.::PHASE:Architecture and Design:STRATEGY:Language Selection:DESCRIPTION:Use a language that provides appropriate memory abstractions.::","::REFERENCE:CVE-2020-11899:DESCRIPTION:Out-of-bounds read in IP stack used in embedded systems, as exploited in the wild per CISA KEV.:LINK:https://www.cve.org/CVERecord?id=CVE-2020-11899::REFERENCE:CVE-2014-0160:DESCRIPTION:Chain: Heartbleed bug receives an inconsistent length parameter (CWE-130) enabling an out-of-bounds read (CWE-126), returning memory that could include private cryptographic keys and other sensitive data.:LINK:https://www.cve.org/CVERecord?id=CVE-2014-0160::REFERENCE:CVE-2018-10887:DESCRIPTION:Chain: unexpected sign extension (CWE-194) leads to integer overflow (CWE-190), causing an out-of-bounds read (CWE-125):LINK:https://www.cve.org/CVERecord?id=CVE-2018-10887::REFERENCE:CVE-2009-2523:DESCRIPTION:Chain: product does not handle when an input string is not NULL terminated (CWE-170), leading to buffer over-read (CWE-125) or heap-based buffer overflow (CWE-122).:LINK:https://www.cve.org/CVERecord?id=CVE-2009-2523::REFERENCE:CVE-2018-16069:DESCRIPTION:Chain: series of floating-point precision errors (CWE-1339) in a web browser rendering engine causes out-of-bounds read (CWE-125), giving access to cross-origin data:LINK:https://www.cve.org/CVERecord?id=CVE-2018-16069::REFERENCE:CVE-2004-0112:DESCRIPTION:out-of-bounds read due to improper length check:LINK:https://www.cve.org/CVERecord?id=CVE-2004-0112::REFERENCE:CVE-2004-0183:DESCRIPTION:packet with large number of specified elements cause out-of-bounds read.:LINK:https://www.cve.org/CVERecord?id=CVE-2004-0183::REFERENCE:CVE-2004-0221:DESCRIPTION:packet with large number of specified elements cause out-of-bounds read.:LINK:https://www.cve.org/CVERecord?id=CVE-2004-0221::REFERENCE:CVE-2004-0184:DESCRIPTION:out-of-bounds read, resultant from integer underflow:LINK:https://www.cve.org/CVERecord?id=CVE-2004-0184::REFERENCE:CVE-2004-1940:DESCRIPTION:large length value causes out-of-bounds read:LINK:https://www.cve.org/CVERecord?id=CVE-2004-1940::REFERENCE:CVE-2004-0421:DESCRIPTION:malformed image causes out-of-bounds read:LINK:https://www.cve.org/CVERecord?id=CVE-2004-0421::REFERENCE:CVE-2008-4113:DESCRIPTION:OS kernel trusts userland-supplied length value, allowing reading of sensitive information:LINK:https://www.cve.org/CVERecord?id=CVE-2008-4113::",,,"::TAXONOMY NAME:PLOVER:ENTRY NAME:Out-of-bounds Read::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:ARR30-C:ENTRY NAME:Do not form or use out-of-bounds pointers or array subscripts:MAPPING FIT:Imprecise::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:ARR38-C:ENTRY NAME:Guarantee that library functions do not form invalid pointers:MAPPING FIT:Imprecise::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:EXP39-C:ENTRY NAME:Do not access a variable through a pointer of an incompatible type:MAPPING FIT:Imprecise::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:STR31-C:ENTRY NAME:Guarantee that storage for strings has sufficient space for character data and the null terminator:MAPPING FIT:Imprecise::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:STR32-C:ENTRY NAME:Do not pass a non-null-terminated character sequence to a library function that expects a string:MAPPING FIT:CWE More Abstract::TAXONOMY NAME:Software Fault Patterns:ENTRY ID:SFP8:ENTRY NAME:Faulty Buffer Access::",::540::,"",
126,"Buffer Over-read",Variant,Draft,"The product reads from a buffer using buffer access mechanisms such as indexes or pointers that reference memory locations after the targeted buffer.","This typically occurs when the pointer or its index is incremented to a position beyond the bounds of the buffer or when pointer arithmetic results in a position outside of the valid memory location to name a few. This may result in exposure of sensitive information or possibly a crash.",::NATURE:ChildOf:CWE ID:125:VIEW ID:1000::NATURE:ChildOf:CWE ID:788:VIEW ID:1000:ORDINAL:Primary::,"::ORDINALITY:Primary::",::LANGUAGE NAME:C:LANGUAGE PREVALENCE:Undetermined::LANGUAGE NAME:C++:LANGUAGE PREVALENCE:Undetermined::,"","","::PHASE:Implementation::","",,"::SCOPE:Confidentiality:IMPACT:Read Memory::SCOPE:Confidentiality:IMPACT:Bypass Protection Mechanism:NOTE:By reading out-of-bounds memory, an attacker might be able to get secret values, such as memory addresses, which can be bypass protection mechanisms such as ASLR in order to improve the reliability and likelihood of exploiting a separate weakness to achieve code execution instead of just denial of service.::","","","::REFERENCE:CVE-2014-0160:DESCRIPTION:Chain: Heartbleed bug receives an inconsistent length parameter (CWE-130) enabling an out-of-bounds read (CWE-126), returning memory that could include private cryptographic keys and other sensitive data.:LINK:https://www.cve.org/CVERecord?id=CVE-2014-0160::REFERENCE:CVE-2009-2523:DESCRIPTION:Chain: product does not handle when an input string is not NULL terminated, leading to buffer over-read or heap-based buffer overflow.:LINK:https://www.cve.org/CVERecord?id=CVE-2009-2523::",,,"::TAXONOMY NAME:PLOVER:ENTRY NAME:Buffer over-read::TAXONOMY NAME:Software Fault Patterns:ENTRY ID:SFP8:ENTRY NAME:Faulty Buffer Access::",,"::TYPE:Relationship:NOTE:These problems may be resultant from missing sentinel values (CWE-463) or trusting a user-influenced input length variable.::",
127,"Buffer Under-read",Variant,Draft,"The product reads from a buffer using buffer access mechanisms such as indexes or pointers that reference memory locations prior to the targeted buffer.","This typically occurs when the pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used. This may result in exposure of sensitive information or possibly a crash.",::NATURE:ChildOf:CWE ID:125:VIEW ID:1000::NATURE:ChildOf:CWE ID:786:VIEW ID:1000:ORDINAL:Primary::,"::ORDINALITY:Primary::",::LANGUAGE NAME:C:LANGUAGE PREVALENCE:Undetermined::LANGUAGE NAME:C++:LANGUAGE PREVALENCE:Undetermined::,"","","::PHASE:Implementation::","",,"::SCOPE:Confidentiality:IMPACT:Read Memory::SCOPE:Confidentiality:IMPACT:Bypass Protection Mechanism:NOTE:By reading out-of-bounds memory, an attacker might be able to get secret values, such as memory addresses, which can be bypass protection mechanisms such as ASLR in order to improve the reliability and likelihood of exploiting a separate weakness to achieve code execution instead of just denial of service.::","","","",,,"::TAXONOMY NAME:PLOVER:ENTRY NAME:Buffer under-read::TAXONOMY NAME:Software Fault Patterns:ENTRY ID:SFP8:ENTRY NAME:Faulty Buffer Access::",,"::TYPE:Research Gap:NOTE:Under-studied.::",
128,"Wrap-around Error",Base,Incomplete,"Wrap around errors occur whenever a value is incremented past the maximum value for its type and therefore wraps around to a very small, negative, or undefined value.","",::NATURE:ChildOf:CWE ID:682:VIEW ID:1000:ORDINAL:Primary::NATURE:CanPrecede:CWE ID:119:VIEW ID:1000::NATURE:PeerOf:CWE ID:190:VIEW ID:1000::,"::ORDINALITY:Primary::",::LANGUAGE NAME:C:LANGUAGE PREVALENCE:Often::LANGUAGE NAME:C++:LANGUAGE PREVALENCE:Often::,"::Due to how addition is performed by computers, if a primitive is incremented past the maximum value possible for its storage space, the system will not recognize this, and therefore increment each bit as if it still had extra space. Because of how negative numbers are represented in binary, primitives interpreted as signed may wrap to very large negative values.::","","::PHASE:Implementation::","",,"::SCOPE:Availability:IMPACT:DoS: Crash, Exit, or Restart:IMPACT:DoS: Resource Consumption (CPU):IMPACT:DoS: Resource Consumption (Memory):IMPACT:DoS: Instability:NOTE:This weakness will generally lead to undefined behavior and therefore crashes. In the case of overflows involving loop index variables, the likelihood of infinite loops is also high.::SCOPE:Integrity:IMPACT:Modify Memory:NOTE:If the value in question is important to data (as opposed to flow), simple data corruption has occurred. Also, if the wrap around results in other conditions such as buffer overflows, further memory corruption may occur.::SCOPE:Confidentiality:SCOPE:Availability:SCOPE:Access Control:IMPACT:Execute Unauthorized Code or Commands:IMPACT:Bypass Protection Mechanism:NOTE:This weakness can sometimes trigger buffer overflows which can be used to execute arbitrary code. This is usually outside the scope of a program's implicit security policy.::","","::PHASE::DESCRIPTION:Requirements specification: The choice could be made to use a language that is not susceptible to these issues.::PHASE:Architecture and Design:DESCRIPTION:Provide clear upper and lower bounds on the scale of any protocols designed.::PHASE:Implementation:DESCRIPTION:Perform validation on all incremented variables to ensure that they remain within reasonable bounds.::","",,,"::TAXONOMY NAME:CLASP:ENTRY NAME:Wrap-around error::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:MEM07-C:ENTRY NAME:Ensure that the arguments to calloc(), when multiplied, can be represented as a size_t::TAXONOMY NAME:Software Fault Patterns:ENTRY ID:SFP1:ENTRY NAME:Glitch in computation::",::92::,"::TYPE:Relationship:NOTE:The relationship between overflow and wrap-around needs to be examined more closely, since several entries (including CWE-190) are closely related.::",
129,"Improper Validation of Array Index",Variant,Draft,"The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.","",::NATURE:ChildOf:CWE ID:1285:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:20:VIEW ID:1003:ORDINAL:Primary::NATURE:CanPrecede:CWE ID:119:VIEW ID:1000::NATURE:CanPrecede:CWE ID:823:VIEW ID:1000::NATURE:CanPrecede:CWE ID:789:VIEW ID:1000::,"::ORDINALITY:Resultant:DESCRIPTION:The most common condition situation leading to an out-of-bounds array index is the use of loop index variables as buffer indexes. If the end condition for the loop is subject to a flaw, the index can grow or shrink unbounded, therefore causing a buffer overflow or underflow. Another common situation leading to this condition is the use of a function's return value, or the resulting value of a calculation directly as an index in to a buffer.::",::LANGUAGE NAME:C:LANGUAGE PREVALENCE:Often::LANGUAGE NAME:C++:LANGUAGE PREVALENCE:Often::LANGUAGE CLASS:Not Language-Specific:LANGUAGE PREVALENCE:Undetermined::,"","::TERM:out-of-bounds array index::TERM:index-out-of-range::TERM:array index underflow::","::PHASE:Implementation::","",,"::SCOPE:Integrity:SCOPE:Availability:IMPACT:DoS: Crash, Exit, or Restart:NOTE:Use of an index that is outside the bounds of an array will very likely result in the corruption of relevant memory and perhaps instructions, leading to a crash, if the values are outside of the valid memory area.::SCOPE:Integrity:IMPACT:Modify Memory:NOTE:If the memory corrupted is data, rather than instructions, the system will continue to function with improper values.::SCOPE:Confidentiality:SCOPE:Integrity:IMPACT:Modify Memory:IMPACT:Read Memory:NOTE:Use of an index that is outside the bounds of an array can also trigger out-of-bounds read or write operations, or operations on the wrong objects; i.e., buffer overflows are not always the result. This may result in the exposure or modification of sensitive data.::SCOPE:Integrity:SCOPE:Confidentiality:SCOPE:Availability:IMPACT:Execute Unauthorized Code or Commands:NOTE:If the memory accessible by the attacker can be effectively controlled, it may be possible to execute arbitrary code, as with a standard buffer overflow and possibly without the use of large inputs if a precise index can be controlled.::SCOPE:Integrity:SCOPE:Availability:SCOPE:Confidentiality:IMPACT:DoS: Crash, Exit, or Restart:IMPACT:Execute Unauthorized Code or Commands:IMPACT:Read Memory:IMPACT:Modify Memory:NOTE:A single fault could allow either an overflow (CWE-788) or underflow (CWE-786) of the array index. What happens next will depend on the type of operation being performed out of bounds, but can expose sensitive information, cause a system crash, or possibly lead to arbitrary code execution.::","::METHOD:Automated Static Analysis:DESCRIPTION:This weakness can often be detected using automated static analysis tools. Many modern tools use data flow analysis or constraint-based techniques to minimize the number of false positives. Automated static analysis generally does not account for environmental considerations when reporting out-of-bounds memory operations. This can make it difficult for users to determine which warnings should be investigated first. For example, an analysis tool might report array index errors that originate from command line arguments in a program that is not expected to run with setuid or other special privileges.:EFFECTIVENESS:High::METHOD:Automated Dynamic Analysis:DESCRIPTION:This weakness can be detected using dynamic tools and techniques that interact with the software using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The software's operation may slow down, but it should not become unstable, crash, or generate incorrect results.::METHOD:Black Box:DESCRIPTION:Black box methods might not get the needed code coverage within limited time constraints, and a dynamic test might not produce any noticeable side effects even if it is successful.::","::PHASE:Architecture and Design:STRATEGY:Input Validation:DESCRIPTION:Use an input validation framework such as Struts or the OWASP ESAPI Validation API. Note that using a framework does not automatically address all input validation problems; be mindful of weaknesses that could arise from misusing the framework itself (CWE-1173).::PHASE:Architecture and Design:DESCRIPTION:For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server. Even though client-side checks provide minimal benefits with respect to server-side security, they are still useful. First, they can support intrusion detection. If the server receives input that should have been rejected by the client, then it may be an indication of an attack. Second, client-side error-checking can provide helpful feedback to the user about the expectations for valid input. Third, there may be a reduction in server-side processing time for accidental input errors, although this is typically a small savings.::PHASE:Requirements:STRATEGY:Language Selection:DESCRIPTION:Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. For example, Ada allows the programmer to constrain the values of a variable and languages such as Java and Ruby will allow the programmer to handle exceptions when an out-of-bounds index is accessed.::PHASE:Operation:STRATEGY:Environment Hardening:DESCRIPTION:Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code. Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64].:EFFECTIVENESS:Defense in Depth::PHASE:Operation:STRATEGY:Environment Hardening:DESCRIPTION:Use a CPU and operating system that offers Data Execution Protection (NX) or its equivalent [REF-60] [REF-61].:EFFECTIVENESS:Defense in Depth::PHASE:Implementation:STRATEGY:Input Validation:DESCRIPTION:Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright. When accessing a user-controlled array index, use a stringent range of values that are within the target array. Make sure that you do not allow negative values to be used. That is, verify the minimum as well as the maximum of the range of acceptable values.::PHASE:Implementation:DESCRIPTION:Be especially careful to validate all input when invoking code that crosses language boundaries, such as from an interpreted language to native code. This could create an unexpected interaction between the language boundaries. Ensure that you are not violating any of the expectations of the language with which you are interfacing. For example, even though Java may not be susceptible to buffer overflows, providing a large argument in a call to native code might trigger an overflow.::PHASE:Architecture and Design Operation:STRATEGY:Environment Hardening:DESCRIPTION:Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.::PHASE:Architecture and Design Operation:STRATEGY:Sandbox or Jail:DESCRIPTION:Run the code in a jail or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software. OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations. This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise. Be careful to avoid CWE-243 and other weaknesses related to jails.:EFFECTIVENESS:Limited::","::REFERENCE:CVE-2005-0369:DESCRIPTION:large ID in packet used as array index:LINK:https://www.cve.org/CVERecord?id=CVE-2005-0369::REFERENCE:CVE-2001-1009:DESCRIPTION:negative array index as argument to POP LIST command:LINK:https://www.cve.org/CVERecord?id=CVE-2001-1009::REFERENCE:CVE-2003-0721:DESCRIPTION:Integer signedness error leads to negative array index:LINK:https://www.cve.org/CVERecord?id=CVE-2003-0721::REFERENCE:CVE-2004-1189:DESCRIPTION:product does not properly track a count and a maximum number, which can lead to resultant array index overflow.:LINK:https://www.cve.org/CVERecord?id=CVE-2004-1189::REFERENCE:CVE-2007-5756:DESCRIPTION:Chain: device driver for packet-capturing software allows access to an unintended IOCTL with resultant array index error.:LINK:https://www.cve.org/CVERecord?id=CVE-2007-5756::REFERENCE:CVE-2005-2456:DESCRIPTION:Chain: array index error (CWE-129) leads to deadlock (CWE-833):LINK:https://www.cve.org/CVERecord?id=CVE-2005-2456::",,::Memory::,"::TAXONOMY NAME:CLASP:ENTRY NAME:Unchecked array indexing::TAXONOMY NAME:PLOVER:ENTRY NAME:INDEX - Array index overflow::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:ARR00-C:ENTRY NAME:Understand how arrays work::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:ARR30-C:ENTRY NAME:Do not form or use out-of-bounds pointers or array subscripts:MAPPING FIT:CWE More Specific::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:ARR38-C:ENTRY NAME:Do not add or subtract an integer to a pointer if the resulting value does not refer to a valid array element::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:INT32-C:ENTRY NAME:Ensure that operations on signed integers do not result in overflow::TAXONOMY NAME:SEI CERT Perl Coding Standard:ENTRY ID:IDS32-PL:ENTRY NAME:Validate any integer that is used as an array index:MAPPING FIT:Imprecise::TAXONOMY NAME:OMG ASCSM:ENTRY ID:ASCSM-CWE-129::TAXONOMY NAME:Software Fault Patterns:ENTRY ID:SFP8:ENTRY NAME:Faulty Buffer Access::",::100::,"::TYPE:Relationship:NOTE:This weakness can precede uncontrolled memory allocation (CWE-789) in languages that automatically expand an array when an index is used that is larger than the size of the array, such as JavaScript.::TYPE:Theoretical:NOTE:An improperly validated array index might lead directly to the always-incorrect behavior of access of array using out-of-bounds index.::",