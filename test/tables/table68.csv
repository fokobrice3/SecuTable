CWE-ID,Name,Weakness Abstraction,Status,Description,Extended Description
400,Uncontrolled Resource Consumption,Class,Draft,The product does not properly control the allocation and maintenance of a limited resource, thereby enabling an actor to influence the amount of resources consumed, eventually leading to the exhaustion of available resources.,Limited resources include memory, file system storage, database connection pool entries, and CPU. If an attacker can trigger the allocation of these limited resources, but the number or size of the resources is not controlled, then the attacker could cause a denial of service that consumes all available resources. This would prevent valid users from accessing the product, and it could potentially have an impact on the surrounding environment. For example, a memory exhaustion attack against an application could slow down the application as well as its host operating system. There are at least three distinct scenarios which can commonly lead to resource exhaustion: Lack of throttling for the number of allocated resources Losing all references to a resource before reaching the shutdown stage Not closing/returning a resource after processing Resource exhaustion problems are often result due to an incorrect implementation of the following situations: Error conditions and other exceptional circumstances. Confusion over which part of the program is responsible for releasing the resource.
401,Missing Release of Memory after Effective Lifetime,Variant,Draft,The product does not sufficiently track and release allocated memory after it has been used, which slowly consumes remaining memory.,This is often triggered by improper handling of malformed data or unexpectedly interrupted sessions. In some languages, developers are responsible for tracking memory allocation and releasing the memory. If there are no more pointers or references to the memory, then it can no longer be tracked and identified for release.
402,Transmission of Private Resources into a New Sphere ('Resource Leak'),Class,Draft,The product makes resources available to untrusted parties when those resources are only intended to be accessed by the product.,
403,Exposure of File Descriptor to Unintended Control Sphere ('File Descriptor Leak'),Base,Draft,A process does not close sensitive file descriptors before invoking a child process, which allows the child to perform unauthorized I/O operations using those descriptors.,When a new process is forked or executed, the child process inherits any open file descriptors. When the child process has fewer privileges than the parent process, this might introduce a vulnerability if the child process can access the file descriptor but does not have the privileges to access the associated file.
404,Improper Resource Shutdown or Release,Class,Draft,The product does not release or incorrectly releases a resource before it is made available for re-use.,When a resource is created or allocated, the developer is responsible for properly releasing the resource as well as accounting for all potential paths of expiration or invalidation, such as a set period of time or revocation.
405,Asymmetric Resource Consumption (Amplification),Class,Incomplete,The product does not properly control situations in which an adversary can cause the product to consume or produce excessive resources without requiring the adversary to invest equivalent work or otherwise prove authorization, i.e., the adversary's influence is asymmetric.,This can lead to poor performance due to amplification of resource consumption, typically in a non-linear fashion. This situation is worsened if the product allows malicious users or attackers to consume more resources than their access level permits.
406,Insufficient Control of Network Message Volume (Network Amplification),Class,Incomplete,The product does not sufficiently monitor or control transmitted network traffic volume, so that an actor can cause the product to transmit more traffic than should be allowed for that actor.,In the absence of a policy to restrict asymmetric resource consumption, the application or system cannot distinguish between legitimate transmissions and traffic intended to serve as an amplifying attack on target systems. Systems can often be configured to restrict the amount of traffic sent out on behalf of a client, based on the client's origin or access level. This is usually defined in a resource allocation policy. In the absence of a mechanism to keep track of transmissions, the system or application can be easily abused to transmit asymmetrically greater traffic than the request or client should be permitted to.
407,Inefficient Algorithmic Complexity,Class,Incomplete,An algorithm in a product has an inefficient worst-case computational complexity that may be detrimental to system performance and can be triggered by an attacker, typically using crafted manipulations that ensure that the worst case is being reached.,
408,Incorrect Behavior Order: Early Amplification,Base,Draft,The product allows an entity to perform a legitimate but expensive operation before authentication or authorization has taken place.,
409,Improper Handling of Highly Compressed Data (Data Amplification),Base,Incomplete,The product does not handle or incorrectly handles a compressed input with a very high compression ratio that produces a large output.,An example of data amplification is a decompression bomb, a small ZIP file that can produce a large amount of data when it is decompressed.
410,Insufficient Resource Pool,Base,Incomplete,The product's resource pool is not large enough to handle peak demand, which allows an attacker to prevent others from accessing the resource by using a (relatively) large number of requests for resources.,Frequently the consequence is a flood of connection or sessions.
412,Unrestricted Externally Accessible Lock,Base,Incomplete,The product properly checks for the existence of a lock, but the lock can be externally controlled or influenced by an actor that is outside of the intended sphere of control.,This prevents the product from acting on associated resources or performing other behaviors that are controlled by the presence of the lock. Relevant locks might include an exclusive lock or mutex, or modifying a shared resource that is treated as a lock. If the lock can be held for an indefinite period of time, then the denial of service could be permanent.
413,Improper Resource Locking,Base,Draft,The product does not lock or does not correctly lock a resource when the product must have exclusive access to the resource.,When a resource is not properly locked, an attacker could modify the resource while it is being operated on by the product. This might violate the product's assumption that the resource will not change, potentially leading to unexpected behaviors.
414,Missing Lock Check,Base,Draft,A product does not check to see if a lock is present before performing sensitive operations on a resource.,
415,Double Free,Variant,Draft,The product calls free() twice on the same memory address, potentially leading to modification of unexpected memory locations.,When a program calls free() twice with the same argument, the program's memory management data structures become corrupted. This corruption can cause the program to crash or, in some circumstances, cause two later calls to malloc() to return the same pointer. If malloc() returns the same value twice and the program later gives the attacker control over the data that is written into this doubly-allocated memory, the program becomes vulnerable to a buffer overflow attack.
416,Use After Free,Variant,Stable,Referencing memory after it has been freed can cause a program to crash, use unexpected values, or execute code.,The use of previously-freed memory can have any number of adverse consequences, ranging from the corruption of valid data to the execution of arbitrary code, depending on the instantiation and timing of the flaw. The simplest way data corruption may occur involves the system's reuse of the freed memory. Use-after-free errors have two common and sometimes overlapping causes: Error conditions and other exceptional circumstances. Confusion over which part of the program is responsible for freeing the memory. In this scenario, the memory in question is allocated to another pointer validly at some point after it has been freed. The original pointer to the freed memory is used again and points to somewhere within the new allocation. As the data is changed, it corrupts the validly used memory; this induces undefined behavior in the process. If the newly allocated data happens to hold a class, in C++ for example, various function pointers may be scattered within the heap data. If one of these function pointers is overwritten with an address to valid shellcode, execution of arbitrary code can be achieved.
419,Unprotected Primary Channel,Base,Draft,The product uses a primary channel for administration or restricted functionality, but it does not properly protect the channel.,
420,Unprotected Alternate Channel,Base,Draft,The product protects a primary channel, but it does not use the same level of protection for an alternate channel.,
421,Race Condition During Access to Alternate Channel,Base,Draft,The product opens an alternate channel to communicate with an authorized user, but the channel is accessible to other actors.,This creates a race condition that allows an attacker to access the channel before the authorized user does.
422,Unprotected Windows Messaging Channel ('Shatter'),Variant,Draft,The product does not properly verify the source of a message in the Windows Messaging System while running at elevated privileges, creating an alternate channel through which an attacker can directly send a message to the product.,
424,Improper Protection of Alternate Path,Class,Draft,The product does not sufficiently protect all possible paths that a user can take to access restricted functionality or resources.,
425,Direct Request ('Forced Browsing'),Base,Incomplete,The web application does not adequately enforce appropriate authorization on all restricted URLs, scripts, or files.,Web applications susceptible to direct request attacks often make the false assumption that such resources can only be reached through a given navigation path and so only apply authorization at certain points in the path.
427,Uncontrolled Search Path Element,Base,Draft,The product uses a fixed or controlled search path to find resources, but one or more locations in that path can be under the control of unintended actors.,Although this weakness can occur with any type of resource, it is frequently introduced when a product uses a directory search path to find executables or code libraries, but the path contains a directory that can be modified by an attacker, such as /tmp or the current working directory. In Windows-based systems, when the LoadLibrary or LoadLibraryEx function is called with a DLL name that does not contain a fully qualified path, the function follows a search order that includes two path elements that might be uncontrolled: the directory from which the program has been loaded the current working directory In some cases, the attack can be conducted remotely, such as when SMB or WebDAV network shares are used. One or more locations in that path could include the Windows drive root or its subdirectories. This often exists in Linux-based code assuming the controlled nature of the root directory (/) or its subdirectories (/etc, etc), or a code that recursively accesses the parent directory. In Windows, the drive root and some of its subdirectories have weak permissions by default, which makes them uncontrolled. In some Unix-based systems, a PATH might be created that contains an empty element, e.g. by splicing an empty variable into the PATH. This empty element can be interpreted as equivalent to the current working directory, which might be an untrusted search element. In software package management frameworks (e.g., npm, RubyGems, or PyPi), the framework may identify dependencies on third-party libraries or other packages, then consult a repository that contains the desired package. The framework may search a public repository before a private repository. This could be exploited by attackers by placing a malicious package in the public repository that has the same name as a package from the private repository. The search path might not be directly under control of the developer relying on the framework, but this search order effectively contains an untrusted element.
428,Unquoted Search Path or Element,Base,Draft,The product uses a search path that contains an unquoted element, in which the element contains whitespace or other separators. This can cause the product to access resources in a parent path.,If a malicious individual has access to the file system, it is possible to elevate privileges by inserting such a file as C:Program.exe to be run by a privileged program making use of WinExec.
430,Deployment of Wrong Handler,Base,Incomplete,The wrong handler is assigned to process an object.,An example of deploying the wrong handler would be calling a servlet to reveal source code of a .JSP file, or automatically determining type of the object even if it is contradictory to an explicitly specified type.
431,Missing Handler,Base,Draft,A handler is not available or implemented.,When an exception is thrown and not caught, the process has given up an opportunity to decide if a given failure or event is worth a change in execution.
432,Dangerous Signal Handler not Disabled During Sensitive Operations,Base,Draft,The product uses a signal handler that shares state with other signal handlers, but it does not properly mask or prevent those signal handlers from being invoked while the original signal handler is still running.,During the execution of a signal handler, it can be interrupted by another handler when a different signal is sent. If the two handlers share state - such as global variables - then an attacker can corrupt the state by sending another signal before the first handler has completed execution.
433,Unparsed Raw Web Content Delivery,Variant,Incomplete,The product stores raw content or supporting code under the web document root with an extension that is not specifically handled by the server.,If code is stored in a file with an extension such as .inc or .pl, and the web server does not have a handler for that extension, then the server will likely send the contents of the file directly to the requester without the pre-processing that was expected. When that file contains sensitive information such as database credentials, this may allow the attacker to compromise the application or associated components.
435,Improper Interaction Between Multiple Correctly-Behaving Entities,Pillar,Draft,An interaction error occurs when two entities have correct behavior when running independently of each other, but when they are integrated as components in a larger system or process, they introduce incorrect behaviors that may cause resultant weaknesses.,When a system or process combines multiple independent components, this often produces new, emergent behaviors at the system level. However, if the interactions between these components are not fully accounted for, some of the emergent behaviors can be incorrect or even insecure.
436,Interpretation Conflict,Class,Incomplete,Product A handles inputs or steps differently than Product B, which causes A to perform incorrect actions based on its perception of B's state.,This is generally found in proxies, firewalls, anti-virus software, and other intermediary devices that monitor, allow, deny, or modify traffic based on how the client or server is expected to behave.
437,Incomplete Model of Endpoint Features,Base,Incomplete,A product acts as an intermediary or monitor between two or more endpoints, but it does not have a complete model of an endpoint's features, behaviors, or state, potentially causing the product to perform incorrect actions based on this incomplete model.,
439,Behavioral Change in New Version or Environment,Base,Draft,A's behavior or functionality changes with a new version of A, or a new environment, which is not known (or manageable) by B.,
440,Expected Behavior Violation,Base,Draft,A feature, API, or function does not perform according to its specification.,
441,Unintended Proxy or Intermediary ('Confused Deputy'),Class,Draft,The product receives a request, message, or directive from an upstream component, but the product does not sufficiently preserve the original source of the request before forwarding the request to an external actor that is outside of the product's control sphere. This causes the product to appear to be the source of the request, leading it to act as a proxy or other intermediary between the upstream component and the external actor.,If an attacker cannot directly contact a target, but the product has access to the target, then the attacker can send a request to the product and have it be forwarded to the target. The request would appear to be coming from the product's system, not the attacker's system. As a result, the attacker can bypass access controls (such as firewalls) or hide the source of malicious requests, since the requests would not be coming directly from the attacker. Since proxy functionality and message-forwarding often serve a legitimate purpose, this issue only becomes a vulnerability when: The product runs with different privileges or on a different system, or otherwise has different levels of access than the upstream component; The attacker is prevented from making the request directly to the target; and The attacker can create a request that the proxy does not explicitly intend to be forwarded on the behalf of the requester. Such a request might point to an unexpected hostname, port number, hardware IP, or service. Or, the request might be sent to an allowed service, but the request could contain disallowed directives, commands, or resources.
444,Inconsistent Interpretation of HTTP Requests ('HTTP Request/Response Smuggling'),Base,Incomplete,The product acts as an intermediary HTTP agent (such as a proxy or firewall) in the data flow between two entities such as a client and server, but it does not interpret malformed HTTP requests or responses in ways that are consistent with how the messages will be processed by those entities that are at the ultimate destination.,HTTP requests or responses (messages) can be malformed or unexpected in ways that cause web servers or clients to interpret the messages in different ways than intermediary HTTP agents such as load balancers, reverse proxies, web caching proxies, application firewalls, etc. For example, an adversary may be able to add duplicate or different header fields that a client or server might interpret as one set of messages, whereas the intermediary might interpret the same sequence of bytes as a different set of messages. For example, discrepancies can arise in how to handle duplicate headers like two Transfer-encoding (TE) or two Content-length (CL), or the malicious HTTP message will have different headers for TE and CL. The inconsistent parsing and interpretation of messages can allow the adversary to smuggle a message to the client/server without the intermediary being aware of it. This weakness is usually the result of the usage of outdated or incompatible HTTP protocol versions in the HTTP agents.
446,UI Discrepancy for Security Feature,Class,Incomplete,The user interface does not correctly enable or configure a security feature, but the interface provides feedback that causes the user to believe that the feature is in a secure state.,When the user interface does not properly reflect what the user asks of it, then it can lead the user into a false sense of security. For example, the user might check a box to enable a security option to enable encrypted communications, but the product does not actually enable the encryption. Alternately, the user might provide a restrict ALL access control rule, but the product only implements restrict SOME.
447,Unimplemented or Unsupported Feature in UI,Base,Draft,A UI function for a security feature appears to be supported and gives feedback to the user that suggests that it is supported, but the underlying functionality is not implemented.,
448,Obsolete Feature in UI,Base,Draft,A UI function is obsolete and the product does not warn the user.,
449,The UI Performs the Wrong Action,Base,Incomplete,The UI performs the wrong action with respect to the user's request.,
450,Multiple Interpretations of UI Input,Base,Draft,The UI has multiple interpretations of user input but does not prompt the user when it selects the less secure interpretation.,
451,User Interface (UI) Misrepresentation of Critical Information,Class,Draft,The user interface (UI) does not properly represent critical information to the user, allowing the information - or its source - to be obscured or spoofed. This is often a component in phishing attacks.,If an attacker can cause the UI to display erroneous data, or to otherwise convince the user to display information that appears to come from a trusted source, then the attacker could trick the user into performing the wrong action. This is often a component in phishing attacks, but other kinds of problems exist. For example, if the UI is used to monitor the security state of a system or network, then omitting or obscuring an important indicator could prevent the user from detecting and reacting to a security-critical event. UI misrepresentation can take many forms: Incorrect indicator: incorrect information is displayed, which prevents the user from understanding the true state of the product or the environment the product is monitoring, especially of potentially-dangerous conditions or operations. This can be broken down into several different subtypes. Overlay: an area of the display is intended to give critical information, but another process can modify the display by overlaying another element on top of it. The user is not interacting with the expected portion of the user interface. This is the problem that enables clickjacking attacks, although many other types of attacks exist that involve overlay. Icon manipulation: the wrong icon, or the wrong color indicator, can be influenced (such as making a dangerous .EXE executable look like a harmless .GIF) Timing: the product is performing a state transition or context switch that is presented to the user with an indicator, but a race condition can cause the wrong indicator to be used before the product has fully switched context. The race window could be extended indefinitely if the attacker can trigger an error. Visual truncation: important information could be truncated from the display, such as a long filename with a dangerous extension that is not displayed in the GUI because the malicious portion is truncated. The use of excessive whitespace can also cause truncation, or place the potentially-dangerous indicator outside of the user's field of view (e.g. filename.txt .exe). A different type of truncation can occur when a portion of the information is removed due to reasons other than length, such as the accidental insertion of an end-of-input marker in the middle of an input, such as a NUL byte in a C-style string. Visual distinction: visual information might be presented in a way that makes it difficult for the user to quickly and correctly distinguish between critical and unimportant segments of the display. Homographs: letters from different character sets, fonts, or languages can appear very similar (i.e. may be visually equivalent) in a way that causes the human user to misread the text (for example, to conduct phishing attacks to trick a user into visiting a malicious web site with a visually-similar name as a trusted site). This can be regarded as a type of visual distinction issue.
453,Insecure Default Variable Initialization,Variant,Draft,The product, by default, initializes an internal variable with an insecure or less secure value than is possible.,
454,External Initialization of Trusted Variables or Data Stores,Base,Draft,The product initializes critical internal variables or data stores using inputs that can be modified by untrusted actors.,A product system should be reluctant to trust variables that have been initialized outside of its trust boundary, especially if they are initialized by users. The variables may have been initialized incorrectly. If an attacker can initialize the variable, then they can influence what the vulnerable system will do.
455,Non-exit on Failed Initialization,Base,Draft,The product does not exit or otherwise modify its operation when security-relevant errors occur during initialization, such as when a configuration file has a format error or a hardware security module (HSM) cannot be activated, which can cause the product to execute in a less secure fashion than intended by the administrator.,
456,Missing Initialization of a Variable,Variant,Draft,The product does not initialize critical variables, which causes the execution environment to use unexpected values.,
457,Use of Uninitialized Variable,Variant,Draft,The code uses a variable that has not been initialized, leading to unpredictable or unintended results.,In some languages such as C and C++, stack variables are not initialized by default. They generally contain junk data with the contents of stack memory before the function was invoked. An attacker can sometimes control or read these contents. In other languages or conditions, a variable that is not explicitly initialized can be given a default value that has security implications, depending on the logic of the program. The presence of an uninitialized variable can sometimes indicate a typographic error in the code.
459,Incomplete Cleanup,Base,Draft,The product does not properly clean up and remove temporary or supporting resources after they have been used.,
460,Improper Cleanup on Thrown Exception,Base,Draft,The product does not clean up its state or incorrectly cleans up its state when an exception is thrown, leading to unexpected state or control flow.,Often, when functions or loops become complicated, some level of resource cleanup is needed throughout execution. Exceptions can disturb the flow of the code and prevent the necessary cleanup from happening.
462,Duplicate Key in Associative List (Alist),Base,Incomplete,Duplicate keys in associative lists can lead to non-unique keys being mistaken for an error.,A duplicate key entry -- if the alist is designed properly -- could be used as a constant time replace function. However, duplicate key entries could be inserted by mistake. Because of this ambiguity, duplicate key entries in an association list are not recommended and should not be allowed.
463,Deletion of Data Structure Sentinel,Base,Incomplete,The accidental deletion of a data-structure sentinel can cause serious programming logic problems.,Often times data-structure sentinels are used to mark structure of the data structure. A common example of this is the null character at the end of strings. Another common example is linked lists which may contain a sentinel to mark the end of the list. It is dangerous to allow this type of control data to be easily accessible. Therefore, it is important to protect from the deletion or modification outside of some wrapper interface which provides safety.
464,Addition of Data Structure Sentinel,Base,Incomplete,The accidental addition of a data-structure sentinel can cause serious programming logic problems.,Data-structure sentinels are often used to mark the structure of data. A common example of this is the null character at the end of strings or a special sentinel to mark the end of a linked list. It is dangerous to allow this type of control data to be easily accessible. Therefore, it is important to protect from the addition or modification of sentinels.
466,Return of Pointer Value Outside of Expected Range,Base,Draft,A function can return a pointer to memory that is outside of the buffer that the pointer is expected to reference.,
467,Use of sizeof() on a Pointer Type,Variant,Draft,The code calls sizeof() on a malloced pointer type, which always returns the wordsize/8. This can produce an unexpected result if the programmer intended to determine how much memory has been allocated.,The use of sizeof() on a pointer can sometimes generate useful information. An obvious case is to find out the wordsize on a platform. More often than not, the appearance of sizeof(pointer) indicates a bug.
468,Incorrect Pointer Scaling,Base,Incomplete,In C and C++, one may often accidentally refer to the wrong memory due to the semantics of when math operations are implicitly scaled.,
469,Use of Pointer Subtraction to Determine Size,Base,Draft,The product subtracts one pointer from another in order to determine size, but this calculation can be incorrect if the pointers do not exist in the same memory chunk.,
470,Use of Externally-Controlled Input to Select Classes or Code ('Unsafe Reflection'),Base,Draft,The product uses external input with reflection to select which classes or code to use, but it does not sufficiently prevent the input from selecting improper classes or code.,If the product uses external inputs to determine which class to instantiate or which method to invoke, then an attacker could supply values to select unexpected classes or methods. If this occurs, then the attacker could create control flow paths that were not intended by the developer. These paths could bypass authentication or access control checks, or otherwise cause the product to behave in an unexpected manner. This situation becomes a doomsday scenario if the attacker can upload files into a location that appears on the product's classpath (CWE-427) or add new entries to the product's classpath (CWE-426). Under either of these conditions, the attacker can use reflection to introduce new, malicious behavior into the product.
471,Modification of Assumed-Immutable Data (MAID),Base,Draft,The product does not properly protect an assumed-immutable element from being modified by an attacker.,This occurs when a particular input is critical enough to the functioning of the application that it should not be modifiable at all, but it is. Certain resources are often assumed to be immutable when they are not, such as hidden form fields in web applications, cookies, and reverse DNS lookups.
472,External Control of Assumed-Immutable Web Parameter,Base,Draft,The web application does not sufficiently verify inputs that are assumed to be immutable but are actually externally controllable, such as hidden form fields.,If a web product does not properly protect assumed-immutable values from modification in hidden form fields, parameters, cookies, or URLs, this can lead to modification of critical data. Web applications often mistakenly make the assumption that data passed to the client in hidden fields or cookies is not susceptible to tampering. Improper validation of data that are user-controllable can lead to the application processing incorrect, and often malicious, input. For example, custom cookies commonly store session data or persistent data across sessions. This kind of session data is normally involved in security related decisions on the server side, such as user authentication and access control. Thus, the cookies might contain sensitive data such as user credentials and privileges. This is a dangerous practice, as it can often lead to improper reliance on the value of the client-provided cookie by the server side application.
473,PHP External Variable Modification,Variant,Draft,A PHP application does not properly protect against the modification of variables from external sources, such as query parameters or cookies. This can expose the application to numerous weaknesses that would not exist otherwise.,
474,Use of Function with Inconsistent Implementations,Base,Draft,The code uses a function that has inconsistent implementations across operating systems and versions.,The use of inconsistent implementations can cause changes in behavior when the code is ported or built under a different environment than the programmer expects, which can lead to security problems in some cases. The implementation of many functions varies by platform, and at times, even by different versions of the same platform. Implementation differences can include: Slight differences in the way parameters are interpreted leading to inconsistent results. Some implementations of the function carry significant security risks. The function might not be defined on all platforms. The function might change which return codes it can provide, or change the meaning of its return codes.
475,Undefined Behavior for Input to API,Base,Incomplete,The behavior of this function is undefined unless its control parameter is set to a specific value.,
476,NULL Pointer Dereference,Base,Stable,A NULL pointer dereference occurs when the application dereferences a pointer that it expects to be valid, but is NULL, typically causing a crash or exit.,NULL pointer dereference issues can occur through a number of flaws, including race conditions, and simple programming omissions.
477,Use of Obsolete Function,Base,Draft,The code uses deprecated or obsolete functions, which suggests that the code has not been actively reviewed or maintained.,As programming languages evolve, functions occasionally become obsolete due to: Advances in the language Improved understanding of how operations should be performed effectively and securely Changes in the conventions that govern certain operations Functions that are removed are usually replaced by newer counterparts that perform the same task in some different and hopefully improved way.
478,Missing Default Case in Multiple Condition Expression,Base,Draft,The code does not have a default case in an expression with multiple conditions, such as a switch statement.,If a multiple-condition expression (such as a switch in C) omits the default case but does not consider or handle all possible values that could occur, then this might lead to complex logical errors and resultant weaknesses. Because of this, further decisions are made based on poor information, and cascading failure results. This cascading failure may result in any number of security issues, and constitutes a significant failure in the system.
479,Signal Handler Use of a Non-reentrant Function,Variant,Draft,The product defines a signal handler that calls a non-reentrant function.,Non-reentrant functions are functions that cannot safely be called, interrupted, and then recalled before the first call has finished without resulting in memory corruption. This can lead to an unexpected system state and unpredictable results with a variety of potential consequences depending on context, including denial of service and code execution. Many functions are not reentrant, but some of them can result in the corruption of memory if they are used in a signal handler. The function call syslog() is an example of this. In order to perform its functionality, it allocates a small amount of memory as scratch space. If syslog() is suspended by a signal call and the signal handler calls syslog(), the memory used by both of these functions enters an undefined, and possibly, exploitable state. Implementations of malloc() and free() manage metadata in global structures in order to track which memory is allocated versus which memory is available, but they are non-reentrant. Simultaneous calls to these functions can cause corruption of the metadata.
480,Use of Incorrect Operator,Base,Draft,The product accidentally uses the wrong operator, which changes the logic in security-relevant ways.,These types of errors are generally the result of a typo by the programmer.
481,Assigning instead of Comparing,Variant,Draft,The code uses an operator for assignment when the intention was to perform a comparison.,In many languages the compare statement is very close in appearance to the assignment statement and are often confused. This bug is generally the result of a typo and usually causes obvious problems with program execution. If the comparison is in an if statement, the if statement will usually evaluate the value of the right-hand side of the predicate.
482,Comparing instead of Assigning,Variant,Draft,The code uses an operator for comparison when the intention was to perform an assignment.,In many languages, the compare statement is very close in appearance to the assignment statement; they are often confused.
483,Incorrect Block Delimitation,Base,Draft,The code does not explicitly delimit a block that is intended to contain 2 or more statements, creating a logic error.,In some languages, braces (or other delimiters) are optional for blocks. When the delimiter is omitted, it is possible to insert a logic error in which a statement is thought to be in a block but is not. In some cases, the logic error can have security implications.
484,Omitted Break Statement in Switch,Base,Draft,The product omits a break statement within a switch or similar construct, causing code associated with multiple conditions to execute. This can cause problems when the programmer only intended to execute code associated with one condition.,This can lead to critical code executing in situations where it should not.
486,Comparison of Classes by Name,Variant,Draft,The product compares classes by name, which can cause it to use the wrong class when multiple classes can have the same name.,If the decision to trust the methods and data of an object is based on the name of a class, it is possible for malicious users to send objects of the same name as trusted classes and thereby gain the trust afforded to known classes and types.
487,Reliance on Package-level Scope,Base,Incomplete,Java packages are not inherently closed; therefore, relying on them for code security is not a good practice.,The purpose of package scope is to prevent accidental access by other parts of a program. This is an ease-of-software-development feature but not a security feature.
488,Exposure of Data Element to Wrong Session,Base,Draft,The product does not sufficiently enforce boundaries between the states of different sessions, causing data to be provided to, or used by, the wrong session.,Data can bleed from one session to another through member variables of singleton objects, such as Servlets, and objects from a shared pool. In the case of Servlets, developers sometimes do not understand that, unless a Servlet implements the SingleThreadModel interface, the Servlet is a singleton; there is only one instance of the Servlet, and that single instance is used and re-used to handle multiple requests that are processed simultaneously by different threads. A common result is that developers use Servlet member fields in such a way that one user may inadvertently see another user's data. In other words, storing user data in Servlet member fields introduces a data access race condition.
489,Active Debug Code,Base,Draft,The product is deployed to unauthorized actors with debugging code still enabled or active, which can create unintended entry points or expose sensitive information.,A common development practice is to add back door code specifically designed for debugging or testing purposes that is not intended to be shipped or deployed with the product. These back door entry points create security risks because they are not considered during design or testing and fall outside of the expected operating conditions of the product.
491,Public cloneable() Method Without Final ('Object Hijack'),Variant,Draft,A class has a cloneable() method that is not declared final, which allows an object to be created without calling the constructor. This can cause the object to be in an unexpected state.,
492,Use of Inner Class Containing Sensitive Data,Variant,Draft,Inner classes are translated into classes that are accessible at package scope and may expose code that the programmer intended to keep private to attackers.,Inner classes quietly introduce several security concerns because of the way they are translated into Java bytecode. In Java source code, it appears that an inner class can be declared to be accessible only by the enclosing class, but Java bytecode has no concept of an inner class, so the compiler must transform an inner class declaration into a peer class with package level access to the original outer class. More insidiously, since an inner class can access private fields in its enclosing class, once an inner class becomes a peer class in bytecode, the compiler converts private fields accessed by the inner class into protected fields.
493,Critical Public Variable Without Final Modifier,Variant,Draft,The product has a critical public variable that is not final, which allows the variable to be modified to contain unexpected values.,If a field is non-final and public, it can be changed once the value is set by any function that has access to the class which contains the field. This could lead to a vulnerability if other parts of the program make assumptions about the contents of that field.
494,Download of Code Without Integrity Check,Base,Draft,The product downloads source code or an executable from a remote location and executes the code without sufficiently verifying the origin and integrity of the code.,An attacker can execute malicious code by compromising the host server, performing DNS spoofing, or modifying the code in transit.
495,Private Data Structure Returned From A Public Method,Variant,Draft,The product has a method that is declared public, but returns a reference to a private data structure, which could then be modified in unexpected ways.,
496,Public Data Assigned to Private Array-Typed Field,Variant,Incomplete,Assigning public data to a private array is equivalent to giving public access to the array.,
497,Exposure of Sensitive System Information to an Unauthorized Control Sphere,Base,Incomplete,The product does not properly prevent sensitive system-level information from being accessed by unauthorized actors who do not have the same level of access to the underlying system as the product does.,Network-based products, such as web applications, often run on top of an operating system or similar environment. When the product communicates with outside parties, details about the underlying system are expected to remain hidden, such as path names for data files, other OS users, installed packages, the application environment, etc. This system information may be provided by the product itself, or buried within diagnostic or debugging messages. Debugging information helps an adversary learn about the system and form an attack plan. An information exposure occurs when system data or debugging information leaves the program through an output stream or logging function that makes it accessible to unauthorized parties. Using other weaknesses, an attacker could cause errors to occur; the response to these errors can reveal detailed system information, along with other impacts. An attacker can use messages that reveal technologies, operating systems, and product versions to tune the attack against known vulnerabilities in these technologies. A product may use diagnostic methods that provide significant implementation details such as stack traces as part of its error handling mechanism.
498,Cloneable Class Containing Sensitive Information,Variant,Draft,The code contains a class with sensitive data, but the class is cloneable. The data can then be accessed by cloning the class.,Cloneable classes are effectively open classes, since data cannot be hidden in them. Classes that do not explicitly deny cloning can be cloned by any other class without running the constructor.
499,Serializable Class Containing Sensitive Data,Variant,Draft,The code contains a class with sensitive data, but the class does not explicitly deny serialization. The data can be accessed by serializing the class through another class.,Serializable classes are effectively open classes since data cannot be hidden in them. Classes that do not explicitly deny serialization can be serialized by any other class, which can then in turn use the data stored inside it.
500,Public Static Field Not Marked Final,Variant,Draft,An object contains a public static field that is not marked final, which might allow it to be modified in unexpected ways.,Public static variables can be read without an accessor and changed without a mutator by any classes in the application.
501,Trust Boundary Violation,Base,Draft,The product mixes trusted and untrusted data in the same data structure or structured message.,A trust boundary can be thought of as line drawn through a program. On one side of the line, data is untrusted. On the other side of the line, data is assumed to be trustworthy. The purpose of validation logic is to allow data to safely cross the trust boundary - to move from untrusted to trusted. A trust boundary violation occurs when a program blurs the line between what is trusted and what is untrusted. By combining trusted and untrusted data in the same data structure, it becomes easier for programmers to mistakenly trust unvalidated data.
502,Deserialization of Untrusted Data,Base,Draft,The product deserializes untrusted data without sufficiently verifying that the resulting data will be valid.,It is often convenient to serialize objects for communication or to save them for later use. However, deserialized data or code can often be modified without using the provided accessor functions if it does not use cryptography to protect itself. Furthermore, any cryptography would still be client-side security -- which is a dangerous security assumption. Data that is untrusted can not be trusted to be well-formed. When developers place no restrictions on gadget chains, or series of instances and method invocations that can self-execute during the deserialization process (i.e., before the object is returned to the caller), it is sometimes possible for attackers to leverage them to perform unauthorized actions, like generating a shell.
506,Embedded Malicious Code,Class,Incomplete,The product contains code that appears to be malicious in nature.,Malicious flaws have acquired colorful names, including Trojan horse, trapdoor, timebomb, and logic-bomb. A developer might insert malicious code with the intent to subvert the security of a product or its host system at some time in the future. It generally refers to a program that performs a useful service but exploits rights of the program's user in a way the user does not intend.
507,Trojan Horse,Base,Incomplete,The product appears to contain benign or useful functionality, but it also contains code that is hidden from normal operation that violates the intended security policy of the user or the system administrator.,
508,Non-Replicating Malicious Code,Base,Incomplete,Non-replicating malicious code only resides on the target system or product that is attacked; it does not attempt to spread to other systems.,
509,Replicating Malicious Code (Virus or Worm),Base,Incomplete,Replicating malicious code, including viruses and worms, will attempt to attack other systems once it has successfully compromised the target system or the product.,
510,Trapdoor,Base,Incomplete,A trapdoor is a hidden piece of code that responds to a special input, allowing its user access to resources without passing through the normal security enforcement mechanism.,
511,Logic/Time Bomb,Base,Incomplete,The product contains code that is designed to disrupt the legitimate operation of the product (or its environment) when a certain time passes, or when a certain logical condition is met.,When the time bomb or logic bomb is detonated, it may perform a denial of service such as crashing the system, deleting critical data, or degrading system response time. This bomb might be placed within either a replicating or non-replicating Trojan horse.
512,Spyware,Base,Incomplete,The product collects personally identifiable information about a human user or the user's activities, but the product accesses this information using other resources besides itself, and it does not require that user's explicit approval or direct input into the product.,Spyware is a commonly used term with many definitions and interpretations. In general, it is meant to refer to products that collect information or install functionality that human users might not allow if they were fully aware of the actions being taken by the software. For example, a user might expect that tax software would collect a social security number and include it when filing a tax return, but that same user would not expect gaming software to obtain the social security number from that tax software's data.
514,Covert Channel,Class,Incomplete,A covert channel is a path that can be used to transfer information in a way not intended by the system's designers.,Typically the system has not given authorization for the transmission and has no knowledge of its occurrence.
515,Covert Storage Channel,Base,Incomplete,A covert storage channel transfers information through the setting of bits by one program and the reading of those bits by another. What distinguishes this case from that of ordinary operation is that the bits are used to convey encoded information.,Covert storage channels occur when out-of-band data is stored in messages for the purpose of memory reuse. Covert channels are frequently classified as either storage or timing channels. Examples would include using a file intended to hold only audit information to convey user passwords--using the name of a file or perhaps status bits associated with it that can be read by all users to signal the contents of the file. Steganography, concealing information in such a manner that no one but the intended recipient knows of the existence of the message, is a good example of a covert storage channel.
520,.NET Misconfiguration: Use of Impersonation,Variant,Incomplete,Allowing a .NET application to run at potentially escalated levels of access to the underlying operating and file systems can be dangerous and result in various forms of attacks.,.NET server applications can optionally execute using the identity of the user authenticated to the client. The intention of this functionality is to bypass authentication and access control checks within the .NET application code. Authentication is done by the underlying web server (Microsoft Internet Information Service IIS), which passes the authenticated token, or unauthenticated anonymous token, to the .NET application. Using the token to impersonate the client, the application then relies on the settings within the NTFS directories and files to control access. Impersonation enables the application, on the server running the .NET application, to both execute code and access resources in the context of the authenticated and authorized user.
521,Weak Password Requirements,Base,Draft,The product does not require that users should have strong passwords, which makes it easier for attackers to compromise user accounts.,Authentication mechanisms often rely on a memorized secret (also known as a password) to provide an assertion of identity for a user of a system. It is therefore important that this password be of sufficient complexity and impractical for an adversary to guess. The specific requirements around how complex a password needs to be depends on the type of system being protected. Selecting the correct password requirements and enforcing them through implementation are critical to the overall success of the authentication mechanism.
522,Insufficiently Protected Credentials,Class,Incomplete,The product transmits or stores authentication credentials, but it uses an insecure method that is susceptible to unauthorized interception and/or retrieval.,
523,Unprotected Transport of Credentials,Base,Incomplete,Login pages do not use adequate measures to protect the user name and password while they are in transit from the client to the server.,
524,Use of Cache Containing Sensitive Information,Base,Incomplete,The code uses a cache that contains sensitive information, but the cache can be read by an actor outside of the intended control sphere.,Applications may use caches to improve efficiency when communicating with remote entities or performing intensive calculations. A cache maintains a pool of objects, threads, connections, pages, financial data, passwords, or other resources to minimize the time it takes to initialize and access these resources. If the cache is accessible to unauthorized actors, attackers can read the cache and obtain this sensitive information.
525,Use of Web Browser Cache Containing Sensitive Information,Variant,Incomplete,The web application does not use an appropriate caching policy that specifies the extent to which each web page and associated form fields should be cached.,
526,Cleartext Storage of Sensitive Information in an Environment Variable,Variant,Incomplete,The product uses an environment variable to store unencrypted sensitive information.,Information stored in an environment variable can be accessible by other processes with the execution context, including child processes that dependencies are executed in, or serverless functions in cloud environments. An environment variable's contents can also be inserted into messages, headers, log files, or other outputs. Often these other dependencies have no need to use the environment variable in question. A weakness that discloses environment variables could expose this information.
527,Exposure of Version-Control Repository to an Unauthorized Control Sphere,Variant,Incomplete,The product stores a CVS, git, or other repository in a directory, archive, or other resource that is stored, transferred, or otherwise made accessible to unauthorized actors.,Version control repositories such as CVS or git store version-specific metadata and other details within subdirectories. If these subdirectories are stored on a web server or added to an archive, then these could be used by an attacker. This information may include usernames, filenames, path root, IP addresses, and detailed diff data about how files have been changed - which could reveal source code snippets that were never intended to be made public.
528,Exposure of Core Dump File to an Unauthorized Control Sphere,Variant,Draft,The product generates a core dump file in a directory, archive, or other resource that is stored, transferred, or otherwise made accessible to unauthorized actors.,
529,Exposure of Access Control List Files to an Unauthorized Control Sphere,Variant,Incomplete,The product stores access control list files in a directory or other container that is accessible to actors outside of the intended control sphere.,Exposure of these access control list files may give the attacker information about the configuration of the site or system. This information may then be used to bypass the intended security policy or identify trusted systems from which an attack can be launched.
530,Exposure of Backup File to an Unauthorized Control Sphere,Variant,Incomplete,A backup file is stored in a directory or archive that is made accessible to unauthorized actors.,Often, older backup files are renamed with an extension such as .~bk to distinguish them from production files. The source code for old files that have been renamed in this manner and left in the webroot can often be retrieved. This renaming may have been performed automatically by the web server, or manually by the administrator.
531,Inclusion of Sensitive Information in Test Code,Variant,Incomplete,Accessible test applications can pose a variety of security risks. Since developers or administrators rarely consider that someone besides themselves would even know about the existence of these applications, it is common for them to contain sensitive information or functions.,
532,Insertion of Sensitive Information into Log File,Base,Incomplete,Information written to log files can be of a sensitive nature and give valuable guidance to an attacker or expose sensitive user information.,While logging all information may be helpful during development stages, it is important that logging levels be set appropriately before a product ships so that sensitive user data and system information are not accidentally exposed to potential attackers. Different log files may be produced and stored for: Server log files (e.g. server.log). This can give information on whatever application left the file. Usually this can give full path names and system information, and sometimes usernames and passwords. log files that are used for debugging
535,Exposure of Information Through Shell Error Message,Variant,Incomplete,A command shell error message indicates that there exists an unhandled exception in the web application code. In many cases, an attacker can leverage the conditions that cause these errors in order to gain unauthorized access to the system.,
536,Servlet Runtime Error Message Containing Sensitive Information,Variant,Incomplete,A servlet error message indicates that there exists an unhandled exception in your web application code and may provide useful information to an attacker.,
537,Java Runtime Error Message Containing Sensitive Information,Variant,Incomplete,In many cases, an attacker can leverage the conditions that cause unhandled exception errors in order to gain unauthorized access to the system.,
538,Insertion of Sensitive Information into Externally-Accessible File or Directory,Base,Draft,The product places sensitive information into files or directories that are accessible to actors who are allowed to have access to the files, but not to the sensitive information.,
539,Use of Persistent Cookies Containing Sensitive Information,Variant,Incomplete,The web application uses persistent cookies, but the cookies contain sensitive information.,Cookies are small bits of data that are sent by the web application but stored locally in the browser. This lets the application use the cookie to pass information between pages and store variable information. The web application controls what information is stored in a cookie and how it is used. Typical types of information stored in cookies are session identifiers, personalization and customization information, and in rare cases even usernames to enable automated logins. There are two different types of cookies: session cookies and persistent cookies. Session cookies just live in the browser's memory and are not stored anywhere, but persistent cookies are stored on the browser's hard drive. This can cause security and privacy issues depending on the information stored in the cookie and how it is accessed.
540,Inclusion of Sensitive Information in Source Code,Base,Incomplete,Source code on a web server or repository often contains sensitive information and should generally not be accessible to users.,There are situations where it is critical to remove source code from an area or server. For example, obtaining Perl source code on a system allows an attacker to understand the logic of the script and extract extremely useful information such as code bugs or logins and passwords.
541,Inclusion of Sensitive Information in an Include File,Variant,Incomplete,If an include file source is accessible, the file can contain usernames and passwords, as well as sensitive information pertaining to the application and system.,
543,Use of Singleton Pattern Without Synchronization in a Multithreaded Context,Variant,Incomplete,The product uses the singleton pattern when creating a resource within a multithreaded environment.,The use of a singleton pattern may not be thread-safe.
544,Missing Standardized Error Handling Mechanism,Base,Draft,The product does not use a standardized method for handling errors throughout the code, which might introduce inconsistent error handling and resultant weaknesses.,If the product handles error messages individually, on a one-by-one basis, this is likely to result in inconsistent error handling. The causes of errors may be lost. Also, detailed information about the causes of an error may be unintentionally returned to the user.
546,Suspicious Comment,Variant,Draft,The code contains comments that suggest the presence of bugs, incomplete functionality, or weaknesses.,Many suspicious comments, such as BUG, HACK, FIXME, LATER, LATER2, TODO, in the code indicate missing security functionality and checking. Others indicate code problems that programmers should fix, such as hard-coded variables, error handling, not using stored procedures, and performance issues.
547,Use of Hard-coded, Security-relevant Constants,Variant,Draft,The product uses hard-coded constants instead of symbolic names for security-critical values, which increases the likelihood of mistakes during code maintenance or security policy change.,If the developer does not find all occurrences of the hard-coded constants, an incorrect policy decision may be made if one of the constants is not changed. Making changes to these values will require code changes that may be difficult or impossible once the system is released to the field. In addition, these hard-coded values may become available to attackers if the code is ever disclosed.
548,Exposure of Information Through Directory Listing,Variant,Draft,A directory listing is inappropriately exposed, yielding potentially sensitive information to attackers.,A directory listing provides an attacker with the complete index of all the resources located inside of the directory. The specific risks and consequences vary depending on which files are listed and accessible.
549,Missing Password Field Masking,Base,Draft,The product does not mask passwords during entry, increasing the potential for attackers to observe and capture passwords.,
550,Server-generated Error Message Containing Sensitive Information,Variant,Incomplete,Certain conditions, such as network failure, will cause a server error message to be displayed.,While error messages in and of themselves are not dangerous, per se, it is what an attacker can glean from them that might cause eventual problems.
551,Incorrect Behavior Order: Authorization Before Parsing and Canonicalization,Base,Incomplete,If a web server does not fully parse requested URLs before it examines them for authorization, it may be possible for an attacker to bypass authorization protection.,For instance, the character strings /./ and / both mean current directory. If /SomeDirectory is a protected directory and an attacker requests /./SomeDirectory, the attacker may be able to gain access to the resource if /./ is not converted to / before the authorization check is performed.
552,Files or Directories Accessible to External Parties,Base,Draft,The product makes files or directories accessible to unauthorized actors, even though they should not be.,Web servers, FTP servers, and similar servers may store a set of files underneath a root directory that is accessible to the server's users. Applications may store sensitive files underneath this root without also using access control to limit which users may request those files, if any. Alternately, an application might package multiple files or directories into an archive file (e.g., ZIP or tar), but the application might not exclude sensitive files that are underneath those directories. In cloud technologies and containers, this weakness might present itself in the form of public (i.e., anonymous) access being allowed/overwritten to storage accounts.
553,Command Shell in Externally Accessible Directory,Variant,Incomplete,A possible shell file exists in /cgi-bin/ or other accessible directories. This is extremely dangerous and can be used by an attacker to execute commands on the web server.,
554,ASP.NET Misconfiguration: Not Using Input Validation Framework,Variant,Draft,The ASP.NET application does not use an input validation framework.,
555,J2EE Misconfiguration: Plaintext Password in Configuration File,Variant,Draft,The J2EE application stores a plaintext password in a configuration file.,Storing a plaintext password in a configuration file allows anyone who can read the file to access the password-protected resource, making it an easy target for attackers.
556,ASP.NET Misconfiguration: Use of Identity Impersonation,Variant,Incomplete,Configuring an ASP.NET application to run with impersonated credentials may give the application unnecessary privileges.,The use of impersonated credentials allows an ASP.NET application to run with either the privileges of the client on whose behalf it is executing or with arbitrary privileges granted in its configuration.
558,Use of getlogin() in Multithreaded Application,Variant,Draft,The product uses the getlogin() function in a multithreaded context, potentially causing it to return incorrect values.,The getlogin() function returns a pointer to a string that contains the name of the user associated with the calling process. The function is not reentrant, meaning that if it is called from another process, the contents are not locked out and the value of the string can be changed by another process. This makes it very risky to use because the username can be changed by other processes, so the results of the function cannot be trusted.
560,Use of umask() with chmod-style Argument,Variant,Draft,The product calls umask() with an incorrect argument that is specified as if it is an argument to chmod().,
561,Dead Code,Base,Draft,The product contains dead code, which can never be executed.,Dead code is code that can never be executed in a running program. The surrounding code makes it impossible for a section of code to ever be executed.
562,Return of Stack Variable Address,Base,Draft,A function returns the address of a stack variable, which will cause unintended program behavior, typically in the form of a crash.,Because local variables are allocated on the stack, when a program returns a pointer to a local variable, it is returning a stack address. A subsequent function call is likely to re-use this same stack address, thereby overwriting the value of the pointer, which no longer corresponds to the same variable since a function's stack frame is invalidated when it returns. At best this will cause the value of the pointer to change unexpectedly. In many cases it causes the program to crash the next time the pointer is dereferenced.
563,Assignment to Variable without Use,Variant,Draft,The variable's value is assigned but never used, making it a dead store.,After the assignment, the variable is either assigned another value or goes out of scope. It is likely that the variable is simply vestigial, but it is also possible that the unused variable points out a bug.
564,SQL Injection: Hibernate,Variant,Incomplete,Using Hibernate to execute a dynamic SQL statement built with user-controlled input can allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.,
565,Reliance on Cookies without Validation and Integrity Checking,Base,Incomplete,The product relies on the existence or values of cookies when performing security-critical operations, but it does not properly ensure that the setting is valid for the associated user.,Attackers can easily modify cookies, within the browser or by implementing the client-side code outside of the browser. Reliance on cookies without detailed validation and integrity checking can allow attackers to bypass authentication, conduct injection attacks such as SQL injection and cross-site scripting, or otherwise modify inputs in unexpected ways.
566,Authorization Bypass Through User-Controlled SQL Primary Key,Variant,Incomplete,The product uses a database table that includes records that should not be accessible to an actor, but it executes a SQL statement with a primary key that can be controlled by that actor.,When a user can set a primary key to any value, then the user can modify the key to point to unauthorized records. Database access control errors occur when: Data enters a program from an untrusted source. The data is used to specify the value of a primary key in a SQL query. The untrusted source does not have the permissions to be able to access all rows in the associated table.
567,Unsynchronized Access to Shared Data in a Multithreaded Context,Base,Draft,The product does not properly synchronize shared data, such as static variables across threads, which can lead to undefined behavior and unpredictable data changes.,Within servlets, shared static variables are not protected from concurrent access, but servlets are multithreaded. This is a typical programming mistake in J2EE applications, since the multithreading is handled by the framework. When a shared variable can be influenced by an attacker, one thread could wind up modifying the variable to contain data that is not valid for a different thread that is also using the data within the variable. Note that this weakness is not unique to servlets.
568,finalize() Method Without super.finalize(),Variant,Draft,The product contains a finalize() method that does not call super.finalize().,The Java Language Specification states that it is a good practice for a finalize() method to call super.finalize().
570,Expression is Always False,Base,Draft,The product contains an expression that will always evaluate to false.,
571,Expression is Always True,Base,Draft,The product contains an expression that will always evaluate to true.,
572,Call to Thread run() instead of start(),Variant,Draft,The product calls a thread's run() method instead of calling start(), which causes the code to run in the thread of the caller instead of the callee.,In most cases a direct call to a Thread object's run() method is a bug. The programmer intended to begin a new thread of control, but accidentally called run() instead of start(), so the run() method will execute in the caller's thread of control.
573,Improper Following of Specification by Caller,Class,Draft,The product does not follow or incorrectly follows the specifications as required by the implementation language, environment, framework, protocol, or platform.,When leveraging external functionality, such as an API, it is important that the caller does so in accordance with the requirements of the external functionality or else unintended behaviors may result, possibly leaving the system vulnerable to any number of exploits.
574,EJB Bad Practices: Use of Synchronization Primitives,Variant,Draft,The product violates the Enterprise JavaBeans (EJB) specification by using thread synchronization primitives.,The Enterprise JavaBeans specification requires that every bean provider follow a set of programming guidelines designed to ensure that the bean will be portable and behave consistently in any EJB container. In this case, the product violates the following EJB guideline: An enterprise bean must not use thread synchronization primitives to synchronize execution of multiple instances. The specification justifies this requirement in the following way: This rule is required to ensure consistent runtime semantics because while some EJB containers may use a single JVM to execute all enterprise bean's instances, others may distribute the instances across multiple JVMs.
575,EJB Bad Practices: Use of AWT Swing,Variant,Draft,The product violates the Enterprise JavaBeans (EJB) specification by using AWT/Swing.,The Enterprise JavaBeans specification requires that every bean provider follow a set of programming guidelines designed to ensure that the bean will be portable and behave consistently in any EJB container. In this case, the product violates the following EJB guideline: An enterprise bean must not use the AWT functionality to attempt to output information to a display, or to input information from a keyboard. The specification justifies this requirement in the following way: Most servers do not allow direct interaction between an application program and a keyboard/display attached to the server system.
576,EJB Bad Practices: Use of Java I/O,Variant,Draft,The product violates the Enterprise JavaBeans (EJB) specification by using the java.io package.,The Enterprise JavaBeans specification requires that every bean provider follow a set of programming guidelines designed to ensure that the bean will be portable and behave consistently in any EJB container. In this case, the product violates the following EJB guideline: An enterprise bean must not use the java.io package to attempt to access files and directories in the file system. The specification justifies this requirement in the following way: The file system APIs are not well-suited for business components to access data. Business components should use a resource manager API, such as JDBC, to store data.
577,EJB Bad Practices: Use of Sockets,Variant,Draft,The product violates the Enterprise JavaBeans (EJB) specification by using sockets.,The Enterprise JavaBeans specification requires that every bean provider follow a set of programming guidelines designed to ensure that the bean will be portable and behave consistently in any EJB container. In this case, the product violates the following EJB guideline: An enterprise bean must not attempt to listen on a socket, accept connections on a socket, or use a socket for multicast. The specification justifies this requirement in the following way: The EJB architecture allows an enterprise bean instance to be a network socket client, but it does not allow it to be a network server. Allowing the instance to become a network server would conflict with the basic function of the enterprise bean-- to serve the EJB clients.
578,EJB Bad Practices: Use of Class Loader,Variant,Draft,The product violates the Enterprise JavaBeans (EJB) specification by using the class loader.,The Enterprise JavaBeans specification requires that every bean provider follow a set of programming guidelines designed to ensure that the bean will be portable and behave consistently in any EJB container. In this case, the product violates the following EJB guideline: The enterprise bean must not attempt to create a class loader; obtain the current class loader; set the context class loader; set security manager; create a new security manager; stop the JVM; or change the input, output, and error streams. The specification justifies this requirement in the following way: These functions are reserved for the EJB container. Allowing the enterprise bean to use these functions could compromise security and decrease the container's ability to properly manage the runtime environment.
579,J2EE Bad Practices: Non-serializable Object Stored in Session,Variant,Draft,The product stores a non-serializable object as an HttpSession attribute, which can hurt reliability.,A J2EE application can make use of multiple JVMs in order to improve application reliability and performance. In order to make the multiple JVMs appear as a single application to the end user, the J2EE container can replicate an HttpSession object across multiple JVMs so that if one JVM becomes unavailable another can step in and take its place without disrupting the flow of the application. This is only possible if all session data is serializable, allowing the session to be duplicated between the JVMs.
580,clone() Method Without super.clone(),Variant,Draft,The product contains a clone() method that does not call super.clone() to obtain the new object.,All implementations of clone() should obtain the new object by calling super.clone(). If a class does not follow this convention, a subclass's clone() method will return an object of the wrong type.
581,Object Model Violation: Just One of Equals and Hashcode Defined,Base,Draft,The product does not maintain equal hashcodes for equal objects.,Java objects are expected to obey a number of invariants related to equality. One of these invariants is that equal objects must have equal hashcodes. In other words, if a.equals(b) == true then a.hashCode() == b.hashCode().
582,Array Declared Public, Final, and Static,Variant,Draft,The product declares an array public, final, and static, which is not sufficient to prevent the array's contents from being modified.,Because arrays are mutable objects, the final constraint requires that the array object itself be assigned only once, but makes no guarantees about the values of the array elements. Since the array is public, a malicious program can change the values stored in the array. As such, in most cases an array declared public, final and static is a bug.
583,finalize() Method Declared Public,Variant,Incomplete,The product violates secure coding principles for mobile code by declaring a finalize() method public.,A product should never call finalize explicitly, except to call super.finalize() inside an implementation of finalize(). In mobile code situations, the otherwise error prone practice of manual garbage collection can become a security threat if an attacker can maliciously invoke a finalize() method because it is declared with public access.
584,Return Inside Finally Block,Base,Draft,The code has a return statement inside a finally block, which will cause any thrown exception in the try block to be discarded.,
585,Empty Synchronized Block,Base,Draft,The product contains an empty synchronized block.,An empty synchronized block does not actually accomplish any synchronization and may indicate a troubled section of code. An empty synchronized block can occur because code no longer needed within the synchronized block is commented out without removing the synchronized block.
586,Explicit Call to Finalize(),Variant,Draft,The product makes an explicit call to the finalize() method from outside the finalizer.,While the Java Language Specification allows an object's finalize() method to be called from outside the finalizer, doing so is usually a bad idea. For example, calling finalize() explicitly means that finalize() will be called more than once: the first time will be the explicit call and the last time will be the call that is made after the object is garbage collected.
587,Assignment of a Fixed Address to a Pointer,Base,Draft,The product sets a pointer to a specific address other than NULL or 0.,Using a fixed address is not portable, because that address will probably not be valid in all environments or platforms.
588,Attempt to Access Child of a Non-structure Pointer,Variant,Incomplete,Casting a non-structure type to a structure type and accessing a field can lead to memory access errors or data corruption.,
589,Call to Non-ubiquitous API,Variant,Incomplete,The product uses an API function that does not exist on all versions of the target platform. This could cause portability problems or inconsistencies that allow denial of service or other consequences.,Some functions that offer security features supported by the OS are not available on all versions of the OS in common use. Likewise, functions are often deprecated or made obsolete for security reasons and should not be used.
590,Free of Memory not on the Heap,Variant,Incomplete,The product calls free() on a pointer to memory that was not allocated using associated heap allocation functions such as malloc(), calloc(), or realloc().,When free() is called on an invalid pointer, the program's memory management data structures may become corrupted. This corruption can cause the program to crash or, in some circumstances, an attacker may be able to cause free() to operate on controllable memory locations to modify critical program variables or execute code.
591,Sensitive Data Storage in Improperly Locked Memory,Variant,Draft,The product stores sensitive data in memory that is not locked, or that has been incorrectly locked, which might cause the memory to be written to swap files on disk by the virtual memory manager. This can make the data more accessible to external actors.,On Windows systems the VirtualLock function can lock a page of memory to ensure that it will remain present in memory and not be swapped to disk. However, on older versions of Windows, such as 95, 98, or Me, the VirtualLock() function is only a stub and provides no protection. On POSIX systems the mlock() call ensures that a page will stay resident in memory but does not guarantee that the page will not appear in the swap. Therefore, it is unsuitable for use as a protection mechanism for sensitive data. Some platforms, in particular Linux, do make the guarantee that the page will not be swapped, but this is non-standard and is not portable. Calls to mlock() also require supervisor privilege. Return values for both of these calls must be checked to ensure that the lock operation was actually successful.
593,Authentication Bypass: OpenSSL CTX Object Modified after SSL Objects are Created,Variant,Draft,The product modifies the SSL context after connection creation has begun.,If the program modifies the SSL_CTX object after creating SSL objects from it, there is the possibility that older SSL objects created from the original context could all be affected by that change.
